<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Rasterization Demos</title>

  <link rel="shortcut icon" type="image/x-icon" href="../assets/logo-v1.svg">
  <link rel="stylesheet" href="../../sherpa/lib/bootstrap-2.2.2.css">
  <link rel="stylesheet" href="../../sherpa/lib/bootstrap-responsive-2.2.2.css">
  <link rel="stylesheet" href="../../sherpa/lib/syntaxhighlighter-3.0.83/shCore.css">
  <link rel="stylesheet" href="../../sherpa/lib/syntaxhighlighter-3.0.83/shThemeDefault.css">
  <link rel="stylesheet" href="../assets/scenery.css">

  <!-- Before loading other things (that might error), create hooks to report errors/loads for continuous testing -->
  <script src="../../chipper/js/sim-tests/pageload-connector.js"></script>

  <!-- jQuery and LoDash are dependencies -->
  <script src="../../sherpa/lib/jquery-2.1.0.min.js"></script>
  <script src="../../sherpa/lib/lodash-4.17.4.min.js"></script>

  <!-- For the styling -->
  <script src="../../sherpa/lib/bootstrap-2.2.2.js"></script>

  <link rel="stylesheet" href="../../sherpa/lib/highlightjs-11.5.1-a11y-light.min.css">
  <script src="../../sherpa/lib/highlightjs-11.5.1.min.js"></script>

  <script src="./teapotObj.js"></script>

  <style>

  </style>
</head>

<body>

<!-- Our code, in either the concatenated 'with comments' version or the minified version -->
<!--<script src="../dist/scenery.debug.js"></script>-->
<script src="../dist/scenery.min.js"></script>

<script type="text/javascript">
  phet.scenery.Utils.polyfillRequestAnimationFrame();

  _.extend( window, phet.phetCore );
  _.extend( window, phet.axon );
  _.extend( window, phet.dot );
  _.extend( window, phet.kite );
  _.extend( window, phet.scenery );

  const colors = [
    new Color( 62, 171, 3 ),
    new Color( 23, 180, 77 ),
    new Color( 24, 183, 138 ),
    new Color( 23, 178, 194 ),
    new Color( 20, 163, 238 ),
    new Color( 71, 136, 255 ),
    new Color( 171, 101, 255 ),
    new Color( 228, 72, 235 ),
    new Color( 252, 66, 186 ),
    new Color( 252, 82, 127 )
  ];

  const piecewiseOptions = {
    minLevels: 1,
    maxLevels: 10,
    // distanceEpsilon: 0.02,
    distanceEpsilon: 0.0002,
    curveEpsilon: 0.2
  };
  const shapeToPolygons = shape => shape.subpaths.map( subpath => {
    return subpath.toPiecewiseLinear( piecewiseOptions ).segments.map( line => {
      return line.start;
    } );
  } );

  const sizeCanvas = canvas => {
    canvas.style.width = `${canvas.width / window.devicePixelRatio}px`;
    canvas.style.height = `${canvas.height / window.devicePixelRatio}px`;
  };

  const getSceneryElement = ( node, width, height, background, renderer ) => {
    const subdiv = document.createElement( 'div' );
    const scene = new Node( { renderer: renderer } );
    const display = new Display( scene, {
      width: width,
      height: height,
      accessibility: true,
      container: subdiv
    } );

    display.width = width;
    display.height = height;
    scene.addChild( node );
    display.backgroundColor = background;
    display.updateDisplay();
    scene.removeChild( node );
    return subdiv;
  };

  // composite Rasterize/CombinedRaster options
  const getRasterizedElement = ( renderProgram, width, height, options ) => {
    const program = renderProgram.transformed( Matrix3.scaling( window.devicePixelRatio ) );

    const outputWidth = width * window.devicePixelRatio;
    const outputHeight = height * window.devicePixelRatio;

    const raster = new CombinedRaster( outputWidth, outputHeight, options );
    Rasterize.rasterize( program, raster, new Bounds2( 0, 0, outputWidth, outputHeight ), options );
    const canvas = Rasterize.imageDataToCanvas( raster.toImageData() );
    sizeCanvas( canvas );
    return canvas;
  };

  const getFiltered = ( filter, multiplier ) => {
    const width = 150;
    const height = 150;

    const program = new RenderStack( [
      new RenderPathBoolean(
        new RenderPath( 'nonzero', [ [
          phet.dot.v2( 30, 30 ),
          phet.dot.v2( 120, 30 ),
          phet.dot.v2( 120, 120 ),
          phet.dot.v2( 30, 120 )
        ], [
          phet.dot.v2( 35, 35 ),
          phet.dot.v2( 45, 105 ),
          phet.dot.v2( 90, 90 ),
          phet.dot.v2( 105, 35 )
        ] ] ),
        RenderColor.from( 'black' ),
        RenderColor.from( 'white' )
      ),
      new RenderPathBoolean(
        new RenderPath( 'nonzero', [
          ...shapeToPolygons( Shape.regularPolygon( 20, 5 ).transformed( Matrix3.translation( 100, 100 ) ) )
        ] ),
        RenderColor.from( 'red' ),
        RenderColor.TRANSPARENT
      ),
      new RenderPathBoolean(
        new RenderPath( 'nonzero', [ [
          phet.dot.v2( 50, 50 ),
          phet.dot.v2( 45, 105 ),
          phet.dot.v2( 90, 90 ),
        ] ] ),
        RenderColor.from( 'blue' ),
        RenderColor.TRANSPARENT
      )
    ] );

    return getRasterizedElement( program, width, height, {
      polygonFiltering: filter,
      polygonFilterWindowMultiplier: multiplier * window.devicePixelRatio
    } );
  };

  const getGradientAliasing = ( type ) => {
    const width = 128;
    const height = 128;

    const addColorStops = gradient => {
      gradient.addColorStop( 0, 'black' );

      for ( let i = 0.2; i < 0.3; i += 0.05 ) {
        gradient.addColorStop( i, 'white' );
        gradient.addColorStop( i + 0.0001, 'black' );
      }
      for ( let i = 0.3; i < 0.4; i += 0.025269 ) {
        gradient.addColorStop( i, 'white' );
        gradient.addColorStop( i + 0.0001, 'blue' );
      }
      for ( let i = 0.4; i < 0.5; i += 0.01 ) {
        gradient.addColorStop( i, 'white' );
        gradient.addColorStop( i + 0.0001, 'black' );
      }
      for ( let i = 0.5; i < 0.6; i += 0.005 ) {
        gradient.addColorStop( i, 'white' );
        gradient.addColorStop( i + 0.0001, 'red' );
      }
      gradient.addColorStop( 0.6, 'white' );
      gradient.addColorStop( 0.7, 'black' );
      gradient.addColorStop( 0.7001, 'white' );
      gradient.addColorStop( 0.8, 'black' );
      gradient.addColorStop( 0.8001, 'white' );
      gradient.addColorStop( 0.81, 'black' );
      gradient.addColorStop( 0.95, 'white' );
      gradient.addColorStop( 0.951, 'black' );
      gradient.addColorStop( 0.952, 'white' );
      gradient.addColorStop( 0.96, 'white' );
      gradient.addColorStop( 0.962, 'black' );
      gradient.addColorStop( 0.964, 'white' );
      gradient.addColorStop( 0.97, 'white' );
      gradient.addColorStop( 0.973, 'black' );
      gradient.addColorStop( 0.976, 'white' );
      gradient.addColorStop( 0.98, 'white' );
      gradient.addColorStop( 0.984, 'black' );
      gradient.addColorStop( 0.988, 'white' );
      gradient.addColorStop( 1, 'black' );
    };

    const linear = new LinearGradient( 10, 10, 118, 20 );
    addColorStops( linear );

    // Oops, tricky to get these to match up exactly.
    const delta = v2( 108, 10 );
    const center = phet.dot.Utils.lineLineIntersection( v2( 10, 10 ), v2( 10, 10 ).plus( delta.perpendicular ), v2( 0, 64 ), v2( 128, 64 ) );
    const radius = delta.magnitude;
    const rightPoint = phet.dot.Utils.lineLineIntersection( center, center.plus( delta ), v2( 128, 0 ), v2( 128, 128 ) );

    const radial = new RadialGradient( center.x, center.y, 0, center.x, center.y, radius );
    addColorStops( radial );

    const scene = new Node( {
      children: [
        new Path( Shape.polygon( [
          v2( 0, 0 ),
          v2( 128, 0 ),
          rightPoint,
          center,
          v2( 0, 64 )
        ] ), { fill: linear } ),
        new Path( Shape.polygon( [
          center,
          rightPoint,
          v2( 128, 128 ),
          v2( 0, 128 ),
          v2( 0, 64 )
        ] ), { fill: radial } )
      ]
    } );

    if ( type === 'svg' || type === 'canvas' || type === 'vello' ) {
      return getSceneryElement(
        scene, width, height, 'white', type
      );
    }
    else if ( type === 'box' || type === 'bilinear' || type === 'mitchellNetravali' ) {
      const filtering = {
        box: PolygonFilterType.Box,
        bilinear: PolygonFilterType.Bilinear,
        mitchellNetravali: PolygonFilterType.MitchellNetravali
      }[ type ];
      const program = RenderFromNode.addBackgroundColor( RenderFromNode.nodeToRenderProgram( scene ), Color.WHITE );

      return getRasterizedElement( program, width, height, {
        polygonFiltering: filtering
      } );
    }
  };

  const getGradientPrecision = ( type ) => {
    const width = 128;
    const height = 128;

    // const left = -3000;
    // const right = 3000;

    const left = 0;
    const right = 6000;

    const ratioLeft = ( 0 - left ) / ( right - left );
    const ratioRight = ( width - left ) / ( right - left );

    const newRatio = ratio => ratioLeft + ratio * ( ratioRight - ratioLeft );

    const addColorStops = gradient => {
      gradient.addColorStop( 0, 'black' );

      gradient.addColorStop( newRatio( 0 ), 'white' );
      gradient.addColorStop( newRatio( 0.5 ), 'black' );
      gradient.addColorStop( newRatio( 0.70 ), 'white' );
      gradient.addColorStop( newRatio( 0.74 ), 'black' );
      gradient.addColorStop( newRatio( 0.78 ), 'white' );
      gradient.addColorStop( newRatio( 0.80 ), 'white' );
      gradient.addColorStop( newRatio( 0.82 ), 'black' );
      gradient.addColorStop( newRatio( 0.84 ), 'white' );
      gradient.addColorStop( newRatio( 0.86 ), 'white' );
      gradient.addColorStop( newRatio( 0.87 ), 'black' );
      gradient.addColorStop( newRatio( 0.88 ), 'white' );
      gradient.addColorStop( newRatio( 0.9 ), 'white' );
      gradient.addColorStop( newRatio( 0.905 ), 'black' );
      gradient.addColorStop( newRatio( 0.91 ), 'white' );
      gradient.addColorStop( newRatio( 0.93 ), 'white' );
      gradient.addColorStop( newRatio( 0.9325 ), 'black' );
      gradient.addColorStop( newRatio( 0.935 ), 'white' );
      gradient.addColorStop( newRatio( 0.95 ), 'white' );
      gradient.addColorStop( newRatio( 0.951 ), 'black' );
      gradient.addColorStop( newRatio( 0.952 ), 'white' );

      gradient.addColorStop( 1, 'black' );
    };

    const linear = new LinearGradient( left, 0, right, 0 );
    addColorStops( linear );

    const radial = new RadialGradient( left, 64, 0, left, 64, right - left );
    addColorStops( radial );

    const scene = new Node( {
      children: [
        new Path( Shape.polygon( [
          v2( 0, 0 ),
          v2( 128, 0 ),
          v2( 128, 64 ),
          v2( 0, 64 )
        ] ), { fill: linear } ),
        new Path( Shape.polygon( [
          v2( 0, 64 ),
          v2( 128, 64 ),
          v2( 128, 128 ),
          v2( 0, 128 )
        ] ), { fill: radial } )
      ]
    } );

    if ( type === 'svg' || type === 'canvas' || type === 'vello' ) {
      return getSceneryElement(
        scene, width, height, 'white', type
      );
    }
    else if ( type === 'box' || type === 'bilinear' || type === 'mitchellNetravali' ) {
      const filtering = {
        box: PolygonFilterType.Box,
        bilinear: PolygonFilterType.Bilinear,
        mitchellNetravali: PolygonFilterType.MitchellNetravali
      }[ type ];
      const program = RenderFromNode.addBackgroundColor( RenderFromNode.nodeToRenderProgram( scene ), Color.WHITE );

      return getRasterizedElement( program, width, height, {
        polygonFiltering: filtering
      } );
    }
  };

  const getConflation = ( type, pointCount ) => {
    const width = 128;
    const height = 128;

    const center = v2( width / 2 + 0.15992094, height / 2 + 0.426296 );
    const radius = width * 0.45;

    const polygons = [];
    const colors = [];
    for ( let i = 0; i < pointCount; i++ ) {
      const polygon = [];
      const angle0 = i * 2 * Math.PI / pointCount;
      const angle1 = ( i + 1 ) * 2 * Math.PI / pointCount;

      const chroma = Vector2.createPolar( 0.1, angle0 );
      colors.push( RenderColor.gamutMapSRGB( RenderColor.convert( v4( 0.5, chroma.x, chroma.y, 1 ), RenderColorSpace.oklab, RenderColorSpace.sRGB ) ) );

      const p0 = v2( center.x + radius * Math.cos( angle0 ), center.y + radius * Math.sin( angle0 ) );
      const p1 = v2( center.x + radius * Math.cos( angle1 ), center.y + radius * Math.sin( angle1 ) );

      polygon.push( center );
      polygon.push( p0 );
      polygon.push( p1 );
      polygons.push( polygon );
    }

    if ( type === 'svg' || type === 'canvas' || type === 'vello' ) {
      return getSceneryElement(
        new Node( {
          children: [
            new Rectangle( 0, 64, 128, 64, { fill: 'black' } ),
            ...polygons.map( ( poly, i ) => {
              return new Path( Shape.polygon( poly ), { fill: new Color( colors[ i ].x * 255, colors[ i ].y * 255, colors[ i ].z * 255, 1 ) } );
            } )
          ]
        } ),
        width, height, 'white', type
      );
    }
    else if ( type === 'default' ) {
      const program = new RenderStack(
        [
          new RenderPathBoolean(
            new RenderPath( 'nonzero', [ [
              v2( 0, 64 ),
              v2( 128, 64 ),
              v2( 128, 128 ),
              v2( 0, 128 )
            ] ] ),
            RenderColor.from( 'black' ),
            RenderColor.from( 'white' )
          ),
          ...polygons.map( ( polygon, i ) => new RenderPathBoolean(
            new RenderPath( 'nonzero', [ polygon ] ),
            new RenderColor( colors[ i ] ),
            RenderColor.TRANSPARENT
          ) )
        ]
      );

      return getRasterizedElement( program, width, height );
    }
  };

  const getSiemensStar = ( type, pointCount ) => {
    const width = 128;
    const height = 128;

    const center = v2( width / 2 + 0.15992094, height / 2 + 0.426296 );
    const radius = width * 0.49;

    const polygon = [];
    for ( let i = 0; i < pointCount; i++ ) {
      const angle0 = i * 2 * Math.PI / pointCount;
      const angle1 = ( i + 0.5 ) * 2 * Math.PI / pointCount;

      const p0 = v2( center.x + radius * Math.cos( angle0 ), center.y + radius * Math.sin( angle0 ) );
      const p1 = v2( center.x + radius * Math.cos( angle1 ), center.y + radius * Math.sin( angle1 ) );

      polygon.push( center );
      polygon.push( p0 );
      polygon.push( p1 );
    }

    if ( type === 'svg' || type === 'canvas' || type === 'vello' ) {
      return getSceneryElement(
        new Path( Shape.polygon( polygon ), { fill: 'black', renderer: type } ),
        width, height, 'white', type
      );
    }
    else if ( type === 'box' || type === 'bilinear' || type === 'mitchellNetravali' ) {
      const filtering = {
        box: PolygonFilterType.Box,
        bilinear: PolygonFilterType.Bilinear,
        mitchellNetravali: PolygonFilterType.MitchellNetravali
      }[ type ];

      const program = new RenderPathBoolean(
        new RenderPath( 'nonzero', [ polygon ] ),
        RenderColor.from( 'black' ),
        RenderColor.from( 'white' )
      );

      return getRasterizedElement( program, width, height, {
        polygonFiltering: filtering
      } );
    }
  };

  const getPerceptual = ( type ) => {
    const width = 196;
    const height = 256;

    const clientSpace = RenderColorSpace.premultipliedSRGB;
    const colorSpace = {
      'srgb': RenderColorSpace.premultipliedSRGB,
      'linear': RenderColorSpace.premultipliedLinearSRGB,
      'display-p3': RenderColorSpace.premultipliedDisplayP3,
      'oklab': RenderColorSpace.premultipliedOklab
    }[ type ];

    const getTwoStop = ( minY, maxY, color1, color2 ) => {
      return new RenderPathBoolean(
        new RenderPath( 'nonzero', [ [
          phet.dot.v2( 0, minY ),
          phet.dot.v2( width, minY ),
          phet.dot.v2( width, maxY ),
          phet.dot.v2( 0, maxY )
        ] ] ),
        new RenderLinearGradient(
          Matrix3.IDENTITY,
          v2( 0, 0 ),
          v2( width, 0 ),
          [
            new RenderGradientStop( 0, RenderColor.from( color1 ).colorConverted( clientSpace, colorSpace ) ),
            new RenderGradientStop( 1, RenderColor.from( color2 ).colorConverted( clientSpace, colorSpace ) )
          ],
          RenderExtend.Pad,
          RenderLinearGradientAccuracy.SplitAccurate
        ).colorConverted( colorSpace, clientSpace ),
        RenderColor.TRANSPARENT
      );
    };

    const program = new RenderStack( [
      RenderColor.from( 'black' ),
      getTwoStop( 0, 64, 'blue', 'white' ),
      getTwoStop( 64, 80, 'rgba(0,200,0,1)', 'white' ),
      getTwoStop( 80, 96, 'red', 'white' ),
      getTwoStop( 96, 160, 'rgba(0,200,0,1)', 'red' ),
      getTwoStop( 160, 224, 'red', 'rgba(0,255,255,1)' ),
      getTwoStop( 224, 256, 'rgba(0,255,0,1)', 'rgba(255,0,255,1)' ),
    ] );
    return getRasterizedElement( program, width, height );
  };

  const getGamut = ( renderType, displayType, blendType, showOutOfGamut = false ) => {
    const sideLength = 200;
    const triangleHeight = Math.sqrt( 3 ) / 2 * sideLength;

    const padding = 3;

    const width = sideLength + padding * 2;
    const height = Math.ceil( triangleHeight ) + padding * 2;

    const redPoint = v2( 0, triangleHeight ).plusScalar( padding );
    const greenPoint = v2( sideLength, triangleHeight ).plusScalar( padding );
    const bluePoint = v2( sideLength / 2, 0 ).plusScalar( padding );

    const rawRedColor = v4( 1, 0, 0, 1 );
    const rawGreenColor = v4( 0, 1, 0, 1 );
    const rawBlueColor = v4( 0, 0, 1, 1 );

    const sRGB = RenderColorSpace.premultipliedSRGB;
    const displayP3 = RenderColorSpace.premultipliedDisplayP3;
    const oklab = RenderColorSpace.premultipliedOklab;

    const rawRedSRGBColor = RenderColor.convert( rawRedColor.copy(), sRGB, displayP3 );
    const rawGreenSRGBColor = RenderColor.convert( rawGreenColor.copy(), sRGB, displayP3 );
    const rawBlueSRGBColor = RenderColor.convert( rawBlueColor.copy(), sRGB, displayP3 );

    const clientSpace = displayType === 'srgb' ? sRGB : displayP3;
    const blendSpace = blendType === 'srgb' ? sRGB : ( blendType === 'display-p3' ? displayP3 : oklab );

    const program = new RenderStack( [
      new RenderPathBoolean(
        new RenderPath( 'nonzero', [ [
          redPoint, greenPoint, bluePoint
        ] ] ),
        new RenderBarycentricBlend(
          redPoint, greenPoint, bluePoint,
          RenderBarycentricBlendAccuracy.Accurate,
          new RenderColor( renderType === 'srgb' ? rawRedSRGBColor : rawRedColor ).colorConverted( displayP3, blendSpace ),
          new RenderColor( renderType === 'srgb' ? rawGreenSRGBColor : rawGreenColor ).colorConverted( displayP3, blendSpace ),
          new RenderColor( renderType === 'srgb' ? rawBlueSRGBColor : rawBlueColor ).colorConverted( displayP3, blendSpace )
        ).colorConverted( blendSpace, clientSpace ),
        RenderColor.TRANSPARENT
      ),
      new RenderPathBoolean(
        new RenderPath( 'nonzero', shapeToPolygons( Shape.polygon( [ redPoint, greenPoint, bluePoint ] ).getStrokedShape( new LineStyles( { lineWidth: 0.5 }) ) ) ),
        RenderColor.from( 'black' ).colorConverted( sRGB, clientSpace ),
        RenderColor.TRANSPARENT
      )
    ] );
    return getRasterizedElement( program, width, height, {
      colorSpace: displayType,
      showOutOfGamut: showOutOfGamut
    } );
  };

  const getGradientBlends = () => {
    const width = 768;
    const height = 256;

    const sideLength = 100;
    const triangleHeight = Math.sqrt( 3 ) / 2 * sideLength;

    const hasDisplayP3 = window.matchMedia( '(color-gamut: p3)' ).matches;
    const clientSpace = hasDisplayP3 ? RenderColorSpace.premultipliedDisplayP3 : RenderColorSpace.premultipliedSRGB;
    const blendSpace = RenderColorSpace.premultipliedOklab;
    const displayP3 = RenderColorSpace.premultipliedDisplayP3;

    const colorTri = ( redPoint, greenPoint, bluePoint ) => {
      return new RenderPathBoolean(
        new RenderPath( 'nonzero', [ [
          redPoint, greenPoint, bluePoint
        ] ] ),
        new RenderBarycentricBlend(
          redPoint, greenPoint, bluePoint,
          RenderBarycentricBlendAccuracy.Accurate,
          new RenderColor( v4( 1, 0, 0, 1 ) ).colorConverted( displayP3, blendSpace ),
          new RenderColor( v4( 0, 1, 0, 1 ) ).colorConverted( displayP3, blendSpace ),
          new RenderColor( v4( 0, 0, 1, 1 ) ).colorConverted( displayP3, blendSpace )
        ),
        RenderColor.TRANSPARENT
      );
    };

    const wireTri = ( redPoint, greenPoint, bluePoint ) => {
      const center = redPoint.plus( greenPoint ).plus( bluePoint ).timesScalar( 1 / 3 );
      const ratio = 0.05;
      return new RenderStack( [
        new RenderPathBoolean(
          new RenderPath( 'nonzero', [ [
            redPoint, greenPoint, bluePoint
          ] ] ),
          new RenderColor( v4( 0, 0, 0, 1 ) ).colorConverted( displayP3, blendSpace ),
          RenderColor.TRANSPARENT
        ),
        new RenderPathBoolean(
          new RenderPath( 'nonzero', [ [
            redPoint, greenPoint, bluePoint
          ], [
            redPoint.blend( center, ratio ), bluePoint.blend( center, ratio ), greenPoint.blend( center, ratio )
          ] ] ),
          new RenderColor( v4( 1, 1, 1, 1 ) ).colorConverted( displayP3, blendSpace ),
          RenderColor.TRANSPARENT
        )
      ] );
    };

    const triMap = ( x, y, f ) => [
      f(
        v2( 0, 0 ),
        v2( -0.5 * sideLength, triangleHeight ),
        v2( 0.5 * sideLength, triangleHeight )
      ),
      f(
        v2( 0, 0 ),
        v2( sideLength, 0 ),
        v2( 0.5 * sideLength, triangleHeight )
      ),
      f(
        v2( 1.5 * sideLength, triangleHeight ),
        v2( sideLength, 0 ),
        v2( 0.5 * sideLength, triangleHeight )
      ),
      f(
        v2( 1.5 * sideLength, triangleHeight ),
        v2( sideLength, 0 ),
        v2( 2 * sideLength, 0 )
      ),
      f(
        v2( 1.5 * sideLength, triangleHeight ),
        v2( 2.5 * sideLength, triangleHeight ),
        v2( 2 * sideLength, 0 )
      ),
      f(
        v2( 1.5 * sideLength, triangleHeight ),
        v2( 2.5 * sideLength, triangleHeight ),
        v2( 2 * sideLength, 0 )
      ),
      f(
        v2( 3 * sideLength, 0 ),
        v2( 2.5 * sideLength, triangleHeight ),
        v2( 2 * sideLength, 0 )
      )
    ].map( tri => tri.transformed( Matrix3.translation( x, y ) ) );

    const fullTriMap = ( f ) => [
      ...triMap( 0, 0, f ),
      ...triMap( 3 * sideLength, 0, f ),
      ...triMap( 6 * sideLength, 0, f ),
      ...triMap( -1.5 * sideLength, triangleHeight, f ),
      ...triMap( 1.5 * sideLength, triangleHeight, f ),
      ...triMap( 4.5 * sideLength, triangleHeight, f ),
      ...triMap( 7.5 * sideLength, triangleHeight, f ),
      ...triMap( 0, 2 * triangleHeight, f ),
      ...triMap( 3 * sideLength, 2 * triangleHeight, f ),
      ...triMap( 6 * sideLength, 2 * triangleHeight, f )
    ];

    const colorTris = () => fullTriMap( colorTri );
    const wireTris = () => fullTriMap( wireTri );

    const outerBlendSpace = RenderColorSpace.premultipliedDisplayP3;

    const program = new RenderStack( [
      RenderColor.from( 'black' ),
      new RenderLinearGradient(
        Matrix3.IDENTITY,
        v2( 0, 0 ), v2( width, 0 ),
        [
          new RenderGradientStop( 0.2, new RenderStack( colorTris() ).colorConverted( blendSpace, outerBlendSpace ) ),
          new RenderGradientStop( 0.8, new RenderStack( wireTris() ).colorConverted( blendSpace, outerBlendSpace ) ),
        ],
        RenderExtend.Pad,
        RenderLinearGradientAccuracy.SplitAccurate
      )
      // ...colorTris(),
      // // ...wireTris()
    ] ).colorConverted( outerBlendSpace, clientSpace );
    return getRasterizedElement( program, width, height, {
      colorSpace: hasDisplayP3 ? 'display-p3' : 'srgb',
    } );
  };

  const getTeapot = ( shadeType, normalType ) => {
    const width = 200;
    const height = 200;

    const dl = 150;
    const projectionMatrix = RenderDepthSort.getProjectionMatrix( 1, 100, -1, -1, 1, 1 );
    const rotationMatrix = Matrix3.rotationY( 0 ).timesMatrix( Matrix3.rotationX( -0.5 ) );
    const project = ( p ) => {

      // a rotation, for testing
      p = rotationMatrix.timesVector3( p.minus( v3( 0, 0, dl ) ) ).plus( v3( 0, 0, dl ) );

      const clip = projectionMatrix.timesVector4( v4( p.x, p.y, p.z, 1 ) );
      return v3( clip.x / clip.w, -clip.y / clip.w, clip.z / clip.w );
    };

    const createTriangularMesh = ( mesh, matrix4 ) => {
      return mesh.faces.map( face => {
        const vertices = face.vertexIndices.map( i => mesh.vertices[ i ] ).reverse();
        const normals = face.normalIndices.map( i => mesh.normals[ i ] ).reverse();

        const transformedVertices = vertices.map( v => matrix4.timesVector3( v ) );
        const projectedVertices = transformedVertices.map( project );

        if ( projectedVertices[ 0 ].equals( projectedVertices[ 1 ] ) || projectedVertices[ 0 ].equals( projectedVertices[ 2 ] ) || projectedVertices[ 1 ].equals( projectedVertices[ 2 ] ) ) {
          return null;
        }

        const positionProgram = new RenderBarycentricPerspectiveBlend(
          projectedVertices[ 0 ], projectedVertices[ 1 ], projectedVertices[ 2 ],
          RenderBarycentricPerspectiveBlendAccuracy.Centroid,
          new RenderColor( transformedVertices[ 0 ].toVector4Zero() ),
          new RenderColor( transformedVertices[ 1 ].toVector4Zero() ),
          new RenderColor( transformedVertices[ 2 ].toVector4Zero() ),
        );

        let normalProgram;
        if ( normalType === 'interpolated' ) {
          normalProgram = new RenderNormalize( new RenderBarycentricPerspectiveBlend(
            projectedVertices[ 0 ], projectedVertices[ 1 ], projectedVertices[ 2 ],
            RenderBarycentricPerspectiveBlendAccuracy.Centroid,
            new RenderColor( normals[ 0 ].toVector4Zero() ),
            new RenderColor( normals[ 1 ].toVector4Zero() ),
            new RenderColor( normals[ 2 ].toVector4Zero() )
          ) );
        }
        else if ( normalType === 'flat' ) {
          normalProgram = new RenderColor( normals[ 0 ].plus( normals[ 1 ] ).plus( normals[ 2 ] ).normalized().toVector4Zero() );
        }

        // const positionProgram = new RenderColor( transformedVertices[ 0 ].plus( transformedVertices[ 1 ] ).plus( transformedVertices[ 2 ] ).timesScalar( 1 / 3 ).toVector4() );

        let renderProgram;
        if ( shadeType === 'phong' ) {
          const ambientColorProgram = new RenderColor( v4( 0, 0, 0, 1 ) );
          const diffuseColorProgram = new RenderColor( v4( 1, 0.05, 0, 1 ) );
          const specularColorProgram = new RenderColor( v4( 0.5, 0.5, 0.5, 1 ) );
          renderProgram = new RenderPhong( 50, ambientColorProgram, diffuseColorProgram, specularColorProgram, positionProgram, normalProgram, [
            new RenderLight(
              new RenderColor( v4( -2.0, 3.5, -2.0, 0 ).normalized() ),
              new RenderColor( v4( 1, 1, 1, 1 ) )
            )
          ] );
        }
        else if ( shadeType === 'normals' ) {
          renderProgram = new RenderNormalDebug( normalProgram );
        }
        else if ( shadeType === 'random' ) {
          renderProgram = new RenderColor( v4( Math.random(), Math.random(), Math.random(), 1 ) );
        }

        return new RenderPlanar(
          RenderPathBoolean.fromInside( new RenderPath( 'nonzero', [ [
            projectedVertices[ 0 ].toVector2(), projectedVertices[ 1 ].toVector2(), projectedVertices[ 2 ].toVector2()
          ] ] ), renderProgram ),
          projectedVertices[ 0 ], projectedVertices[ 1 ], projectedVertices[ 2 ]
        );
      } ).filter( _.identity );
    };

    let program = new RenderDepthSort( [
      ...createTriangularMesh( Mesh.loadOBJ( teapotOBJ )[ 0 ], Matrix4.translation( 0, 0, 150 ) ),
    ] ).transformed( phet.dot.Matrix3.scaling( 170 * width / 256 ) ).transformed( phet.dot.Matrix3.translation( width / 2, height / 2 ) );
    if ( shadeType === 'phong' ) {
      program = new RenderLinearSRGBToSRGB( program );
    }

    return getRasterizedElement( program, width, height );
  };

  const getCheckerboard = ( type ) => {
    const width = 128;
    const height = width / 2;

    const dl = 10;

    const projectionMatrix = RenderDepthSort.getProjectionMatrix( 1, 100, -1, -1, 1, 1 );
    const rotationMatrix = Matrix3.rotationY( 0.1 ).timesMatrix( Matrix3.rotationX( 0 ) );
    const project = ( p ) => {

      // a rotation, for testing
      p = rotationMatrix.timesVector3( p.minus( v3( 0, 0, dl ) ) ).plus( v3( 0, 0, dl ) );

      const clip = projectionMatrix.timesVector4( v4( p.x, p.y, p.z, 1 ) );
      return v3( clip.x / clip.w, -clip.y / clip.w, clip.z / clip.w );
    };

    const polygons = [];

    const matrix = Matrix3.scaling( height ).timesMatrix( Matrix3.translation( 1, 0, 0 ) );

    const xSpan = 40;
    const y = -5;
    const zMax = 100;

    for ( let x = -xSpan; x < xSpan; x++ ) {
      for ( let z = 5; z < zMax; z++ ) {
        if ( ( x + z ) % 2 === 0 ) {
          continue;
        }
        const p0 = matrix.timesVector2( project( v3( x, y, z ) ).toVector2() );
        const p1 = matrix.timesVector2( project( v3( x + 1, y, z ) ).toVector2() );
        const p2 = matrix.timesVector2( project( v3( x + 1, y, z + 1 ) ).toVector2() );
        const p3 = matrix.timesVector2( project( v3( x, y, z + 1 ) ).toVector2() );

        polygons.push( [ p0, p1, p2, p3 ] );
      }
    }

    if ( type === 'svg' || type === 'canvas' || type === 'vello' ) {
      return getSceneryElement(
        new Node( {
          renderer: type,
          children: polygons.map( polygon => new Path( Shape.polygon( polygon ), { fill: 'black' } ) )
        } ),
        width, height, 'white', type
      );
    }
    else {
      const program = new RenderStack( [
        new RenderPathBoolean(
          new RenderPath( 'nonzero', polygons ),
          RenderColor.from( 'black' ),
          RenderColor.from( 'white' )
        )
      ] );

      return getRasterizedElement( program, width, height, {
        polygonFiltering: {
          box: PolygonFilterType.Box,
          bilinear: PolygonFilterType.Bilinear,
          mitchellNetravali: PolygonFilterType.MitchellNetravali
        }[ type ]
      } );
    }
  };

</script>

<div class="navbar navbar-inverse navbar-static-top">
  <div class="navbar-inner">
    <a class="brand" href="/scenery">Scenery</a>
    <ul class="nav">
      <li><a href="../">Home</a></li>
      <li class="active"><a href="../doc">Documentation</a></li>
      <li><a href="../examples">Examples</a></li>
      <li><a href="../tests">Tests</a></li>
    </ul>
  </div>
</div>

<div class="row-fluid">
  <div class="span2"></div>
  <div class="span8">
    <div class="page-header" style="text-align: center;">
      <h1>Rasterization Demos</h1>
    </div>
  </div>
  <div class="span2"></div>
</div>

<div class="row-fluid">
  <div class="span2">

  </div>
  <div class="span8">

    <h2>Conflation</h2>

    <p>
      Background colors can show up at joints between paths, due to blending with the background multiple times per pixel.
      Ideally there will be no white lines showing through, and no whitening toward the center.
    </p>

    <table class="table">
      <tbody>
        <tr>
          <td style="text-align: center;">Canvas</td>
          <td style="text-align: center;">SVG</td>
          <td style="text-align: center;">Vello</td>
          <td style="text-align: center;">Proposed Method</td>
        </tr>
        <tr>
          <td id="conflation-canvas"></td>
          <td id="conflation-svg"></td>
          <td id="conflation-vello"></td>
          <td id="conflation-default"></td>
        </tr>
      </tbody>
    </table>

    <script>
      setTimeout( async () => {
        document.getElementById( 'conflation-canvas' ).appendChild(
          getConflation( 'canvas', 100 )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'conflation-svg' ).appendChild(
          getConflation( 'svg', 100 )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        if ( await DeviceContext.isVelloSupported() ) {
          document.getElementById( 'conflation-vello' ).appendChild(
            getConflation( 'vello', 100 )
          );
        }
        else {
          document.getElementById( 'conflation-vello' ).innerHTML = 'Not supported';
        }
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'conflation-default' ).appendChild(
          getConflation( 'default', 100 )
        );
      } );
    </script>

    <h2>3D Capabilities</h2>

    <table class="table">
      <tbody>
        <tr>
          <td style="text-align: center;">Colors</td>
          <td style="text-align: center;">Flat Normals</td>
          <td style="text-align: center;">Interpolated Normals</td>
          <td style="text-align: center;">Phong</td>
        </tr>
        <tr>
          <td id="teapot-random"></td>
          <td id="teapot-flat"></td>
          <td id="teapot-normals"></td>
          <td id="teapot-phong"></td>
        </tr>
      </tbody>
    </table>

    <script>
      setTimeout( async () => {
        document.getElementById( 'teapot-random' ).appendChild(
          getTeapot( 'random', 'flat' )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'teapot-flat' ).appendChild(
          getTeapot( 'normals', 'flat' )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'teapot-normals' ).appendChild(
          getTeapot( 'normals', 'interpolated' )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'teapot-phong' ).appendChild(
          getTeapot( 'phong', 'interpolated' )
        );
      } );
    </script>

    <h2>Gradient Aliasing</h2>

    <table class="table">
      <tbody>
        <tr>
          <td style="text-align: center;">Canvas</td>
          <td style="text-align: center;">SVG</td>
          <td style="text-align: center;">Vello</td>
          <td style="text-align: center;">Proposed Method (box)</td>
          <td style="text-align: center;">Proposed Method (bilinear)</td>
          <td style="text-align: center;">Proposed Method (Mitchell-Netravali)</td>
        </tr>
        <tr>
          <td id="gradient-aliasing-canvas"></td>
          <td id="gradient-aliasing-svg"></td>
          <td id="gradient-aliasing-vello"></td>
          <td id="gradient-aliasing-box"></td>
          <td id="gradient-aliasing-bilinear"></td>
          <td id="gradient-aliasing-mitchell-netravali"></td>
        </tr>
      </tbody>
    </table>

    <script>
      setTimeout( async () => {
        document.getElementById( 'gradient-aliasing-canvas' ).appendChild(
          getGradientAliasing( 'canvas' )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'gradient-aliasing-svg' ).appendChild(
          getGradientAliasing( 'svg' )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        if ( await DeviceContext.isVelloSupported() ) {
          document.getElementById( 'gradient-aliasing-vello' ).appendChild(
            getGradientAliasing( 'vello' )
          );
        }
        else {
          document.getElementById( 'gradient-aliasing-vello' ).innerHTML = 'Not supported';
        }
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'gradient-aliasing-box' ).appendChild(
          getGradientAliasing( 'box' )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'gradient-aliasing-bilinear' ).appendChild(
          getGradientAliasing( 'bilinear' )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'gradient-aliasing-mitchell-netravali' ).appendChild(
          getGradientAliasing( 'mitchellNetravali' )
        );
      } );
    </script>

    <h2>Gradient Precision</h2>

    <table class="table">
      <tbody>
        <tr>
          <td style="text-align: center;">Canvas</td>
          <td style="text-align: center;">SVG</td>
          <td style="text-align: center;">Vello</td>
          <td style="text-align: center;">Proposed Method</td>
        </tr>
        <tr>
          <td id="gradient-precision-canvas"></td>
          <td id="gradient-precision-svg"></td>
          <td id="gradient-precision-vello"></td>
          <td id="gradient-precision-box"></td>
        </tr>
      </tbody>
    </table>

    <script>
      setTimeout( async () => {
        document.getElementById( 'gradient-precision-canvas' ).appendChild(
          getGradientPrecision( 'canvas' )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'gradient-precision-svg' ).appendChild(
          getGradientPrecision( 'svg' )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        if ( await DeviceContext.isVelloSupported() ) {
          document.getElementById( 'gradient-precision-vello' ).appendChild(
            getGradientPrecision( 'vello' )
          );
        }
        else {
          document.getElementById( 'gradient-precision-vello' ).innerHTML = 'Not supported';
        }
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'gradient-precision-box' ).appendChild(
          getGradientPrecision( 'box' )
        );
      } );
    </script>

    <h2>Filtered Polygons</h2>

    <table class="table">
      <tbody>
        <tr>
          <td style="text-align: center;">Reference (dirac delta)</td>
          <td style="text-align: center;">Box</td>
          <td style="text-align: center;">Bilinear</td>
          <td style="text-align: center;">Mitchell-Netravali</td>
        </tr>
        <tr>
          <td id="filter-reference"></td>
          <td id="filter-box"></td>
          <td id="filter-bilinear"></td>
          <td id="filter-mitchell-netravali"></td>
        </tr>
      </tbody>
    </table>

    <script>
      setTimeout( async () => {
        document.getElementById( 'filter-reference' ).appendChild(
          getFiltered( PolygonFilterType.Box, 1 )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'filter-box' ).appendChild(
          getFiltered( PolygonFilterType.Box, 10 )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'filter-bilinear' ).appendChild(
          getFiltered( PolygonFilterType.Bilinear, 10 )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'filter-mitchell-netravali' ).appendChild(
          getFiltered( PolygonFilterType.MitchellNetravali, 10 )
        );
      } );
    </script>

    <h2>Polygonal Aliasing</h2>

    <p>Sometimes, high-frequency patterns can create lower-frequency (aliased) patterns in the result.</p>

    <h3>Checkerboards</h3>

    <table class="table">
      <tbody>
        <tr>
          <td style="text-align: center;">Canvas</td>
          <td style="text-align: center;">SVG</td>
          <td style="text-align: center;">Vello</td>
          <td style="text-align: center;">Proposed Method (box)</td>
          <td style="text-align: center;">Proposed Method (bilinear)</td>
          <td style="text-align: center;">Proposed Method (Mitchell-Netravali)</td>
        </tr>
        <tr>
          <td id="checkerboard-canvas"></td>
          <td id="checkerboard-svg"></td>
          <td id="checkerboard-vello"></td>
          <td id="checkerboard-box"></td>
          <td id="checkerboard-bilinear"></td>
          <td id="checkerboard-mitchell-netravali"></td>
        </tr>
      </tbody>
    </table>

    <script>
      setTimeout( async () => {
        document.getElementById( 'checkerboard-canvas' ).appendChild(
          getCheckerboard( 'canvas' )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'checkerboard-svg' ).appendChild(
          getCheckerboard( 'svg' )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        if ( await DeviceContext.isVelloSupported() ) {
          document.getElementById( 'checkerboard-vello' ).appendChild(
            getCheckerboard( 'vello' )
          );
        }
        else {
          document.getElementById( 'checkerboard-vello' ).innerHTML = 'Not supported';
        }
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'checkerboard-box' ).appendChild(
          getCheckerboard( 'box' )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'checkerboard-bilinear' ).appendChild(
          getCheckerboard( 'bilinear' )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'checkerboard-mitchell-netravali' ).appendChild(
          getCheckerboard( 'mitchellNetravali' )
        );
      } );
    </script>

    <h3>Siemens Stars</h3>

    <p>
      Alternating radial bands of light/dark, to visualize aliasing. It should blur towards a consistent gray toward the
      center (not showing extra patterns, OR showing a darker gray).
    </p>

    <table class="table">
      <tbody>
        <tr>
          <td style="text-align: center;">Canvas</td>
          <td style="text-align: center;">SVG</td>
          <td style="text-align: center;">Vello</td>
          <td style="text-align: center;">Proposed Method (box)</td>
          <td style="text-align: center;">Proposed Method (bilinear)</td>
          <td style="text-align: center;">Proposed Method (Mitchell-Netravali)</td>
        </tr>
        <tr>
          <td id="siemens-star-canvas"></td>
          <td id="siemens-star-svg"></td>
          <td id="siemens-star-vello"></td>
          <td id="siemens-star-box"></td>
          <td id="siemens-star-bilinear"></td>
          <td id="siemens-star-mitchell-netravali"></td>
        </tr>
      </tbody>
    </table>

    <script>
      setTimeout( async () => {
        document.getElementById( 'siemens-star-canvas' ).appendChild(
          getSiemensStar( 'canvas', 200 )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'siemens-star-svg' ).appendChild(
          getSiemensStar( 'svg', 200 )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        if ( await DeviceContext.isVelloSupported() ) {
          document.getElementById( 'siemens-star-vello' ).appendChild(
            getSiemensStar( 'vello', 200 )
          );
        }
        else {
          document.getElementById( 'siemens-star-vello' ).innerHTML = 'Not supported';
        }
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'siemens-star-box' ).appendChild(
          getSiemensStar( 'box', 200 )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'siemens-star-bilinear' ).appendChild(
          getSiemensStar( 'bilinear', 200 )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'siemens-star-mitchell-netravali' ).appendChild(
          getSiemensStar( 'mitchellNetravali', 200 )
        );
      } );
    </script>

    <h2>Gamut and Color Spaces</h2>

    <p>
      There are two color spaces (sRGB and Display P3) currently supported by Canvas, and that can be currently displayed.
      Other color spaces are supported internally (e.g. Oklab). Colors can be blended in any of these color spaces.
      Oklab is the preferred "perceptual" color space to blend in (e.g. for gradients). Additionally, "linear" variants
      of color spaces are supported, which effectively excludes the "transfer function", such that adding two colors
      in a linear space will be the same as if two lights of that color were added together.
    </p>

    <p>
      Colors from one color space may be outside the range (gamut) of another color space. In particular, this includes
      blending BETWEEN color spaces (e.g. using Oklab to blend between to valid sRGB colors may result in something
      outside the range of sRGB). In this case, gamut mapping is needed. This is currently done with a simple
      relative colorimetric approach (which will only change out-of-gamut colors), similar to that used in the web
      specifications.
    </p>

    <h3>sRGB</h3>

    <p>
      The following show a triangle with the three sRGB "primary" colors in each corner. Blending in sRGB will result in
      fully in-gamut results, however blending in Oklab will result in out-of-gamut colors (middle example will have
      mapped these to in-gamut colors).
    </p>

    <table class="table">
      <tbody>
        <tr>
          <td style="text-align: center;">sRGB triangle in sRGB</td>
          <td style="text-align: center;">sRGB triangle (perceptual blend) in sRGB</td>
          <td style="text-align: center;">sRGB triangle (perceptual blend) in sRGB (gray if out of gamut)</td>
        </tr>
        <tr>
          <td id="gamut-srgb-srgb"></td>
          <td id="gamut-srgb-srgb-perceptual"></td>
          <td id="gamut-srgb-srgb-perceptual-gamut"></td>
        </tr>
      </tbody>
    </table>

    <h3>Display P3</h3>

    <p>
      Display P3 is a wider gamut color space than sRGB, and can show more saturated colors (particularly reds/yellows/greens).
      The below displays are only supported on some browsers on some devices (tested on Chrome/Safari macOS).
    </p>

    <table class="table">
      <tbody>
        <tr>
          <td style="text-align: center;">Display P3 triangle in Display P3</td>
          <td style="text-align: center;">Display P3 triangle (perceptual blend) in Display P3</td>
          <td style="text-align: center;">Display P3 triangle (perceptual blend) in Display P3 (gray if out of gamut)</td>
        </tr>
        <tr>
          <td id="gamut-display-p3-display-p3"></td>
          <td id="gamut-display-p3-display-p3-perceptual"></td>
          <td id="gamut-display-p3-display-p3-perceptual-gamut"></td>
        </tr>
      </tbody>
    </table>

    <h3>Display P3 Mapped to sRGB</h3>

    <p>
      This gives a "best approximation of the above Display P3 triangle within sRGB", and shows how many colors are mapped.
    </p>

    <table class="table">
      <tbody>
        <tr>
          <td></td>
          <td style="text-align: center;">Display P3 triangle in sRGB (relative colorimetric gamut mapping)</td>
          <td style="text-align: center;">Display P3 triangle (perceptual blend) in sRGB (relative colorimetric gamut mapping)</td>
        </tr>
        <tr>
          <td></td>
          <td id="gamut-display-p3-srgb"></td>
          <td id="gamut-display-p3-srgb-perceptual"></td>
        </tr>
      </tbody>
      <tbody>
        <tr>
          <td></td>
          <td style="text-align: center;">Display P3 triangle in sRGB (gray if out of gamut)</td>
          <td style="text-align: center;">Display P3 triangle (perceptual blend) in sRGB (gray if out of gamut)</td>
        </tr>
        <tr>
          <td></td>
          <td id="gamut-display-p3-srgb-gamut"></td>
          <td id="gamut-display-p3-srgb-perceptual-gamut"></td>
        </tr>
      </tbody>
    </table>

    <script>
      setTimeout( async () => {
        document.getElementById( 'gamut-srgb-srgb' ).appendChild(
          getGamut( 'srgb', 'srgb', 'srgb' )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'gamut-srgb-srgb-perceptual' ).appendChild(
          getGamut( 'srgb', 'srgb', 'oklab' )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'gamut-srgb-srgb-perceptual-gamut' ).appendChild(
          getGamut( 'srgb', 'srgb', 'oklab', true )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'gamut-display-p3-srgb' ).appendChild(
          getGamut( 'display-p3', 'srgb', 'display-p3' )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'gamut-display-p3-srgb-perceptual' ).appendChild(
          getGamut( 'display-p3', 'srgb', 'oklab' )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'gamut-display-p3-srgb-gamut' ).appendChild(
          getGamut( 'display-p3', 'srgb', 'display-p3', true )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'gamut-display-p3-srgb-perceptual-gamut' ).appendChild(
          getGamut( 'display-p3', 'srgb', 'oklab', true )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        if ( window.matchMedia( '(color-gamut: p3)' ).matches ) {
          document.getElementById( 'gamut-display-p3-display-p3' ).appendChild(
            getGamut( 'display-p3', 'display-p3', 'display-p3' )
          );
        }
        else {
          document.getElementById( 'gamut-display-p3-display-p3' ).innerHTML = 'Not supported';
        }
      } );
    </script>
    <script>
      setTimeout( async () => {
        if ( window.matchMedia( '(color-gamut: p3)' ).matches ) {
          document.getElementById( 'gamut-display-p3-display-p3-perceptual' ).appendChild(
            getGamut( 'display-p3', 'display-p3', 'oklab' )
          );
        }
        else {
          document.getElementById( 'gamut-display-p3-display-p3-perceptual' ).innerHTML = 'Not supported';
        }
      } );
    </script>
    <script>
      setTimeout( async () => {
        if ( window.matchMedia( '(color-gamut: p3)' ).matches ) {
          document.getElementById( 'gamut-display-p3-display-p3-perceptual-gamut' ).appendChild(
            getGamut( 'display-p3', 'display-p3', 'oklab', true )
          );
        }
        else {
          document.getElementById( 'gamut-display-p3-display-p3-perceptual-gamut' ).innerHTML = 'Not supported';
        }
      } );
    </script>

    <h3>Blending in Color Spaces</h3>

    <p>
      Blending with different color spaces can result in different results. Oklab is the preferred perceptual space,
      and has better hue consistency (the blue-white doesn't turn slightly purple). Blending in sRGB (or the similar wider-gamut
      Display P3) darkens blends between opposing saturated colors. Blending in linear spaces can still have color
      hue shifts, but will not darken blends between opposing saturated colors.
    </p>

    <table class="table">
      <tbody>
        <tr>
          <td style="text-align: center;">Oklab</td>
          <td style="text-align: center;">sRGB</td>
          <td style="text-align: center;">Display P3</td>
          <td style="text-align: center;">Linear sRGB</td>
        </tr>
        <tr>
          <td id="perceptual-oklab"></td>
          <td id="perceptual-srgb"></td>
          <td id="perceptual-display-p3"></td>
          <td id="perceptual-linear-srgb"></td>
        </tr>
      </tbody>
    </table>

    <script>
      setTimeout( async () => {
        document.getElementById( 'perceptual-oklab' ).appendChild(
          getPerceptual( 'oklab' )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'perceptual-srgb' ).appendChild(
          getPerceptual( 'srgb' )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'perceptual-display-p3' ).appendChild(
          getPerceptual( 'display-p3' )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'perceptual-linear-srgb' ).appendChild(
          getPerceptual( 'linear' )
        );
      } );
    </script>

    <h2>Gradient Blends between Content</h2>

    <div id="gradient-blends"></div>
    <script>
      setTimeout( async () => {
        document.getElementById( 'gradient-blends' ).appendChild(
          getGradientBlends()
        );
      } );
    </script>

  </div>
  <div class="span2"></div>
</div>

</body>
</html>
