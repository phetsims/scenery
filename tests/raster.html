<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Raster Tests</title>

  <link rel="shortcut icon" type="image/x-icon" href="../assets/logo-v1.svg">
  <link rel="stylesheet" href="../../sherpa/lib/bootstrap-2.2.2.css">
  <link rel="stylesheet" href="../../sherpa/lib/bootstrap-responsive-2.2.2.css">
  <link rel="stylesheet" href="../../sherpa/lib/syntaxhighlighter-3.0.83/shCore.css">
  <link rel="stylesheet" href="../../sherpa/lib/syntaxhighlighter-3.0.83/shThemeDefault.css">
  <link rel="stylesheet" href="../assets/scenery.css">

  <!-- Before loading other things (that might error), create hooks to report errors/loads for continuous testing -->
  <script src="../../chipper/js/sim-tests/pageload-connector.js"></script>

  <!-- jQuery and LoDash are dependencies -->
  <script src="../../sherpa/lib/jquery-2.1.0.min.js"></script>
  <script src="../../sherpa/lib/lodash-4.17.4.min.js"></script>

  <!-- For the styling -->
  <script src="../../sherpa/lib/bootstrap-2.2.2.js"></script>

  <link rel="stylesheet" href="../../sherpa/lib/highlightjs-11.5.1-a11y-light.min.css">
  <script src="../../sherpa/lib/highlightjs-11.5.1.min.js"></script>

  <style>

  </style>
</head>

<body>

<!-- Our code, in either the concatenated 'with comments' version or the minified version -->
<!--<script src="../dist/scenery.debug.js"></script>-->
<script src="../dist/scenery.min.js"></script>

<script type="text/javascript">
  phet.scenery.Utils.polyfillRequestAnimationFrame();

  _.extend( window, phet.phetCore );
  _.extend( window, phet.axon );
  _.extend( window, phet.dot );
  _.extend( window, phet.kite );
  _.extend( window, phet.scenery );

  const colors = [
    new Color( 62, 171, 3 ),
    new Color( 23, 180, 77 ),
    new Color( 24, 183, 138 ),
    new Color( 23, 178, 194 ),
    new Color( 20, 163, 238 ),
    new Color( 71, 136, 255 ),
    new Color( 171, 101, 255 ),
    new Color( 228, 72, 235 ),
    new Color( 252, 66, 186 ),
    new Color( 252, 82, 127 )
  ];

  const piecewiseOptions = {
    minLevels: 1,
    maxLevels: 10,
    // distanceEpsilon: 0.02,
    distanceEpsilon: 0.0002,
    curveEpsilon: 0.2
  };
  const shapeToPolygons = shape => shape.subpaths.map( subpath => {
    return subpath.toPiecewiseLinear( piecewiseOptions ).segments.map( line => {
      return line.start;
    } );
  } );

  const sizeCanvas = canvas => {
    canvas.style.width = `${canvas.width / window.devicePixelRatio}px`;
    canvas.style.height = `${canvas.height / window.devicePixelRatio}px`;
  };

  const getSceneryElement = ( node, width, height, background, renderer ) => {
    const subdiv = document.createElement( 'div' );
    const scene = new Node( { renderer: renderer } );
    const display = new Display( scene, {
      width: width,
      height: height,
      accessibility: true,
      container: subdiv
    } );

    display.width = width;
    display.height = height;
    scene.addChild( node );
    display.backgroundColor = background;
    display.updateDisplay();
    scene.removeChild( node );
    return subdiv;
  };

  // composite Rasterize/CombinedRaster options
  const getRasterizedElement = ( renderProgram, width, height, options ) => {
    const program = renderProgram.transformed( Matrix3.scaling( window.devicePixelRatio ) );

    const outputWidth = width * window.devicePixelRatio;
    const outputHeight = height * window.devicePixelRatio;

    const raster = new CombinedRaster( outputWidth, outputHeight, options );
    Rasterize.rasterize( program, raster, new Bounds2( 0, 0, outputWidth, outputHeight ), options );
    const canvas = Rasterize.imageDataToCanvas( raster.toImageData() );
    sizeCanvas( canvas );
    return canvas;
  };

  const getFiltered = ( filter, multiplier ) => {
    const width = 150;
    const height = 150;

    const program = new RenderStack( [
      new RenderPathBoolean(
        new RenderPath( 'nonzero', [ [
          phet.dot.v2( 30, 30 ),
          phet.dot.v2( 120, 30 ),
          phet.dot.v2( 120, 120 ),
          phet.dot.v2( 30, 120 )
        ], [
          phet.dot.v2( 35, 35 ),
          phet.dot.v2( 45, 105 ),
          phet.dot.v2( 90, 90 ),
          phet.dot.v2( 105, 35 )
        ] ] ),
        RenderColor.from( 'black' ),
        RenderColor.from( 'white' )
      ),
      new RenderPathBoolean(
        new RenderPath( 'nonzero', [
          ...shapeToPolygons( Shape.regularPolygon( 20, 5 ).transformed( Matrix3.translation( 100, 100 ) ) )
        ] ),
        RenderColor.from( 'red' ),
        RenderColor.TRANSPARENT
      ),
      new RenderPathBoolean(
        new RenderPath( 'nonzero', [ [
          phet.dot.v2( 50, 50 ),
          phet.dot.v2( 45, 105 ),
          phet.dot.v2( 90, 90 ),
        ] ] ),
        RenderColor.from( 'blue' ),
        RenderColor.TRANSPARENT
      )
    ] );

    return getRasterizedElement( program, width, height, {
      polygonFiltering: filter,
      polygonFilterWindowMultiplier: multiplier * window.devicePixelRatio
    } );
  };

  const getGradientAliasing = ( type ) => {
    const width = 128;
    const height = 128;

    const addColorStops = gradient => {
      gradient.addColorStop( 0, 'black' );

      for ( let i = 0.2; i < 0.3; i += 0.05 ) {
        gradient.addColorStop( i, 'white' );
        gradient.addColorStop( i + 0.0001, 'black' );
      }
      for ( let i = 0.3; i < 0.4; i += 0.025269 ) {
        gradient.addColorStop( i, 'white' );
        gradient.addColorStop( i + 0.0001, 'blue' );
      }
      for ( let i = 0.4; i < 0.5; i += 0.01 ) {
        gradient.addColorStop( i, 'white' );
        gradient.addColorStop( i + 0.0001, 'black' );
      }
      for ( let i = 0.5; i < 0.6; i += 0.005 ) {
        gradient.addColorStop( i, 'white' );
        gradient.addColorStop( i + 0.0001, 'red' );
      }
      gradient.addColorStop( 0.6, 'white' );
      gradient.addColorStop( 0.7, 'black' );
      gradient.addColorStop( 0.7001, 'white' );
      gradient.addColorStop( 0.8, 'black' );
      gradient.addColorStop( 0.8001, 'white' );
      gradient.addColorStop( 0.81, 'black' );
      gradient.addColorStop( 0.95, 'white' );
      gradient.addColorStop( 0.951, 'black' );
      gradient.addColorStop( 0.952, 'white' );
      gradient.addColorStop( 0.96, 'white' );
      gradient.addColorStop( 0.962, 'black' );
      gradient.addColorStop( 0.964, 'white' );
      gradient.addColorStop( 0.97, 'white' );
      gradient.addColorStop( 0.973, 'black' );
      gradient.addColorStop( 0.976, 'white' );
      gradient.addColorStop( 0.98, 'white' );
      gradient.addColorStop( 0.984, 'black' );
      gradient.addColorStop( 0.988, 'white' );
      gradient.addColorStop( 1, 'black' );
    };

    const linear = new LinearGradient( 10, 10, 118, 20 );
    addColorStops( linear );

    // Oops, tricky to get these to match up exactly.
    const delta = v2( 108, 10 );
    const center = phet.dot.Utils.lineLineIntersection( v2( 10, 10 ), v2( 10, 10 ).plus( delta.perpendicular ), v2( 0, 64 ), v2( 128, 64 ) );
    const radius = delta.magnitude;
    const rightPoint = phet.dot.Utils.lineLineIntersection( center, center.plus( delta ), v2( 128, 0 ), v2( 128, 128 ) );

    const radial = new RadialGradient( center.x, center.y, 0, center.x, center.y, radius );
    addColorStops( radial );

    const scene = new Node( {
      children: [
        new Path( Shape.polygon( [
          v2( 0, 0 ),
          v2( 128, 0 ),
          rightPoint,
          center,
          v2( 0, 64 )
        ] ), { fill: linear } ),
        new Path( Shape.polygon( [
          center,
          rightPoint,
          v2( 128, 128 ),
          v2( 0, 128 ),
          v2( 0, 64 )
        ] ), { fill: radial } )
      ]
    } );

    if ( type === 'svg' || type === 'canvas' || type === 'vello' ) {
      return getSceneryElement(
        scene, width, height, 'white', type
      );
    }
    else if ( type === 'box' || type === 'bilinear' || type === 'mitchellNetravali' ) {
      const filtering = {
        box: PolygonFilterType.Box,
        bilinear: PolygonFilterType.Bilinear,
        mitchellNetravali: PolygonFilterType.MitchellNetravali
      }[ type ];
      const program = RenderFromNode.addBackgroundColor( RenderFromNode.nodeToRenderProgram( scene ), Color.WHITE );

      return getRasterizedElement( program, width, height, {
        polygonFiltering: filtering
      } );
    }
  };

  const getGradientPrecision = ( type ) => {
    const width = 128;
    const height = 128;

    // const left = -3000;
    // const right = 3000;

    const left = 0;
    const right = 6000;

    const ratioLeft = ( 0 - left ) / ( right - left );
    const ratioRight = ( width - left ) / ( right - left );

    const newRatio = ratio => ratioLeft + ratio * ( ratioRight - ratioLeft );

    const addColorStops = gradient => {
      gradient.addColorStop( 0, 'black' );

      gradient.addColorStop( newRatio( 0 ), 'white' );
      gradient.addColorStop( newRatio( 0.5 ), 'black' );
      gradient.addColorStop( newRatio( 0.70 ), 'white' );
      gradient.addColorStop( newRatio( 0.74 ), 'black' );
      gradient.addColorStop( newRatio( 0.78 ), 'white' );
      gradient.addColorStop( newRatio( 0.80 ), 'white' );
      gradient.addColorStop( newRatio( 0.82 ), 'black' );
      gradient.addColorStop( newRatio( 0.84 ), 'white' );
      gradient.addColorStop( newRatio( 0.86 ), 'white' );
      gradient.addColorStop( newRatio( 0.87 ), 'black' );
      gradient.addColorStop( newRatio( 0.88 ), 'white' );
      gradient.addColorStop( newRatio( 0.9 ), 'white' );
      gradient.addColorStop( newRatio( 0.905 ), 'black' );
      gradient.addColorStop( newRatio( 0.91 ), 'white' );
      gradient.addColorStop( newRatio( 0.93 ), 'white' );
      gradient.addColorStop( newRatio( 0.9325 ), 'black' );
      gradient.addColorStop( newRatio( 0.935 ), 'white' );
      gradient.addColorStop( newRatio( 0.95 ), 'white' );
      gradient.addColorStop( newRatio( 0.951 ), 'black' );
      gradient.addColorStop( newRatio( 0.952 ), 'white' );

      gradient.addColorStop( 1, 'black' );
    };

    const linear = new LinearGradient( left, 0, right, 0 );
    addColorStops( linear );

    const radial = new RadialGradient( left, 64, 0, left, 64, right - left );
    addColorStops( radial );

    const scene = new Node( {
      children: [
        new Path( Shape.polygon( [
          v2( 0, 0 ),
          v2( 128, 0 ),
          v2( 128, 64 ),
          v2( 0, 64 )
        ] ), { fill: linear } ),
        new Path( Shape.polygon( [
          v2( 0, 64 ),
          v2( 128, 64 ),
          v2( 128, 128 ),
          v2( 0, 128 )
        ] ), { fill: radial } )
      ]
    } );

    if ( type === 'svg' || type === 'canvas' || type === 'vello' ) {
      return getSceneryElement(
        scene, width, height, 'white', type
      );
    }
    else if ( type === 'box' || type === 'bilinear' || type === 'mitchellNetravali' ) {
      const filtering = {
        box: PolygonFilterType.Box,
        bilinear: PolygonFilterType.Bilinear,
        mitchellNetravali: PolygonFilterType.MitchellNetravali
      }[ type ];
      const program = RenderFromNode.addBackgroundColor( RenderFromNode.nodeToRenderProgram( scene ), Color.WHITE );

      return getRasterizedElement( program, width, height, {
        polygonFiltering: filtering
      } );
    }
  };

  const getRasterizedConflation = ( type, pointCount ) => {
    const width = 128;
    const height = 128;

    const center = v2( width / 2 + 0.15992094, height / 2 + 0.426296 );
    const radius = width * 0.45;

    const polygons = [];
    const colors = [];
    for ( let i = 0; i < pointCount; i++ ) {
      const polygon = [];
      const angle0 = i * 2 * Math.PI / pointCount;
      const angle1 = ( i + 1 ) * 2 * Math.PI / pointCount;

      const chroma = Vector2.createPolar( 0.1, angle0 );
      colors.push( RenderColor.gamutMapSRGB( RenderColor.convert( v4( 0.5, chroma.x, chroma.y, 1 ), RenderColorSpace.oklab, RenderColorSpace.sRGB ) ) );

      const p0 = v2( center.x + radius * Math.cos( angle0 ), center.y + radius * Math.sin( angle0 ) );
      const p1 = v2( center.x + radius * Math.cos( angle1 ), center.y + radius * Math.sin( angle1 ) );

      polygon.push( center );
      polygon.push( p0 );
      polygon.push( p1 );
      polygons.push( polygon );
    }

    if ( type === 'svg' || type === 'canvas' || type === 'vello' ) {
      return getSceneryElement(
        new Node( {
          children: [
            new Rectangle( 0, 64, 128, 64, { fill: 'black' } ),
            ...polygons.map( ( poly, i ) => {
              return new Path( Shape.polygon( poly ), { fill: new Color( colors[ i ].x * 255, colors[ i ].y * 255, colors[ i ].z * 255, 1 ) } );
            } )
          ]
        } ),
        width, height, 'white', type
      );
    }
    else if ( type === 'default' ) {
      const program = new RenderStack(
        [
          new RenderPathBoolean(
            new RenderPath( 'nonzero', [ [
              v2( 0, 64 ),
              v2( 128, 64 ),
              v2( 128, 128 ),
              v2( 0, 128 )
            ] ] ),
            RenderColor.from( 'black' ),
            RenderColor.from( 'white' )
          ),
          ...polygons.map( ( polygon, i ) => new RenderPathBoolean(
            new RenderPath( 'nonzero', [ polygon ] ),
            new RenderColor( colors[ i ] ),
            RenderColor.TRANSPARENT
          ) )
        ]
      );

      return getRasterizedElement( program, width, height );
    }
  };

  const getRasterizedSiemensStar = ( type, pointCount ) => {
    const width = 128;
    const height = 128;

    const center = v2( width / 2 + 0.15992094, height / 2 + 0.426296 );
    const radius = width * 0.49;

    const polygon = [];
    for ( let i = 0; i < pointCount; i++ ) {
      const angle0 = i * 2 * Math.PI / pointCount;
      const angle1 = ( i + 0.5 ) * 2 * Math.PI / pointCount;

      const p0 = v2( center.x + radius * Math.cos( angle0 ), center.y + radius * Math.sin( angle0 ) );
      const p1 = v2( center.x + radius * Math.cos( angle1 ), center.y + radius * Math.sin( angle1 ) );

      polygon.push( center );
      polygon.push( p0 );
      polygon.push( p1 );
    }

    if ( type === 'svg' || type === 'canvas' || type === 'vello' ) {
      return getSceneryElement(
        new Path( Shape.polygon( polygon ), { fill: 'black', renderer: type } ),
        width, height, 'white', type
      );
    }
    else if ( type === 'box' || type === 'bilinear' || type === 'mitchellNetravali' ) {
      const filtering = {
        box: PolygonFilterType.Box,
        bilinear: PolygonFilterType.Bilinear,
        mitchellNetravali: PolygonFilterType.MitchellNetravali
      }[ type ];

      const program = new RenderPathBoolean(
        new RenderPath( 'nonzero', [ polygon ] ),
        RenderColor.from( 'black' ),
        RenderColor.from( 'white' )
      );

      return getRasterizedElement( program, width, height, {
        polygonFiltering: filtering
      } );
    }
  };
</script>

<div class="navbar navbar-inverse navbar-static-top">
  <div class="navbar-inner">
    <a class="brand" href="/scenery">Scenery</a>
    <ul class="nav">
      <li><a href="../">Home</a></li>
      <li class="active"><a href="../doc">Documentation</a></li>
      <li><a href="../examples">Examples</a></li>
      <li><a href="../tests">Tests</a></li>
    </ul>
  </div>
</div>

<div class="row-fluid">
  <div class="span2"></div>
  <div class="span8">
    <div class="page-header" style="text-align: center;">
      <h1>Rasterization</h1>
    </div>
  </div>
  <div class="span2"></div>
</div>

<div class="row-fluid">
  <div class="span2">

  </div>
  <div class="span8">

    <h2>Conflation</h2>

    <p>
      Background colors can show up at joints between paths, due to blending with the background multiple times per pixel.
      Ideally there will be no white lines showing through, and no whitening toward the center.
    </p>

    <table class="table">
      <tbody>
        <tr>
          <td style="text-align: center;">Canvas</td>
          <td style="text-align: center;">SVG</td>
          <td style="text-align: center;">Vello</td>
          <td style="text-align: center;">Proposed Method</td>
        </tr>
        <tr>
          <td id="conflation-canvas"></td>
          <td id="conflation-svg"></td>
          <td id="conflation-vello"></td>
          <td id="conflation-default"></td>
        </tr>
      </tbody>
    </table>

    <script>
      setTimeout( async () => {
        document.getElementById( 'conflation-canvas' ).appendChild(
          getRasterizedConflation( 'canvas', 100 )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'conflation-svg' ).appendChild(
          getRasterizedConflation( 'svg', 100 )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        await DeviceContext.isVelloSupported();
        document.getElementById( 'conflation-vello' ).appendChild(
          getRasterizedConflation( 'vello', 100 )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'conflation-default' ).appendChild(
          getRasterizedConflation( 'default', 100 )
        );
      } );
    </script>

    <h2>Gradient Aliasing</h2>

    <table class="table">
      <tbody>
        <tr>
          <td style="text-align: center;">Canvas</td>
          <td style="text-align: center;">SVG</td>
          <td style="text-align: center;">Vello</td>
          <td style="text-align: center;">Proposed Method (box)</td>
          <td style="text-align: center;">Proposed Method (bilinear)</td>
          <td style="text-align: center;">Proposed Method (Mitchell-Netravali)</td>
        </tr>
        <tr>
          <td id="gradient-aliasing-canvas"></td>
          <td id="gradient-aliasing-svg"></td>
          <td id="gradient-aliasing-vello"></td>
          <td id="gradient-aliasing-box"></td>
          <td id="gradient-aliasing-bilinear"></td>
          <td id="gradient-aliasing-mitchell-netravali"></td>
        </tr>
      </tbody>
    </table>

    <script>
      setTimeout( async () => {
        document.getElementById( 'gradient-aliasing-canvas' ).appendChild(
          getGradientAliasing( 'canvas' )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'gradient-aliasing-svg' ).appendChild(
          getGradientAliasing( 'svg' )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        await DeviceContext.isVelloSupported();
        document.getElementById( 'gradient-aliasing-vello' ).appendChild(
          getGradientAliasing( 'vello' )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'gradient-aliasing-box' ).appendChild(
          getGradientAliasing( 'box' )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'gradient-aliasing-bilinear' ).appendChild(
          getGradientAliasing( 'bilinear' )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'gradient-aliasing-mitchell-netravali' ).appendChild(
          getGradientAliasing( 'mitchellNetravali' )
        );
      } );
    </script>

    <h2>Gradient Precision</h2>

    <table class="table">
      <tbody>
        <tr>
          <td style="text-align: center;">Canvas</td>
          <td style="text-align: center;">SVG</td>
          <td style="text-align: center;">Vello</td>
          <td style="text-align: center;">Proposed Method</td>
        </tr>
        <tr>
          <td id="gradient-precision-canvas"></td>
          <td id="gradient-precision-svg"></td>
          <td id="gradient-precision-vello"></td>
          <td id="gradient-precision-box"></td>
        </tr>
      </tbody>
    </table>

    <script>
      setTimeout( async () => {
        document.getElementById( 'gradient-precision-canvas' ).appendChild(
          getGradientPrecision( 'canvas' )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'gradient-precision-svg' ).appendChild(
          getGradientPrecision( 'svg' )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        await DeviceContext.isVelloSupported();
        document.getElementById( 'gradient-precision-vello' ).appendChild(
          getGradientPrecision( 'vello' )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'gradient-precision-box' ).appendChild(
          getGradientPrecision( 'box' )
        );
      } );
    </script>

    <h2>Filtered Polygons</h2>

    <table class="table">
      <tbody>
        <tr>
          <td style="text-align: center;">Reference (dirac delta)</td>
          <td style="text-align: center;">Box</td>
          <td style="text-align: center;">Bilinear</td>
          <td style="text-align: center;">Mitchell-Netravali</td>
        </tr>
        <tr>
          <td id="filter-reference"></td>
          <td id="filter-box"></td>
          <td id="filter-bilinear"></td>
          <td id="filter-mitchell-netravali"></td>
        </tr>
      </tbody>
    </table>

    <script>
      setTimeout( async () => {
        document.getElementById( 'filter-reference' ).appendChild(
          getFiltered( PolygonFilterType.Box, 1 )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'filter-box' ).appendChild(
          getFiltered( PolygonFilterType.Box, 10 )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'filter-bilinear' ).appendChild(
          getFiltered( PolygonFilterType.Bilinear, 10 )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'filter-mitchell-netravali' ).appendChild(
          getFiltered( PolygonFilterType.MitchellNetravali, 10 )
        );
      } );
    </script>

    <h2>Siemens Stars</h2>

    <p>
      Alternating radial bands of light/dark, to visualize aliasing. It should blur towards a consistent gray toward the
      center (not showing extra patterns, OR showing a darker gray).
    </p>

    <table class="table">
      <tbody>
        <tr>
          <td style="text-align: center;">Canvas</td>
          <td style="text-align: center;">SVG</td>
          <td style="text-align: center;">Vello</td>
          <td style="text-align: center;">Proposed Method (box)</td>
          <td style="text-align: center;">Proposed Method (bilinear)</td>
          <td style="text-align: center;">Proposed Method (Mitchell-Netravali)</td>
        </tr>
        <tr>
          <td id="siemens-star-canvas"></td>
          <td id="siemens-star-svg"></td>
          <td id="siemens-star-vello"></td>
          <td id="siemens-star-box"></td>
          <td id="siemens-star-bilinear"></td>
          <td id="siemens-star-mitchell-netravali"></td>
        </tr>
      </tbody>
    </table>

    <script>
      setTimeout( async () => {
        document.getElementById( 'siemens-star-canvas' ).appendChild(
          getRasterizedSiemensStar( 'canvas', 200 )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'siemens-star-svg' ).appendChild(
          getRasterizedSiemensStar( 'svg', 200 )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        await DeviceContext.isVelloSupported();
        document.getElementById( 'siemens-star-vello' ).appendChild(
          getRasterizedSiemensStar( 'vello', 200 )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'siemens-star-box' ).appendChild(
          getRasterizedSiemensStar( 'box', 200 )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'siemens-star-bilinear' ).appendChild(
          getRasterizedSiemensStar( 'bilinear', 200 )
        );
      } );
    </script>
    <script>
      setTimeout( async () => {
        document.getElementById( 'siemens-star-mitchell-netravali' ).appendChild(
          getRasterizedSiemensStar( 'mitchellNetravali', 200 )
        );
      } );
    </script>

  </div>
  <div class="span2"></div>
</div>

</body>
</html>
