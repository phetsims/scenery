<!DOCTYPE html>
<html>
<!--
When run in the browser, this will load code into the global namespace so that it can be tested via the developer console. Additionally, it provides
an UI and Display made for visual testing and debugging.
-->
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Scenery Playground</title>

  <script>
    window.phet = window.phet || {};
  </script>

  <!-- Before loading other things (that might error), create hooks to report errors/loads for continuous testing -->
  <script src="../../chipper/js/sim-tests/pageload-connector.js"></script>

  <!-- jQuery and LoDash are dependencies -->
  <script src="../../sherpa/lib/jquery-2.1.0.min.js"></script>
  <script src="../../sherpa/lib/lodash-4.17.4.min.js"></script>

  <script src="../../assert/js/assert.js"></script>
  <script src="../../tandem/js/PhetioIDUtils.js"></script>
  <script src="../../sherpa/lib/himalaya-1.1.0.js"></script>
  <script src="../../sherpa/lib/linebreak-1.1.0.js"></script>
  <script src="../../sherpa/lib/flatqueue-1.2.1.js"></script>
  <script src="../../sherpa/lib/paper-js-0.12.17.js"></script>
  <script src="../../sherpa/lib/he-1.1.1.js"></script>
  <script src="../../sherpa/lib/TextEncoderLite-3c9f6f0.js"></script>
  <script src="../../sherpa/lib/base64-js-1.2.0.js"></script>

  <script type="text/javascript">
    window.assertions.enableAssert();
    window.assertions.enableAssertSlow();
  </script>


  <style>
    html, body {
      background-color: #eee;
      border: 0;
      padding: 0;
    }

    #display {
      background-color: #fff;
    }

    #debug, #a11yDebug {
      position: relative;
      top: 320px;
      padding: 0.5em;
      border: 1px solid rgba(0, 0, 255, 0.3);
    }

    #serialized {
      position: relative;
      top: 320px;
      padding: 0.5em;
      border: 1px solid rgba(0, 0, 0, 0.3);
    }

    #controls {
      position: absolute;
      width: 170px;
      top: 0;
      right: 0;
    }
  </style>

</head>
<body>

<div id="controls">
  <button onclick="toggleDebug();">Toggle Debug</button>
  <br>
  <button onclick="toggleA11yDebug();">Toggle A11y</button>
  <br>
  <button onclick="toggleLogging();">Toggle Logging</button>
  <br>
  <button onclick="display.setPointerDisplayVisible( !display._pointerOverlay );">Toggle Pointer Overlay</button>
  <br>
  <button onclick="display.setPointerAreaDisplayVisible( !display._pointerAreaOverlay );">Toggle Pointer Area Overlay
  </button>
  <br>
  <button onclick="toggleUpdates();">Toggle Update</button>
  <br>
  <button onclick="display.initializeEvents();">Events</button>
  <br>
  <br>
  <button onclick="display.updateDisplay();">Update</button>
  <br>
  <button onclick="display.popupDebug();">Popup Debug</button>
  <br>
</div>

<script type="module">
  import '../../chipper/dist/js/scenery/js/main.js'; // eslint-disable-line bad-sim-text
  import '../../chipper/dist/js/phet-core/js/main.js';
  import '../../chipper/dist/js/axon/js/main.js';
  import '../../chipper/dist/js/dot/js/main.js';
  import '../../chipper/dist/js/kite/js/main.js';
  import '../../chipper/dist/js/utterance-queue/js/main.js';

  console.log( 'loaded' );

  window.scene = new phet.scenery.Node();

  var display = window.display = new phet.scenery.Display( scene, {
    width: 640,
    height: 320,
    preserveDrawingBuffer: true,
    accessibility: true
    // any overrides here?
  } );
  console.log( 'window.display created' );

  display._domElement.id = 'display';
  document.body.insertBefore( display._domElement, document.body.firstChild );

  phet.scenery.Utils.polyfillRequestAnimationFrame();

  // convenience function for IE stack trackes
  window.twrap = function( f ) {
    try {
      f();
    }
    catch( e ) {
      console.log( e.stack );
    }
  };

  window.accessibleTest = function() {
    setTimeout( function() {

      display.initializeEvents();
      document.body.appendChild( display.domElement );

      const a = new phet.scenery.Rectangle( 0, 0, 20, 20, { tagName: 'button' } );

      let aGotFocus = false;
      let aLostFocus = false;
      let bGotFocus = false;

      scene.addChild( a );

      a.addInputListener( {
        focus() {
          aGotFocus = true;
        },
        blur() {
          aLostFocus = true;
        }
      } );

      a._pdomInstances[ 0 ].peer._primarySibling.addEventListener( 'focusin', () => console.log( 'primary focusin' ) );
      a._pdomInstances[ 0 ].peer._primarySibling.addEventListener( 'focus', () => console.log( 'primary focus' ) );
      display.pdomRootElement.addEventListener( 'focusin', () => console.log( 'element focusin' ) );
      display.pdomRootElement.addEventListener( 'focus', () => console.log( 'element focus' ) );

      a.focus();

      window.element = a._pdomInstances[ 0 ].peer._primarySibling;
      element.focus();
    } )
  };

  window.interpTest = function() {
    var canvas = document.createElement( 'canvas' );
    var context = canvas.getContext( '2d' )
    canvas.width = 4;
    canvas.height = 4;
    context.fillStyle = 'rgba(255,255,255,1)'
    context.fillRect( 0, 0, 2, 4 );
    context.fillStyle = 'rgba(255,0,0,1)'
    context.fillRect( 0, 0, 1, 4 );
    context.fillStyle = 'rgba(0,0,255,1)'
    context.fillRect( 3, 0, 1, 4 );
    context.fillStyle = 'rgba(0,0,0,0)'
    context.fillRect( 2, 0, 2, 4 );
    var im = new phet.scenery.Image( canvas );
    scene.addChild( im );
    im.setScaleMagnitude( 100 );
    im.renderer = 'webgl';
    toggleUpdates();
  };

  window.blendTest = function() {
    display.width = 512;
    display.height = 512;

    var canvas = document.createElement( 'canvas' );
    var context = canvas.getContext( '2d' )
    canvas.width = 4;
    canvas.height = 4;
    context.fillStyle = 'rgba(255,255,255,1)'
    context.fillRect( 0, 0, 2, 4 );
    context.fillStyle = 'rgba(255,0,0,1)'
    context.fillRect( 0, 0, 1, 4 );
    context.fillStyle = 'rgba(0,0,255,1)'
    context.fillRect( 3, 0, 1, 4 );
    context.fillStyle = 'rgba(0,0,0,0)'
    context.fillRect( 2, 0, 2, 4 );

    var canvas2 = document.createElement( 'canvas' );
    var context2 = canvas2.getContext( '2d' );
    canvas2.width = 256;
    canvas2.height = 256;
    var gradient = context2.createLinearGradient( 0, 0, 168, 0 );
    gradient.addColorStop( 0.00 / 0.75, 'rgba(0,0,0,1)' );
    gradient.addColorStop( 0.05 / 0.75, 'rgba(255,0,0,1)' );
    gradient.addColorStop( 0.10 / 0.75, 'rgba(160,160,160,1)' );
    gradient.addColorStop( 0.15 / 0.75, 'rgba(160,160,160,0)' );
    gradient.addColorStop( 0.20 / 0.75, 'rgba(255,255,255,1)' );
    gradient.addColorStop( 0.25 / 0.75, 'rgba(255,255,255,0)' );
    gradient.addColorStop( 0.30 / 0.75, 'rgba(255,255,255,1)' );
    gradient.addColorStop( 0.35 / 0.75, 'rgba(0,0,0,0)' );
    gradient.addColorStop( 0.40 / 0.75, 'rgba(0,0,0,1)' );
    gradient.addColorStop( 0.45 / 0.75, 'rgba(255,255,255,0)' );
    gradient.addColorStop( 0.50 / 0.75, 'rgba(0,0,0,1)' );
    gradient.addColorStop( 0.55 / 0.75, 'rgba(0,0,0,0)' );
    gradient.addColorStop( 0.60 / 0.75, 'rgba(0,0,255,1)' );
    gradient.addColorStop( 0.65 / 0.75, 'rgba(255,255,255,0)' );
    gradient.addColorStop( 0.70 / 0.75, 'rgba(0,0,255,1)' );
    gradient.addColorStop( 0.75 / 0.75, 'rgba(0,0,0,0)' );
    context2.fillStyle = gradient;
    context2.fillRect( 0, 0, 168, 256 );

    var im = new phet.scenery.Image( canvas );
    im.setScaleMagnitude( 16, 64 );
    im.x = 80;
    var im2 = new phet.scenery.Image( canvas2 );
    im2.x = 176;
    var im3 = new phet.scenery.Image( canvas2.toDataURL() );
    im3.x = 176 + 168;

    const bars = new phet.scenery.Node( {
      children: [
        new phet.scenery.Rectangle( 0, 0, 16, 256, {
          fill: 'rgba(0,255,0,1)'
        } ),
        new phet.scenery.Rectangle( 16, 0, 16, 256, {
          fill: 'rgba(0,0,0,0)'
        } ),
        new phet.scenery.Rectangle( 32, 0, 16, 256, {
          fill: 'rgba(255,255,255,0)'
        } ),
        new phet.scenery.Rectangle( 48, 0, 16, 256, {
          fill: 'rgba(0,0,0,0.5)'
        } ),
        new phet.scenery.Rectangle( 64, 0, 16, 256, {
          fill: 'rgba(255,255,255,0.5)'
        } ),
        im,
        new phet.scenery.Rectangle( 144, 0, 16, 256, {
          fill: 'rgba(128,128,128,1)'
        } ),
        new phet.scenery.Rectangle( 160, 0, 16, 256, {
          fill: 'rgba(128,128,128,0.5)'
        } ),
        im2,
        im3
      ]
    } );

    const section = new phet.scenery.Node( {
      children: [
        new phet.scenery.Rectangle( 0, 0, 512, 256, {
          fill: new phet.scenery.LinearGradient( 0, 0, 0, 256 )
              .addColorStop( 0, 'rgba(255,0,0,1)' )
              .addColorStop( 0.3, 'rgba(255,0,0,0)' )
              .addColorStop( 0.4, 'rgba(255,255,255,0)' )
              .addColorStop( 0.6, 'rgba(255,255,0,1)' )
              .addColorStop( 0.8, 'rgba(0,0,0,1)' )
              .addColorStop( 1, 'rgba(128,128,128,0.5)' )
        } ),
        bars
      ]
    } );

    scene.addChild( new phet.scenery.Node( {
      children: [ section ],
      renderer: 'svg'
    } ) );

    const webglNode = new phet.scenery.Node( {
      y: 512,
      children: [ section ],
      renderer: 'webgl'
    } );
    webglNode.setScaleMagnitude( 1, -1 );
    scene.addChild( webglNode );

    toggleUpdates();
  };

  window.focusTest = function() {
    setTimeout( function() {
      toggleUpdates();
      display.initializeEvents();

      var button = new phet.scenery.Rectangle( 10, 10, 100, 60, {
        fill: 'gray',
        tagName: 'div',
        focusable: true
      } );
      button.addInputListener( {
        click: function( domEvent, trail ) {
          console.log( param1, param2 );
        }
      } );
      scene.addChild( new phet.scenery.Node( {
        children: [ button ]
      } ) );
      scene.addChild( new phet.scenery.Node( {
        children: [ button ],
        y: 100
      } ) );
    } );
  };

  window.debugPDOMInstances = function() {
    recurse( display._rootPDOMInstance, '' );

    function recurse( instance, indentation ) {
      console.log( indentation + ( instance.isRootInstance ? '' : instance.node.tagName ) + ' ' + instance.toString() );
      instance.children.forEach( function( child ) { recurse( child, indentation + '  ' ) } );
    }
  };

  window.debugDOM = function() {
    var parallelDOM = display._rootPDOMInstance.peer.primarySibling.outerHTML;
    parallelDOM = parallelDOM.replace( /\>\</g, '>\n<' );
    var lines = parallelDOM.split( '\n' );

    var indentation = '';
    var indentedLines = [];
    for ( var i = 0; i < lines.length; i++ ) {
      var line = lines[ i ];
      var isEndTag = line.slice( 0, 2 ) === '</';

      if ( isEndTag ) {
        indentation = indentation.slice( 2 );
      }
      indentedLines.push( indentation + line );
      if ( !isEndTag ) {
        indentation += '  ';
      }
    }

    console.log( indentedLines.join( '\n' ) );
  };

  window.rasterTest = function() {
    setTimeout( async function() {
      const pathA = new phet.scenery.RenderPath( 'nonzero', [
        [
          new phet.dot.Vector2( 0, 0 ),
          new phet.dot.Vector2( 10, 0 ),
          new phet.dot.Vector2( 13.52, 17.154 ),
          new phet.dot.Vector2( 0, 10 )
        ]
      ] );
      const pathB = new phet.scenery.RenderPath( 'nonzero', [
        [
          new phet.dot.Vector2( 5, 5 ),
          new phet.dot.Vector2( 15, 5 ),
          new phet.dot.Vector2( 24.2105, 21.5142 ),
          new phet.dot.Vector2( 5, 15 )
        ]
      ] );
      const pathC = new phet.scenery.RenderPath( 'nonzero', [
        [
          new phet.dot.Vector2( 0, 0 ),
          new phet.dot.Vector2( 20, 0 ),
          new phet.dot.Vector2( 20, 20 ),
          new phet.dot.Vector2( 0, 20 )
        ]
      ] );
      const pathD = new phet.scenery.RenderPath( 'nonzero', [
        [
          new phet.dot.Vector2( 0, 0 ),
          new phet.dot.Vector2( 40, 0 ),
          new phet.dot.Vector2( 32, 32 ),
          new phet.dot.Vector2( 0, 40 )
        ]
      ] );

      const a = phet.scenery.RenderColor.fromColor( pathA, new phet.scenery.Color( 255, 0, 0, 1 ) );
      const b = phet.scenery.RenderColor.fromColor( pathB, new phet.scenery.Color( 0, 255, 0, 1 ) );
      const c = phet.scenery.RenderColor.fromColor( pathC, new phet.scenery.Color( 0, 0, 255, 0.7 ) );
      const d = new phet.scenery.RenderLinearGradient( pathD, phet.dot.Matrix3.IDENTITY, new phet.dot.Vector2( 0, 32 ), new phet.dot.Vector2( 32, 0 ), [
        new phet.scenery.RenderGradientStop( 0, phet.scenery.RenderColor.fromColor( null, new phet.scenery.Color( 255,57,2, 1 ) ) ),
        new phet.scenery.RenderGradientStop( 0.25, phet.scenery.RenderColor.fromColor( null, new phet.scenery.Color( 255,128,7, 1 ) ) ),
        new phet.scenery.RenderGradientStop( 0.5, phet.scenery.RenderColor.fromColor( null, new phet.scenery.Color( 255,180,4, 1 ) ) ),
        new phet.scenery.RenderGradientStop( 0.75, phet.scenery.RenderColor.fromColor( null, new phet.scenery.Color( 5,186,221, 1 ) ) ),
        new phet.scenery.RenderGradientStop( 1, phet.scenery.RenderColor.fromColor( null, new phet.scenery.Color( 43,72,113, 1 ) ) )
      ], 0 );
      const back = phet.scenery.RenderColor.fromColor( null, new phet.scenery.Color( 128, 128, 128, 0.5 ) );

      const bc = new phet.scenery.RenderBlendCompose( 3, 0, b, c );
      const dx = new phet.scenery.RenderBlendCompose( 0, 0, d, back );
      const bcd = new phet.scenery.RenderBlendCompose( 0, 0, bc, dx );
      const program = new phet.scenery.RenderBlendCompose( 0, 0, a, bcd );

      const canvas = program.slowRasterizeToCanvas( 64, 64, 8 );
      canvas.style.width = ( canvas.width / window.devicePixelRatio ) + 'px';
      canvas.style.height = ( canvas.height / window.devicePixelRatio ) + 'px';
      document.body.appendChild( canvas );
      console.log( canvas.toDataURL() );
    } )
  };

  window.mitchellNetravaliTest1 = () => {
    setTimeout( async function() {
      const width = 1024;
      const height = 1024;
      const imageData = new ImageData( width, height );

      const polygon = [
        phet.dot.v2( 3, 3 ),
        phet.dot.v2( 7, 3 ),
        phet.dot.v2( 3, 7 )
      ];

      const bounds = new phet.dot.Bounds2( 0, 0, 10, 10 );

      for ( let i = 0; i < height; i++ ) {
        for ( let j = 0; j < width; j++ ) {
          const x = bounds.minX + bounds.width * ( j / width );
          const y = bounds.minY + bounds.height * ( i / height );

          const value = phet.scenery.PolygonMitchellNetravali.evaluate( polygon, phet.dot.v2( x, y ) );
          const floor = 50;

          const r = value * ( 255 - floor ) + floor;
          const g = value * ( 255 - floor ) + floor;
          const b = value * ( 255 - floor ) + floor;
          const a = 255;
          const index = 4 * ( i * width + j );
          imageData.data[ index ] = r;
          imageData.data[ index + 1 ] = g;
          imageData.data[ index + 2 ] = b;
          imageData.data[ index + 3 ] = a;
        }
      }

      const canvas = document.createElement( 'canvas' );
      canvas.width = width;
      canvas.height = height;
      canvas.style.width = ( width / window.devicePixelRatio ) + 'px';
      canvas.style.height = ( height / window.devicePixelRatio ) + 'px';
      const context = canvas.getContext( '2d' );
      context.putImageData( imageData, 0, 0 );

      // example
      const examplePoint = phet.dot.v2( 4.5, 5.5 );
      const exampleBounds = new phet.dot.Bounds2( examplePoint.x, examplePoint.y, examplePoint.x + 1, examplePoint.y + 1 );

      /*
          const clippedPolygon = PolygonClipping.boundsClipPolygon( polygon, bounds );
    // const clippedPolygon = PolygonClipping.sillyClipPolygon( polygon, bounds );
    // const clippedPolygon = phet.kite.Shape.polygon( polygon ).shapeIntersection( phet.kite.Shape.bounds( bounds ) )?.subpaths[ 0 ]?.points || [];
       */

      const exampleClip = phet.scenery.PolygonClipping.boundsClipPolygon( polygon, exampleBounds );

      console.log( exampleClip );

      context.strokeStyle = 'red';
      context.beginPath();
      context.moveTo( polygon[ 0 ].x * width / bounds.width, polygon[ 0 ].y * height / bounds.height );
      context.lineTo( polygon[ 1 ].x * width / bounds.width, polygon[ 1 ].y * height / bounds.height );
      context.lineTo( polygon[ 2 ].x * width / bounds.width, polygon[ 2 ].y * height / bounds.height );
      context.closePath();
      context.stroke();

      context.strokeStyle = 'blue';
      context.beginPath();
      context.moveTo( exampleBounds.minX * width / bounds.width, exampleBounds.minY * height / bounds.height );
      context.lineTo( exampleBounds.maxX * width / bounds.width, exampleBounds.minY * height / bounds.height );
      context.lineTo( exampleBounds.maxX * width / bounds.width, exampleBounds.maxY * height / bounds.height );
      context.lineTo( exampleBounds.minX * width / bounds.width, exampleBounds.maxY * height / bounds.height );
      context.closePath();
      context.stroke();

      if ( exampleClip.length ) {
        context.fillStyle = 'rgba(255,0,0,0.3)';
        context.beginPath();
        context.moveTo( exampleClip[ 0 ].x * width / bounds.width, exampleClip[ 0 ].y * height / bounds.height );
        for ( let i = 1; i < exampleClip.length; i++ ) {
          context.lineTo( exampleClip[ i ].x * width / bounds.width, exampleClip[ i ].y * height / bounds.height );
        }
        context.closePath();
        context.fill();
      }

      document.body.appendChild( canvas );
    } );
  };

  window.mitchellNetravaliTest2 = () => {
    setTimeout( async function() {
      const width = 1024;
      const height = 1024;
      const imageData = new ImageData( width, height );

      const polygon = [
        phet.dot.v2( 300, 300 ),
        phet.dot.v2( 700, 300 ),
        phet.dot.v2( 300, 700 )
      ];

      const bounds = new phet.dot.Bounds2( 0, 0, width, height );

      for ( let i = 0; i < height; i++ ) {
        for ( let j = 0; j < width; j++ ) {
          const x = bounds.minX + bounds.width * ( j / width ) + 0.5;
          const y = bounds.minY + bounds.height * ( i / height ) + 0.5;

          const value = phet.scenery.PolygonMitchellNetravali.evaluate( polygon, phet.dot.v2( x, y ) );

          const paddedValue = 0.9 * value + 0.05;

          const color = phet.scenery.RenderColor.premultipliedLinearToColor( phet.dot.v4( paddedValue, paddedValue, paddedValue, 1 ) );

          const index = 4 * ( i * width + j );
          imageData.data[ index ] = color.r;
          imageData.data[ index + 1 ] = color.g;
          imageData.data[ index + 2 ] = color.b;
          imageData.data[ index + 3 ] = Math.floor( color.a * 255 );
        }
      }

      const canvas = document.createElement( 'canvas' );
      canvas.width = width;
      canvas.height = height;
      canvas.style.width = ( width / window.devicePixelRatio ) + 'px';
      canvas.style.height = ( height / window.devicePixelRatio ) + 'px';
      const context = canvas.getContext( '2d' );
      context.putImageData( imageData, 0, 0 );

      document.body.appendChild( canvas );
    } );
  };

  // Siemens star
  window.mitchellNetravaliTest3 = () => {
    setTimeout( async function() {
      assert = false;
      assertSlow = false;

      const width = 1024;
      const height = 1024;
      const imageData = new ImageData( width, height );

      const center = phet.dot.v2( width / 2 + 0.15992094, height / 2 + 0.426296 );
      const radius = width / 3;
      const pointCount = 100;

      const polygon = [];
      for ( let i = 0; i < pointCount; i++ ) {
        const angle0 = i * 2 * Math.PI / pointCount;
        const angle1 = ( i + 0.5 ) * 2 * Math.PI / pointCount;

        const p0 = phet.dot.v2( center.x + radius * Math.cos( angle0 ), center.y + radius * Math.sin( angle0 ) );
        const p1 = phet.dot.v2( center.x + radius * Math.cos( angle1 ), center.y + radius * Math.sin( angle1 ) );

        polygon.push( center );
        polygon.push( p0 );
        polygon.push( p1 );
      }

      const bounds = new phet.dot.Bounds2( 0, 0, width, height );

      for ( let i = 0; i < height; i++ ) {
        console.log( i );
        for ( let j = 0; j < width; j++ ) {
          const x = bounds.minX + bounds.width * ( j / width ) + 0.5;
          const y = bounds.minY + bounds.height * ( i / height ) + 0.5;

          const value = phet.scenery.PolygonMitchellNetravali.evaluate( polygon, phet.dot.v2( x, y ) );


          // const p = phet.dot.v2( x, y );
          // const anglePart = ( Math.atan2( p.y - center.y, p.x - center.x ) + Math.PI ) / ( 2 * Math.PI );
          // const value = p.distance( center ) < radius ? ( ( ( anglePart * pointCount ) % 1 ) < 0.5 ? 1 : 0 ) : 0;


          // let sum = 0;
          // for ( let k = 0; k < 1000; k++ ) {
          //   const p = phet.dot.v2( x + Math.random() - 0.5, y + Math.random() - 0.5 );
          //   const anglePart = ( Math.atan2( p.y - center.y, p.x - center.x ) + Math.PI ) / ( 2 * Math.PI );
          //   sum += p.distance( center ) < radius ? ( ( ( anglePart * pointCount ) % 1 ) < 0.5 ? 1 : 0 ) : 0;
          // }
          // const value = sum / 1000;



          const paddedValue = 0.95 - 0.9 * value;

          const color = phet.scenery.RenderColor.premultipliedLinearToColor( phet.dot.v4( paddedValue, paddedValue, paddedValue, 1 ) );

          const index = 4 * ( i * width + j );
          imageData.data[ index ] = color.r;
          imageData.data[ index + 1 ] = color.g;
          imageData.data[ index + 2 ] = color.b;
          imageData.data[ index + 3 ] = Math.floor( color.a * 255 );
        }
      }

      const canvas = document.createElement( 'canvas' );
      canvas.width = width;
      canvas.height = height;
      canvas.style.width = ( width / window.devicePixelRatio ) + 'px';
      canvas.style.height = ( height / window.devicePixelRatio ) + 'px';
      const context = canvas.getContext( '2d' );
      context.putImageData( imageData, 0, 0 );

      document.body.appendChild( canvas );
    } );
  };

  window.clipTest = function() {
    setTimeout( async function() {
      const inPolygon = [
        new phet.dot.Vector2( -10, -10 ),
        new phet.dot.Vector2( 50, -30 ),
        new phet.dot.Vector2( 40, 5 ),
        new phet.dot.Vector2( 130, -20 ),
        new phet.dot.Vector2( 50, 120 ),
        new phet.dot.Vector2( -20, 120 ),
        new phet.dot.Vector2( -50, -20 ),
        new phet.dot.Vector2( -10, 80 ),
        new phet.dot.Vector2( -10, 110 ),
        new phet.dot.Vector2( 20, 110 ),
        new phet.dot.Vector2( 60, 20 )
      ];

      const container = new phet.scenery.Node( {
        children: [
          new phet.scenery.Path( phet.kite.Shape.polygon( inPolygon ), {
            stroke: 'red',
            lineWidth: 0.2,
            lineJoin: 'round'
          } )
        ],
        x: 200,
        y: 200,
        scale: 2
      } );
      scene.addChild( container );

      const addBounds = bounds => {
        const outPolygon = phet.scenery.PolygonClipping.boundsClipPolygon( inPolygon, bounds );

        container.addChild( new phet.scenery.Path( phet.kite.Shape.bounds( bounds ), {
          stroke: 'black',
          lineWidth: 0.2,
          lineJoin: 'round'
        } ) );
        container.addChild( new phet.scenery.Path( phet.kite.Shape.polygon( outPolygon ), {
          stroke: 'blue',
          fill: 'rgba(0,0,0,0.1)',
          lineWidth: 1,
          lineJoin: 'round'
        } ) );
      };
      addBounds( new phet.dot.Bounds2( 0, 0, 100, 100 ) );
      addBounds( new phet.dot.Bounds2( 100, 0, 200, 100 ) );
      addBounds( new phet.dot.Bounds2( -100, 0, 0, 100 ) );
      addBounds( new phet.dot.Bounds2( 0, -100, 100, 0 ) );
      addBounds( new phet.dot.Bounds2( 100, -100, 200, 0 ) );
      addBounds( new phet.dot.Bounds2( -100, -100, 0, 0 ) );
      addBounds( new phet.dot.Bounds2( 0, 100, 100, 200 ) );
      addBounds( new phet.dot.Bounds2( 100, 100, 200, 200 ) );
      addBounds( new phet.dot.Bounds2( -100, 100, 0, 200 ) );

      display.width = 1024;
      display.height = 1024;
      display.updateDisplay();
    } );
  };

  window.displayTest = function() {
    setTimeout( async function() {
      const rect = new phet.scenery.Rectangle( 0, 0, 50, 50, {
        fill: 'blue',
        children: [
          new phet.scenery.Rectangle( 0, -7.5, 200, 15, {
            fill: 'red',
            rotation: Math.PI / 4
          } ),
          new phet.scenery.Rectangle( 0, -7.5, 200, 15, {
            fill: 'white',
            rotation: -Math.PI / 4,
            y: 50
          } )
        ]
      } );
      let url;
      rect.toCanvas( canvas => {
        url = canvas.toDataURL();
      }, 0, 0, 50, 50 );

      console.log( url );
      const img = document.createElement( 'img' );
      img.addEventListener( 'load', () => {
        const pattern = new phet.scenery.Pattern( img );
        const gradient = new phet.scenery.LinearGradient( 0, 0, 400, 400 ).addColorStop( 0, 'red' ).addColorStop( 1, 'blue' );

        pattern.setTransformMatrix( phet.dot.Matrix3.translation( 12.5, 12.5 ).timesMatrix( phet.dot.Matrix3.scaling( 4 ) ) );
        gradient.setTransformMatrix( phet.dot.Matrix3.translation( 12.5, 12.5 ).timesMatrix( phet.dot.Matrix3.scaling( 4 ) ) );

        window.r = new phet.scenery.Rectangle( -200, -200, 400, 400, {
          fill: pattern,
          renderer: 'vello',
          x: 200,
          y: 200
        } );
        scene.addChild( r );
        window.s = new phet.scenery.Rectangle( 0, 0, 400, 400, {
          y: 400,
          renderer: 'vello',
          fill: gradient
        } );
        scene.addChild( s );

        display.width = 512;
        display.height = 800;
        display.updateDisplay();
      } );
      img.src = url;

      // const sceneryImports = await import( '../../chipper/dist/js/scenery/js/imports.js' );
      //
      // const canvas = document.createElement( 'canvas' );
      // const fullWidth = 512;
      // const fullHeight = 512;
      // canvas.width = Math.ceil( fullWidth * window.devicePixelRatio );
      // canvas.height = Math.ceil( fullHeight * window.devicePixelRatio );
      // canvas.style.width = `${fullWidth}px`;
      // canvas.style.height = `${fullHeight}px`;
      //
      // document.body.appendChild( canvas );
      //
      // const PhetEncoding = phet.scenery.PhetEncoding;
      // const DeviceContext = phet.scenery.DeviceContext;
      //
      // const deviceContext = await DeviceContext.create();
      // const canvasContext = deviceContext.getCanvasContext( canvas );
      //
      // // const sceneEncoding = exampleScene( window.devicePixelRatio );
      // const sceneEncoding = new phet.scenery.PhetEncoding();
      // sceneEncoding.reset( false );
      //
      // const encoding = new phet.scenery.PhetEncoding();
      //
      // const node = new phet.scenery.Node( {
      //   children: [
      //     new phet.scenery.Rectangle( 0, 0, 100, 50, { fill: 'red' } ),
      //     new phet.scenery.Rectangle( 0, 50, 100, 50, { fill: new phet.scenery.LinearGradient( 0, 0, 100, 0 ).addColorStop( 0, 'red' ).addColorStop( 1, 'blue' ) } ),
      //     new phet.scenery.Rectangle( 0, 100, 100, 50, { fill: new phet.scenery.LinearGradient( 0, 0, 100, 0 ).addColorStop( 0.3, 'red' ).addColorStop( 0.7, 'orange' ) } ),
      //     new phet.scenery.Rectangle( 0, 150, 100, 100, { fill: new phet.scenery.RadialGradient( 0, 150, 0, 0, 150, 100 ).addColorStop( 0.3, 'red' ).addColorStop( 0.7, 'orange' ) } ),
      //     new phet.scenery.Text( 'Hello World', {
      //       font: new phet.scenery.Font( { size: 20 } ),
      //       top: 10,
      //       left: 10,
      //       fill: 'black'
      //     } )
      //   ],
      //   clipArea: phet.kite.Shape.rect( 0, 20, 512, 512 )
      // } );
      //
      // encoding.encode_node( node );
      //
      //
      // // const angle = Date.now() / 1000;
      // // let c = Math.cos( angle );
      // // let s = Math.sin( angle );
      // //
      // // encoding.encode_transform( new phet.scenery.Affine( c, -s, s, c, 200, 100 ) );
      // // encoding.encode_linewidth( -1 );
      // // encoding.encode_path( true );
      // // encoding.move_to( -100, -100 );
      // // encoding.quad_to( 0, 0, 100, -100 );
      // // encoding.line_to( 100, 100 );
      // // encoding.cubic_to( 0, 200, 0, 0, -100, 100 );
      // // encoding.line_to( -100, -100 );
      // // encoding.close();
      // // encoding.finish( true );
      // // encoding.encode_linear_gradient( -100, 0, 100, 0, [
      // //   new phet.scenery.VelloColorStop( 0, 0xff0000ff ),
      // //   new phet.scenery.VelloColorStop( 1, 0x0000ffff )
      // // ], phet.scenery.Extend.Pad );
      //
      //
      //
      //
      // sceneEncoding.append( encoding, new phet.scenery.Affine( window.devicePixelRatio, 0, 0, window.devicePixelRatio, 0, 0 ) );
      //
      // sceneEncoding.finalize_scene();
      //
      // const outTexture = canvasContext.getCurrentTexture();
      // const renderInfo = sceneEncoding.resolve( deviceContext );
      // renderInfo.prepareRender( outTexture.width, outTexture.height, 0xf4fcfeff );
      //
      // phet.scenery.render( renderInfo, deviceContext, outTexture );

      // const GridBox = sceneryImports.GridBox;
      // const Rectangle = sceneryImports.Rectangle;
      // const Color = sceneryImports.Color;
      //
      // const colors = [
      //   new Color( 62, 171, 3 ),
      //   new Color( 23, 180, 77 ),
      //   new Color( 24, 183, 138 ),
      //   new Color( 23, 178, 194 ),
      //   new Color( 20, 163, 238 ),
      //   new Color( 71, 136, 255 ),
      //   new Color( 171, 101, 255 ),
      //   new Color( 228, 72, 235 ),
      //   new Color( 252, 66, 186 ),
      //   new Color( 252, 82, 127 )
      // ];
      //
      // const box = new GridBox( {
      //   x: 10,
      //   y: 10,
      //   preferredWidth: 100,
      //   preferredHeight: 100,
      //   children: [
      //     new Rectangle( 0, 0, 30, 15, {
      //       fill: colors[ 2 ],
      //       sizable: true,
      //       localMinimumWidth: 30,
      //       localMinimumHeight: 15,
      //       layoutOptions: { column: 1, row: 0, stretch: true, grow: 1 }
      //     } ),
      //     new Rectangle( 0, 0, 30, 30, {
      //       fill: colors[ 4 ],
      //       sizable: true,
      //       localMinimumWidth: 30,
      //       localMinimumHeight: 100,
      //       layoutOptions: { column: 0, row: 1, horizontalSpan: 2, verticalSpan: 2, stretch: true }
      //     } ),
      //     new Rectangle( 0, 0, 15, 15, {
      //       fill: colors[ 0 ],
      //       layoutOptions: { column: 0, row: 3 }
      //     } )
      //   ]
      // } );
      //
      // console.log( box.height );
      //
      // scene.addChild( box );
      //
      // display.width = 120;
      // display.height = 120;
      // display.updateDisplay();

    }, 400 );
  };

  window.ellipseTest = function() {
    display.width = 700;
    display.height = 600;

    const DISPLAY_DEGENERATE_BACKGROUND = true;
    const DEGENERATE_BACKGROUND_OPACITY = 0.5;
    const DEGENERATE_BACKGROUND_MULTIPLIER = 1;
    const BACKGROUND_COMBINED = true;
    const BACKGROUND_REAL = false;
    const BACKGROUND_IMAGINARY = false;

    const DISPLAY_SOLUTION_VECTORS = false;
    const SOLUTION_VECTOR_OPACITY = 0.5;

    const DISPLAY_SOLUTION_LINES = false;
    const SOLUTION_LINE_OPACITY = 0.5;

    const DISPLAY_INTERSECTION_POINTS = false;
    const INTERSECTION_POINT_OPACITY = 0.5;

    const DISPLAY_INTERSECTION_LINES = false;
    const INTERSECTION_LINE_OPACITY = 0.5;

    const DISPLAY_INTERSECTION_DATA = true;
    const INTERSECTION_DATA_OPACITY = 0.5;

    const DISPLAY_CONICS = true;
    const CONIC_OPACITY = 0.5;

    const CONIC_SELECTION = -1;

    // const segmentA = new phet.kite.Arc( new phet.dot.Vector2( 200, 200 ), 100, 0, Math.PI * 2, false );
    // const segmentB = new phet.kite.Arc( new phet.dot.Vector2( 300, 200 ), 100, 0, Math.PI * 2, false );
    // const segmentA = new phet.kite.Arc( new phet.dot.Vector2( 200, 200 ), 100, 0, Math.PI * 2, false );
    // const segmentB = new phet.kite.Arc( new phet.dot.Vector2( 400, 200 ), 100, 0, Math.PI * 2, false );
    // const segmentA = new phet.kite.Arc( new phet.dot.Vector2( 200, 200 ), 100, 0, Math.PI * 2, false );
    // const segmentB = new phet.kite.Arc( new phet.dot.Vector2( 405, 200 ), 100, 0, Math.PI * 2, false );

    // const segmentA = new phet.kite.Arc( new phet.dot.Vector2( 200, 200 ), 100, 0, Math.PI * 2, false );
    // const segmentB = new phet.kite.Arc( new phet.dot.Vector2( 201, 200 ), 100, 0, Math.PI * 2, false );
    //   const segmentA = new phet.kite.Arc( new phet.dot.Vector2( 200, 200 ), 100, 0, Math.PI * 2, false );
    //   const segmentB = new phet.kite.Arc( new phet.dot.Vector2( 200.1, 200 ), 100, 0, Math.PI * 2, false );
    //   const segmentA = new phet.kite.Arc( new phet.dot.Vector2( 200, 200 ), 100, 0, Math.PI * 2, false );
    //   const segmentB = new phet.kite.Arc( new phet.dot.Vector2( 200.01, 200 ), 100, 0, Math.PI * 2, false );
      const segmentA = new phet.kite.Arc( new phet.dot.Vector2( 200, 200 ), 100, 0, Math.PI * 2, false );
      const segmentB = new phet.kite.Arc( new phet.dot.Vector2( 200.005, 200 ), 100, 0, Math.PI * 2, false );
            // const segmentA = new phet.kite.Arc( new phet.dot.Vector2( 200, 200 ), 100, 0, Math.PI * 2, false );
            // const segmentB = new phet.kite.Arc( new phet.dot.Vector2( 200.001, 200 ), 100, 0, Math.PI * 2, false );

    // can't identify
    //   const segmentA = new phet.kite.Arc( new phet.dot.Vector2( 200, 200 ), 100, 0, Math.PI * 2, false );
    //   const segmentB = new phet.kite.Arc( new phet.dot.Vector2( 200.00001, 200 ), 100, 0, Math.PI * 2, false );

    // const segmentA = new phet.kite.Arc( new phet.dot.Vector2( 400, 200 ), 100, 0, Math.PI * 2, false );
    // const segmentB = new phet.kite.EllipticalArc( new phet.dot.Vector2( 400, 200 ), 200, 50, 0, 0, Math.PI * 2, false );
    // const segmentA = new phet.kite.Arc( new phet.dot.Vector2( 400, 200 ), 100, 0, Math.PI * 2, false );
    // const segmentB = new phet.kite.EllipticalArc( new phet.dot.Vector2( 400, 200 ), 200, 50, Math.PI / 6, 0, Math.PI * 2, false );
    // const segmentA = new phet.kite.Arc( new phet.dot.Vector2( 400, 200 ), 100, 0, Math.PI * 2, false );
    // const segmentB = new phet.kite.EllipticalArc( new phet.dot.Vector2( 400, 250 ), 200, 50, Math.PI / 6, 0, Math.PI * 2, false );

    // const segmentA = new phet.kite.Arc( new phet.dot.Vector2( 410, 200 ), 100, 0, Math.PI * 2, false );
    // const segmentB = new phet.kite.EllipticalArc( new phet.dot.Vector2( 400, 250 ), 200, 50, Math.PI / 6, 0, Math.PI * 2, false );
    // const segmentA = new phet.kite.Arc( new phet.dot.Vector2( 450, 200 ), 100, 0, Math.PI * 2, false );
    // const segmentB = new phet.kite.EllipticalArc( new phet.dot.Vector2( 400, 250 ), 200, 50, Math.PI / 6, 0, Math.PI * 2, false );

    const intersections = phet.kite.intersectConicMatrices( segmentA.getConicMatrix(), segmentB.getConicMatrix() )
    const points = intersections.points;

    if ( DISPLAY_INTERSECTION_POINTS ) {
      points.forEach( point => {
        scene.addChild( new phet.scenery.Circle( 2, {
          translation: point,
          fill: 'black',
          opacity: INTERSECTION_POINT_OPACITY
        } ) );
      } );
    }

    // (x,y,1)^T * M * (x,y,1) = 0
    // m00 x^2 + ( m01 + m10 ) xy + m11 y^2 + ( m02 + m20 ) x + ( m12 + m21 ) y + m22 = 0
    // x,y are real
    // Real and imaginary constraints:
    // Real:
    //   re(m00) x^2 + re(m01 + m10) xy + re(m11) y^2 + re(m02 + m20) x + re(m12 + m21) y + re(m22) = 0
    //   r00 * x^2 + ( r01 + r10 ) * xy + r11 * y^2 + ( r02 + r20 ) * x + ( r12 + r21 ) * y + r22 = 0
    // Imaginary:
    //   im(m00) x^2 + im(m01 + m10) xy + im(m11) y^2 + im(m02 + m20) x + im(m12 + m21) y + im(m22) = 0
    //   i00 * x^2 + ( i01 + i10 ) * xy + i11 * y^2 + ( i02 + i20 ) * x + ( i12 + i21 ) * y + i22 = 0
    // So effectively, it's two conics again? BUT they will be somehow degenerate?
    // Can we classify them, then convert to standard form?

    // Ax^2 + Bxy + Cy^2 + Dx + Ey + F = 0
    // degenerate factorable as (ax + by + c)(dx + ey + f) = 0, for complex a,b,c,d,e,f, resulting in:
    // (ad)x^2 + (ae + bd)xy + (be)y^2 + (af + cd)x + (bf + ce)y + (cf) = 0
    // A = ad
    // B = ae + bd
    // C = be
    // D = af + cd
    // E = bf + ce
    // F = cf

    // dp/dx = 2Ax + By + D
    // dp/dy = 2Cy + Bx + E

    // (rA + i*iA)(rx + i*ix)^2 + (rB + i*iB)(rx + i*ix)(ry + i*iy) + (rC + i*iC)(ry + i*iy)^2 + (rD + i*iD)(rx + i*ix) + (rE + i*iE)(ry + i*iy) + (rF + i*iF) = 0


    // gradient for real part:
    // dreal/drx = -2 iA ix - iB iy + rD + 2 rA rx + rB ry
    // dreal/dry = -iB ix - 2 iC iy + rE + rB rx + 2 rC ry
    // dreal/dix = -iD - 2 ix rA - iy rB - 2 iA rx - iB ry
    // dreal/diy = -iE - ix rB - 2 iy rC - iB rx - 2 iC ry

    // dimaginary/drx = iD + 2 ix rA + iy rB + 2 iA rx + iB ry
    // dimaginary/dry = iE + ix rB + 2 iy rC + iB rx + 2 iC ry
    // dimaginary/dix = -2 iA ix - iB iy + rD + 2 rA rx + rB ry
    // dimaginary/diy = -iB ix - 2 iC iy + rE + rB rx + 2 rC ry


    // if y=alpha:
    // (A)x^2 + (B*alpha + D)x + (C*alpha^2 + E*alpha + F) = 0
    // if x=alpha:
    // (C)y^2 + (B*alpha + E)y + (A*alpha^2 + D*alpha + F) = 0

    // "line" is Px + Qy + C = 0
    // (rP + i*iP)(rx + i*ix) + (rQ + i*iQ)(ry + i*iY) + (rC + i*iC) = 0
    // real part:
    // (rP * rx - iP * ix) + (rQ * ry - iQ * iy) + rC = 0
    // imaginary part:
    // (rP * ix + iP * rx) + (rQ * iy + iQ * ry) + iC = 0
    //
    //                        [ rx ]
    // [ rP  rQ  -iP  -iQ ] * [ ry ] = [ -rC ]
    // [ iP  iQ   rP   rQ ]   [ ix ]   [ -iC ]
    //                        [ iy ]
    //
    // given our two bases:
    //
    //                        [ B0rx  B1rx ]
    // [ rP  rQ  -iP  -iQ ] * [ B0ry  B1ry ] = [ 0  0 ]   e.g. construct a matrix with a specific null space
    // [ iP  iQ   rP   rQ ]   [ B0ix  B1ix ]   [ 0  0 ]
    //                        [ B0iy  B1iy ]
    //
    // [ B0rx  B0ry -B0ix -B0iy ]   [ rP ]   [ 0 ]
    // [ B1rx  B1ry -B1ix -B1iy ] * [ rQ ] = [ 0 ]
    // [ B0ix  B0iy  B0rx  B0ry ]   [ iP ]   [ 0 ]
    // [ B1ix  B1iy  B1rx  B1ry ]   [ iQ ]   [ 0 ]
    // GET nullspace (row-reduced-echelon-form, then grab one, it should be singular), pick a vector!
    // use our point x,y to get C
    // [NOTE only used for checking] convert line to y = (-P/Q)x + (-C/Q) = mx + b

    // Then (Px + Qy + C)(Sx + Ty + U) we need to factor!
    // From Ax^2 + Bxy + Cy^2 + Dx + Ey + F
    // Actually, S=A/P so SPx = (A/P)(P)x = Ax
    // Similarly, T=C/Q,
    // Similarly, U=F/C
    // This MIGHT be the approach with the best error?
    // NOPE did not work, ok let's factor

    // (Px + Qy + C)((A/P)x + (C/Q)y + (F/C))
    //

    // Long division (Px + Qy + C)
    // 0
    // Ax^2 + Bxy + Cy^2 + Dx + Ey + F

    // (A/P)x
    // ||| Ax^2 + (QA/P)y + (CA/P)
    // Bxy + Cy^2 + Dx + (E - QA/P)y + F - CA/P

    // B/Py
    // ||| Bxy + (QB/P)y^2 + (CB/P)y
    // (C - QB/P)y^2 + Dx + (E - QA/P - CB/P)y + F - CA/P

    // Example:
    // ( (2+i)x + (3-2i)y + (4-i) )( (5+2i)x + (6-3i)y + (7+i) ) = 0
    // (8+9i)x^2 + (34-4i)xy + (12-21i)y^2 + (35+12i)x + (44-29i)y + (29-3i)
    // A = (8+9i)
    // B = (34-4i)
    // C = (12-21i)
    // D = (35+12i)
    // E = (44-29i)
    // F = (29-3i)
    // if y=1.423 - 2.543i
    // then ~x -> -0.0858966 + 3.73976i, x -> 1.0218 + 5.2266i
    // {x -> -0.08589655172413689` + 3.7397586206896554` I, y -> 1.423 - 2.543 I}
    // subs: /. {rx -> -0.08589655172413689, ix ->  3.7397586206896554, ry -> 1.423, iy -> -2.543, rA -> 8, iA -> 9, rB -> 34, iB -> -4, rC -> 12, iC -> -21, rD -> 35, iD -> 12, rE -> 44, iE -> -29, rF -> 29, iF -> -3}
    // real gradient: {4.520000000000017`, -16.61544827586204`, 21.863999999999983`, 22.30262068965518`}
    // imaginary gradient: {-21.863999999999983`, -22.30262068965518`, 4.520000000000017`, -16.61544827586204`}
    // point: {-0.08589655172413689, 1.423, 3.7397586206896554, -2.543}
    // basis of plane: {-0.09672388203287421`, 0.5158607041753288`, 0.7737910562629933`, -0.35465423412053854`},
    //                 {0.773791056262993`, -0.3546542341205386`, 0.09672388203287423`, -0.5158607041753287`}
    // NOTE: cut here since we can't factor well
    // row-reduced echelon form of basis matrix: {{1, 0.`, -0.8888888888888888`, 1.074074074074074`}, {0, 1, -1.6666666666666667`, 0.8888888888888888`}, {0, 0, 0, 0}, {0, 0, 0, 0}}
    // nullspace: {{0.49216051416301365`, 0.0471141097980782`, -0.3868719687321505`, -0.7783883148956202`}, {-0.3868719687321505`, -0.77838831489562`, -0.49216051416301354`, -0.04711410979807762`}}
    // picking first as line equation:
    // (0.49216051416301365 + -0.3868719687321505i)*x + (0.0471141097980782 + -0.7783883148956202i)*y + ??? = 0
    // plug in x,y of solution to get C
    // (0.49216051416301365 + -0.3868719687321505i)*x + (0.0471141097980782 + -0.7783883148956202i)*y + 0.5078652174290392 + -0.6463347403640229i = 0
    // P = (0.49216051416301365 + -0.3868719687321505i)
    // Q = (0.0471141097980782 + -0.7783883148956202i)
    // C = (0.5078652174290392 + -0.6463347403640229i)
    // TESTING TESTING
    // convert line to y = (-P/Q)x + (-C/Q) = mx + b
    // m = -0.5333333333333333` - 0.5999999999999998` I
    // b = -0.8666666666666653` - 0.5999999999999992` I
    // test a random point, say.... (-0.5333333333333333 - 0.5999999999999998i) * (512 - 21i) + (-0.8666666666666653 - 0.5999999999999992i)
    // x=(512 - 21i), y=(-286.5333333333333 - 296.5999999999999i)
    // YES it's pretty decent (1e-10 error)
    // ---- ALSO it seems to solve ( (5+2i)x + (6-3i)y + (7+i) )
    // (Px + Qy + C)(Sx + Ty + U)
    // S = (1.1621480416859242 + 19.20024510075862i)
    // T = (27.810061574410806 + 13.733188822246595i)
    // U = (24.667301379270675 + 25.485765491038986i)


    //

    // thus we have a plane defined by the basis vectors. We want to find the intersection of this plane with the real plane
    // e.g. where ix=0, iy=0, thus P + jB0 + kB1 = (_, _, 0, 0)
    // THINK all cases of planes
    // reorthogonalize vectors so we have B0* = (_, _, 1, 0 ), B1* = (_, _, 0, 1)
    // adjust P to a location on (_, _, 0, 0)

    // https://math.stackexchange.com/questions/1768368/intersection-of-2d-planes-in-4d-space
    // can we find a single value which is real?

    // BASIS CASES:
    // P real
    // P partially complex?
    // P complex
    // full plane (all solutions) if P is real AND B0* and B1* are real
    // line
    // point






    // if we pick alpha randomly = y, then, solve roots (and repeat), we have:
    // (x00 + P)(x01 + Q) = 0
    // (x10 + R)(x11 + S) = 0
    // (A)x^2 + (B*alpha + D)x + (C*alpha^2 + E*alpha + F) = 0

    console.log( '----------' );
    console.log( `lines: ${intersections.lines.length}` );

    const drawValues = ( f, r, g, b, a ) => {
      const scale = 1;
      const canvas = document.createElement( 'canvas' );
      const context = canvas.getContext( '2d' );
      canvas.width = Math.ceil( display.width / scale );
      canvas.height = Math.ceil( display.height / scale );

      const values = new Float32Array( display.width * display.height );

      let maxValue = 0;
      for ( let x = 0; x < display.width; x += scale ) {
        const xx = phet.dot.Complex.real( x + 0.5 * scale );
        for ( let y = 0; y < display.height; y += scale ) {
          const yy = phet.dot.Complex.real( y + 0.5 * scale );

          const value = f( xx, yy );
          values[ x / scale + y / scale * canvas.width ] = value;
          maxValue = Math.max( maxValue, value );
        }
      }

      for ( let x = 0; x < display.width; x++ ) {
        for ( let y = 0; y < display.height; y++ ) {
          const value = values[ x + y * canvas.width ];

          let alpha = ( a * value / maxValue ).toFixed( 20 );
          while ( alpha.length >= 2 && alpha.endsWith( '0' ) && alpha[ alpha.length - 2 ] !== '.' ) {
            alpha = alpha.slice( 0, alpha.length - 1 );
          }
          context.fillStyle = `rgba(${r},${g},${b},${alpha})`;
          context.fillRect( x, y, 1, 1 );
        }
      }

      scene.addChild( new phet.scenery.Image( canvas, {
        scale: scale,
        opacity: DEGENERATE_BACKGROUND_OPACITY
      } ) );
    };

    // TODO: display multiplication of multiples of these!!!!
    if ( DISPLAY_DEGENERATE_BACKGROUND ) {
      intersections.degenerateConicMatrices.forEach( ( m, i ) => {
        console.log( 'matrix' );
        console.log( m );
        if ( CONIC_SELECTION >= 0 && CONIC_SELECTION !== i ) {
          return;
        }
        if ( BACKGROUND_COMBINED ) {
          drawValues( ( x, y ) => {
            const value = m[ 8 ].plus( m[ 2 ].times( x ) ).plus( m[ 5 ].times( y ) ).plus( x.times( m[ 6 ].plus( m[ 0 ].times( x ) ).plus( m[ 3 ].times( y ) ) ) ).plus( y.times( m[ 7 ].plus( m[ 1 ].times( x ) ).plus( m[ 4 ].times( y ) ) ) );

            return ( 1 / Math.cbrt( value.magnitude ) );
          }, i === 0 ? 255 : 0, i === 1 ? 255 : 0, i === 2 ? 255 : 0, DEGENERATE_BACKGROUND_MULTIPLIER );
        }
        if ( BACKGROUND_REAL ) {
          drawValues( ( x, y ) => {
            const r00 = m[ 0 ].real;
            const r01 = m[ 1 ].real;
            const r02 = m[ 2 ].real;
            const r10 = m[ 3 ].real;
            const r11 = m[ 4 ].real;
            const r12 = m[ 5 ].real;
            const r20 = m[ 6 ].real;
            const r21 = m[ 7 ].real;
            const r22 = m[ 8 ].real;
            x = x.real;
            y = y.real;

            const value = r00 * x * x + ( r01 + r10 ) * x * y + r11 * y * y + ( r02 + r20 ) * x + ( r12 + r21 ) * y + r22;

            return ( 1 / Math.cbrt( Math.abs( value ) ) );
          }, i === 0 ? 255 : 0, i === 1 ? 255 : 0, i === 2 ? 255 : 0, DEGENERATE_BACKGROUND_MULTIPLIER );
        }
        if ( BACKGROUND_IMAGINARY ) {
          drawValues( ( x, y ) => {
            const i00 = m[ 0 ].imaginary;
            const i01 = m[ 1 ].imaginary;
            const i02 = m[ 2 ].imaginary;
            const i10 = m[ 3 ].imaginary;
            const i11 = m[ 4 ].imaginary;
            const i12 = m[ 5 ].imaginary;
            const i20 = m[ 6 ].imaginary;
            const i21 = m[ 7 ].imaginary;
            const i22 = m[ 8 ].imaginary;
            x = x.real;
            y = y.real;

            const value = i00 * x * x + ( i01 + i10 ) * x * y + i11 * y * y + ( i02 + i20 ) * x + ( i12 + i21 ) * y + i22;

            return ( 1 / Math.cbrt( Math.abs( value ) ) );
          }, i === 0 ? 255 : 0, i === 1 ? 255 : 0, i === 2 ? 255 : 0, DEGENERATE_BACKGROUND_MULTIPLIER );
        }
      } );
    }

    console.log( 'intersections' );
    console.log( intersections.intersectionCollections );
    if ( DISPLAY_INTERSECTION_DATA ) {
      intersections.intersectionCollections.forEach( ( intersectionCollection, i ) => {
        const color = [
          'rgb(255,0,0)',
          'rgb(0,255,0)',
          'rgb(0,0,255)',
        ][ i ];

        intersectionCollection.forEach( vectorOrRay => {
          if ( vectorOrRay instanceof phet.dot.Vector2 ) {
            scene.addChild( new phet.scenery.Circle( 2, {
              translation: vectorOrRay,
              fill: color,
              opacity: INTERSECTION_DATA_OPACITY
            } ) );
          }
          else if ( vectorOrRay instanceof phet.dot.Ray2 ) {
            scene.addChild( new phet.scenery.Line( vectorOrRay.pointAtDistance( -1e6 ), vectorOrRay.pointAtDistance( 1e6 ), {
              stroke: color,
              lineWidth: 0.5,
              opacity: INTERSECTION_DATA_OPACITY
            } ) );
          }
        } );
      } );
    }

    intersections.lines.forEach( ( line, i ) => {
      // ax + by + c = 0
      const a = line[ 0 ];
      const b = line[ 1 ];
      const c = line[ 2 ];

      console.log( `line: ${a} ${b} ${c}` );

      // re(a) * x + re(b) * y + re(c) = 0
      // im(a) * x + im(b) * y + im(c) = 0
      // M * [ x, y ] = -c

      let solutionVector = null; // Vector2
      let solutionLine = null; // Ray2
      // const M = new phet.dot.Matrix( 2, 2, [ a.real, a.imaginary, b.real, b.imaginary ] );
      const M = new phet.dot.Matrix( 2, 2, [ a.real, b.real, a.imaginary, b.imaginary ] );
      const lu = new phet.dot.LUDecomposition( M );
      if ( lu.isNonsingular() ) {
        const solved = lu.solve( new phet.dot.Matrix( 2, 1, [ -c.real, -c.imaginary ] ) );
        solutionVector = new phet.dot.Vector2( solved.getArray()[ 0 ], solved.getArray()[ 1 ] );
        console.log( 'solutionVector', solutionVector );
      }
      else {
        const aZero = Math.abs( a.real ) < 1e-10;
        const bZero = Math.abs( b.real ) < 1e-10;
        if ( !aZero && !bZero ) {
          if ( aZero ) {
            const y = -c.real / b.real;
            solutionLine = new phet.dot.Ray2( new phet.dot.Vector2( 0, y ), new phet.dot.Vector2( 1, 0 ) );
          }
          else if ( bZero ) {
            const x = -c.real / a.real;
            solutionLine = new phet.dot.Ray2( new phet.dot.Vector2( x, 0 ), new phet.dot.Vector2( 0, 1 ) );
          }
          else {
            // solve for y=0 and y=1

            // a.real * x + c.real = 0
            const x0 = -c.real / a.real;

            // a.real * x + b.real * 1 + c.real = 0
            const x1 = -( c.real + b.real ) / a.real;

            const position = new phet.dot.Vector2( x0, 0 );
            const secondPosition = new phet.dot.Vector2( x1, 1 );

            solutionLine = new phet.dot.Ray2( position, secondPosition.minus( position ).normalized() );
          }
          console.log( 'solutionLine', solutionLine );
        }
      }


      const color = [
        new phet.scenery.Color( 255, 0, 0, 0.5 ),
        new phet.scenery.Color( 128, 128, 0, 0.5 ),
        new phet.scenery.Color( 0, 255, 0, 0.5 ),
        new phet.scenery.Color( 0, 128, 128, 0.5 ),
        new phet.scenery.Color( 0, 0, 255, 0.5 ),
        new phet.scenery.Color( 128, 0, 128, 0.5 )
      ][ i ];

      if ( DISPLAY_SOLUTION_VECTORS && solutionVector ) {
        scene.addChild( new phet.scenery.Circle( 7 + i * 2, {
          translation: solutionVector,
          stroke: color,
          lineWidth: 0.5,
          opacity: SOLUTION_VECTOR_OPACITY
        } ) );
      }
      if ( DISPLAY_SOLUTION_LINES && solutionLine ) {
        scene.addChild( new phet.scenery.Line( solutionLine.pointAtDistance( -1e6 ), solutionLine.pointAtDistance( 1e6 ), {
          stroke: color,
          lineWidth: 5,
          opacity: SOLUTION_LINE_OPACITY
        } ) );
      }

      if ( DISPLAY_INTERSECTION_LINES && ( a.magnitude > 1e-10 || b.magnitude > 1e-10 ) ) {
        let leftY = null;
        let topX = null;
        let rightY = null;
        let bottomX = null;
        let xm = null;
        let xd = null;
        let ym = null;
        let yd = null;

        if ( b.magnitude > 1e-10 ) {
          // slope intercept form: y = -a/b * x - c/b = mx + d
          ym = a.negated().dividedBy( b );
          yd = c.negated().dividedBy( b );

          // Just consider the real x,y values:
          // re( y ) = re( mx + d ) = re( m ) * re( x ) - im( m ) * im( x ) + re( d ) = 0
          // with im( x ) = 0:
          // re( y ) = re( m ) * re( x ) + re( d ) = 0

          leftY = yd.real;
          rightY = ym.real * display.width + yd.real;

          scene.addChild( new phet.scenery.Line( 0, leftY, display.width, rightY, {
            stroke: color,
            lineWidth: 0.5,
            opacity: INTERSECTION_LINE_OPACITY
          } ) );
        }
        if ( a.magnitude > 1e-10 ) {
          // slope intercept form: x = -b/a * y - c/a = my + d
          xm = b.negated().dividedBy( a );
          xd = c.negated().dividedBy( a );

          // Just consider the real x,y values:
          // re( x ) = re( my + d ) = re( m ) * re( y ) - im( m ) * im( y ) + re( d ) = 0
          // with im( y ) = 0:
          // re( x ) = re( m ) * re( y ) + re( d ) = 0

          topX = xd.real;
          bottomX = xm.real * display.height + xd.real;

          scene.addChild( new phet.scenery.Line( topX, 0, bottomX, display.height, {
            stroke: color,
            lineWidth: 0.5,
            opacity: INTERSECTION_LINE_OPACITY
          } ) );
        }
      }
    } );

    if ( DISPLAY_CONICS ) {
      const pathA = new phet.scenery.Path( segmentA.toShape(), {
        stroke: 'rgb(0,200,200)',
        lineWidth: 0.5,
        opacity: CONIC_OPACITY
      } );
      scene.addChild( pathA );

      const pathB = new phet.scenery.Path( segmentB.toShape(), {
        stroke: 'rgb(255,0,255)',
        lineWidth: 0.5,
        opacity: CONIC_OPACITY
      } );
      scene.addChild( pathB );
    }

    display.updateDisplay();
  };
  // setTimeout( ellipseTest, 50 );

  window.rectTest = function() {
    setTimeout( async function() {
      const rect = new phet.scenery.Rectangle( 0, 0, 50, 50, {
        fill: 'blue',
        children: [
          new phet.scenery.Rectangle( 0, -7.5, 200, 15, {
            fill: 'red',
            rotation: Math.PI / 4
          } ),
          new phet.scenery.Rectangle( 0, -7.5, 200, 15, {
            fill: 'white',
            rotation: -Math.PI / 4,
            y: 50
          } )
        ]
      } );
      let url;
      rect.toCanvas( canvas => {
        url = canvas.toDataURL();
      }, 0, 0, 50, 50 );

      console.log( url );
      const img = document.createElement( 'img' );
      img.addEventListener( 'load', () => {
        const pattern = new phet.scenery.Pattern( img );
        const gradient = new phet.scenery.LinearGradient( 0, 0, 400, 400 ).addColorStop( 0, 'red' ).addColorStop( 1, 'blue' );

        pattern.setTransformMatrix( phet.dot.Matrix3.translation( 0, 0 ).timesMatrix( phet.dot.Matrix3.scaling( 0.5 ) ) );
        gradient.setTransformMatrix( phet.dot.Matrix3.translation( 0, 0 ).timesMatrix( phet.dot.Matrix3.scaling( 0.5 ) ) );

        window.r = new phet.scenery.Rectangle( 0, 0, 25, 25, {
          fill: pattern,
          renderer: 'vello',
          x: 200.1,
          y: 200.9
        } );
        scene.addChild( r );

        display.width = 512;
        display.height = 800;
        display.updateDisplay();
      } );
      img.src = url;
    }, 400 );
  };

  window.displayErr = function() {
    setTimeout( function() {
      var node0 = new phet.scenery.Node();
      var node4 = new phet.scenery.Node();
      var path1 = new phet.scenery.Path();
      var path3 = new phet.scenery.Path();

      path1.insertChild( 0, node4 );
      node4.insertChild( 0, path3 );
      scene.insertChild( 0, node0 );
      node0.insertChild( 0, path1 );
      scene.transform.append( phet.dot.Matrix3.scaling( 1.5586118499044517 ) );
      node0.renderer = "canvas";
      display.updateDisplay();
    } );
  };

  window.inputTest = function() {
    display.initializeEvents();
    toggleUpdates();

    var circle = new phet.scenery.Circle( 30, { fill: 'red', cursor: 'pointer' } );
    scene.addChild( circle );
    circle.addInputListener( new phet.scenery.DragListener( {
      translateNode: true,
      press: function() { console.log( 'press' ); },
      release: function() { console.log( 'release' ); },
      drag: function() { console.log( 'drag' ); }
    } ) );

    var square = new phet.scenery.Rectangle( 0, 0, 60, 60, { fill: 'blue', cursor: 'pointer', x: -30, y: 90 } );
    scene.addChild( square );
    square.addInputListener( new phet.scenery.SimpleDragHandler( {
      start: function() { console.log( 'start' ); },
      end: function() { console.log( 'end' ); },
      drag: function() { console.log( 'drag' ); }
    } ) );
  };

  window.cssTest = function() {
    window.assertSlow = window.assert;
    setTimeout( function() {
      window.back = new phet.scenery.Rectangle( 0, 0, 100, 100, 0, 0, {
        fill: '#000'
      } );
      window.rect = new phet.scenery.Rectangle( 0, 0, 100, 50, 0, 0, {
        y: 50,
        fill: new phet.scenery.LinearGradient( 0, 0, 100, 0 ).addColorStop( 0, 'red' ).addColorStop( 1, 'blue' )
      } );
      window.a = new phet.scenery.Node( {} );
      window.b = new phet.scenery.Node( { y: 100 } );
      b._cssTransform = true;
      a.addChild( back );
      a.addChild( rect );
      b.addChild( back );
      b.addChild( rect );
      scene.addChild( a );
      scene.addChild( b );

      display.updateDisplay();

      scene.renderer = 'canvas';

      display.updateDisplay();
    } );
  };

  window.transformTest = function() {
    window.n = new phet.scenery.Node();
    n.addChild( new phet.scenery.Rectangle( 0, 50, 100, 50, { fill: '#aaa' } ) );
    n.addChild( new phet.scenery.Rectangle( 50, 0, 50, 50, { fill: '#aaf' } ) );
    scene.addChild( n );
    n.x = 50;
    n.y = 50;
    n.rotation = Math.PI / 4;
    n.left = 50;
    scene.addChild( phet.scenery.Rectangle.bounds( n.bounds, { stroke: 'red' } ) );
    n.transformBounds = true;
    scene.addChild( phet.scenery.Rectangle.bounds( n.bounds, { stroke: 'blue' } ) );

    display.updateDisplay();
  };

  /*---------------------------------------------------------------------------*
   * Debug
   *----------------------------------------------------------------------------*/

  var playgroundDebugging = false;
  var playgroundDebuggingRequestID = 0;

  var debug = document.createElement( 'div' );
  debug.id = 'debug';
  debug.style.display = 'none';
  document.body.appendChild( debug );

  function debugStep() {
    playgroundDebuggingRequestID = window.requestAnimationFrame( debugStep, debug );

    debug.style.display = '';
    debug.innerHTML = display.getDebugHTML();
  }

  window.toggleDebug = function() {
    if ( playgroundDebugging ) {
      window.cancelAnimationFrame( playgroundDebuggingRequestID );
      debug.style.display = 'none';
    }
    else {
      debugStep();
    }

    playgroundDebugging = !playgroundDebugging;
  };

  /*---------------------------------------------------------------------------*
   * A11y Debug
   *----------------------------------------------------------------------------*/

  var a11yDebugging = false;
  var a11yDebuggingRequestID = 0;

  var a11yDebug = document.createElement( 'div' );
  a11yDebug.id = 'a11yDebug';
  a11yDebug.style.display = 'none';
  document.body.appendChild( a11yDebug );

  function a11yDebugStep() {
    a11yDebuggingRequestID = window.requestAnimationFrame( a11yDebugStep, a11yDebug );

    a11yDebug.style.display = '';
    a11yDebug.innerHTML = display.getPDOMDebugHTML();
  }

  /**
   * @param {boolean} withSceneryLog
   */
  window.toggleA11yDebug = function( withSceneryLog ) {
    if ( a11yDebugging ) {
      if ( window.location.search.indexOf( 'a11yLog' ) >= 0 || withSceneryLog ) {
        phet.scenery.disableLogging();
      }

      window.cancelAnimationFrame( a11yDebuggingRequestID );
      a11yDebug.style.display = 'none';
    }
    else {
      if ( window.location.search.indexOf( 'a11yLog' ) >= 0 || withSceneryLog ) {
        phet.scenery.enableLogging( [ 'a11y' ] );
      }

      a11yDebugStep();
    }

    a11yDebugging = !a11yDebugging;
  };

  /*---------------------------------------------------------------------------*
   * Updates
   *----------------------------------------------------------------------------*/

  var playgroundUpdating = false;

  window.toggleUpdates = function() {
    if ( playgroundUpdating ) {
      display.cancelUpdateOnRequestAnimationFrame();
    }
    else {
      display.updateOnRequestAnimationFrame();
    }

    playgroundUpdating = !playgroundUpdating;
  };

  /*---------------------------------------------------------------------------*
   * Logging
   *----------------------------------------------------------------------------*/

  var logging = false;

  window.toggleLogging = function() {
    if ( logging ) {
      phet.scenery.disableLogging();
    }
    else {
      phet.scenery.enableLogging( [
        'ParallelDOM'
      ] );
    }

    logging = !logging;
  };


  window.snapshot = async () => {
    const sceneryImports = await import( '../../chipper/dist/js/scenery/js/imports.js' );
    const Bounds2 = await import( '../../chipper/dist/js/dot/js/Bounds2.js' );
    const Vector2 = await import( '../../chipper/dist/js/dot/js/Vector2.js' );

    const PDOMFuzzer = sceneryImports.PDOMFuzzer;
    const PDOMInstance = sceneryImports.PDOMInstance;
    const PDOMPeer = sceneryImports.PDOMPeer;
    const PDOMTree = sceneryImports.PDOMTree;
    const PDOMUtils = sceneryImports.PDOMUtils;
    const Voicing = sceneryImports.Voicing;
    const voicingManager = sceneryImports.voicingManager;
    const Cursor = sceneryImports.Cursor;
    const Reader = sceneryImports.Reader;
    const DebugContext = sceneryImports.DebugContext;
    const BackboneDrawable = sceneryImports.BackboneDrawable;
    const Block = sceneryImports.Block;
    const CanvasBlock = sceneryImports.CanvasBlock;
    const CanvasSelfDrawable = sceneryImports.CanvasSelfDrawable;
    const ChangeInterval = sceneryImports.ChangeInterval;
    const DOMBlock = sceneryImports.DOMBlock;
    const DOMSelfDrawable = sceneryImports.DOMSelfDrawable;
    const Display = sceneryImports.Display;
    const Drawable = sceneryImports.Drawable;
    const Fittability = sceneryImports.Fittability;
    const FittedBlock = sceneryImports.FittedBlock;
    const GreedyStitcher = sceneryImports.GreedyStitcher;
    const InlineCanvasCacheDrawable = sceneryImports.InlineCanvasCacheDrawable;
    const Instance = sceneryImports.Instance;
    const PaintObserver = sceneryImports.PaintObserver;
    const PaintSVGState = sceneryImports.PaintSVGState;
    const RebuildStitcher = sceneryImports.RebuildStitcher;
    const RelativeTransform = sceneryImports.RelativeTransform;
    const Renderer = sceneryImports.Renderer;
    const SVGBlock = sceneryImports.SVGBlock;
    const SVGGroup = sceneryImports.SVGGroup;
    const SVGSelfDrawable = sceneryImports.SVGSelfDrawable;
    const SelfDrawable = sceneryImports.SelfDrawable;
    const SharedCanvasCacheDrawable = sceneryImports.SharedCanvasCacheDrawable;
    const Stitcher = sceneryImports.Stitcher;
    const WebGLBlock = sceneryImports.WebGLBlock;
    const WebGLSelfDrawable = sceneryImports.WebGLSelfDrawable;
    const CanvasNodeDrawable = sceneryImports.CanvasNodeDrawable;
    const CircleCanvasDrawable = sceneryImports.CircleCanvasDrawable;
    const CircleDOMDrawable = sceneryImports.CircleDOMDrawable;
    const CircleSVGDrawable = sceneryImports.CircleSVGDrawable;
    const CircleStatefulDrawable = sceneryImports.CircleStatefulDrawable;
    const DOMDrawable = sceneryImports.DOMDrawable;
    const ImageCanvasDrawable = sceneryImports.ImageCanvasDrawable;
    const ImageDOMDrawable = sceneryImports.ImageDOMDrawable;
    const ImageSVGDrawable = sceneryImports.ImageSVGDrawable;
    const ImageStatefulDrawable = sceneryImports.ImageStatefulDrawable;
    const ImageWebGLDrawable = sceneryImports.ImageWebGLDrawable;
    const LineCanvasDrawable = sceneryImports.LineCanvasDrawable;
    const LineSVGDrawable = sceneryImports.LineSVGDrawable;
    const LineStatefulDrawable = sceneryImports.LineStatefulDrawable;
    const LineStatelessDrawable = sceneryImports.LineStatelessDrawable;
    const PaintableStatefulDrawable = sceneryImports.PaintableStatefulDrawable;
    const PaintableStatelessDrawable = sceneryImports.PaintableStatelessDrawable;
    const PathCanvasDrawable = sceneryImports.PathCanvasDrawable;
    const PathSVGDrawable = sceneryImports.PathSVGDrawable;
    const PathStatefulDrawable = sceneryImports.PathStatefulDrawable;
    const RectangleCanvasDrawable = sceneryImports.RectangleCanvasDrawable;
    const RectangleDOMDrawable = sceneryImports.RectangleDOMDrawable;
    const RectangleSVGDrawable = sceneryImports.RectangleSVGDrawable;
    const RectangleStatefulDrawable = sceneryImports.RectangleStatefulDrawable;
    const RectangleWebGLDrawable = sceneryImports.RectangleWebGLDrawable;
    const SpritesCanvasDrawable = sceneryImports.SpritesCanvasDrawable;
    const SpritesWebGLDrawable = sceneryImports.SpritesWebGLDrawable;
    const TextCanvasDrawable = sceneryImports.TextCanvasDrawable;
    const TextDOMDrawable = sceneryImports.TextDOMDrawable;
    const TextSVGDrawable = sceneryImports.TextSVGDrawable;
    const TextStatefulDrawable = sceneryImports.TextStatefulDrawable;
    const WebGLNodeDrawable = sceneryImports.WebGLNodeDrawable;
    const BatchedDOMEvent = sceneryImports.BatchedDOMEvent;
    const BrowserEvents = sceneryImports.BrowserEvents;
    const ButtonListener = sceneryImports.ButtonListener;
    const DownUpListener = sceneryImports.DownUpListener;
    const Input = sceneryImports.Input;
    const Mouse = sceneryImports.Mouse;
    const Pen = sceneryImports.Pen;
    const Pointer = sceneryImports.Pointer;
    const SceneryEvent = sceneryImports.SceneryEvent;
    const SimpleDragHandler = sceneryImports.SimpleDragHandler;
    const Touch = sceneryImports.Touch;
    const AlignBox = sceneryImports.AlignBox;
    const AlignGroup = sceneryImports.AlignGroup;
    const AlignPropertyBox = sceneryImports.AlignPropertyBox;
    const Separator = sceneryImports.Divider;
    const FlowBox = sceneryImports.FlowBox;
    const FlowCell = sceneryImports.FlowCell;
    const FlowConfigurable = sceneryImports.FlowConfigurable;
    const FlowConstraint = sceneryImports.FlowConstraint;
    const FlowLine = sceneryImports.FlowLine;
    const GridBackgroundNode = sceneryImports.GridBackgroundNode;
    const GridBox = sceneryImports.GridBox;
    const GridCell = sceneryImports.GridCell;
    const GridConfigurable = sceneryImports.GridConfigurable;
    const GridConstraint = sceneryImports.GridConstraint;
    const GridLine = sceneryImports.GridLine;
    const HBox = sceneryImports.HBox;
    const VSeparator = sceneryImports.VSeparator;
    const HeightSizable = sceneryImports.HeightSizable;
    const LayoutAlign = sceneryImports.LayoutAlign;
    const LayoutCell = sceneryImports.LayoutCell;
    const LayoutConstraint = sceneryImports.LayoutConstraint;
    const LayoutJustification = sceneryImports.LayoutJustification;
    const LayoutNode = sceneryImports.LayoutNode;
    const LayoutOrientation = sceneryImports.LayoutOrientation;
    const LayoutProxy = sceneryImports.LayoutProxy;
    const LayoutProxyProperty = sceneryImports.LayoutProxyProperty;
    const ManualConstraint = sceneryImports.ManualConstraint;
    const MarginLayoutCell = sceneryImports.MarginLayoutCell;
    const NodeLayoutConstraint = sceneryImports.NodeLayoutConstraint;
    const VBox = sceneryImports.VBox;
    const HSeparator = sceneryImports.HSeparator;
    const WidthSizable = sceneryImports.WidthSizable;
    const DragListener = sceneryImports.DragListener;
    const FireListener = sceneryImports.FireListener;
    const HandleDownListener = sceneryImports.HandleDownListener;
    const KeyboardDragListener = sceneryImports.KeyboardDragListener;
    const MultiListener = sceneryImports.MultiListener;
    const PanZoomListener = sceneryImports.PanZoomListener;
    const PressListener = sceneryImports.PressListener;
    const CanvasNode = sceneryImports.CanvasNode;
    const Circle = sceneryImports.Circle;
    const DOM = sceneryImports.DOM;
    const HStrut = sceneryImports.HStrut;
    const Image = sceneryImports.Image;
    const Leaf = sceneryImports.Leaf;
    const Line = sceneryImports.Line;
    const Node = sceneryImports.Node;
    const Paintable = sceneryImports.Paintable;
    const Path = sceneryImports.Path;
    const Plane = sceneryImports.Plane;
    const Rectangle = sceneryImports.Rectangle;
    const RichText = sceneryImports.RichText;
    const Spacer = sceneryImports.Spacer;
    const Sprites = sceneryImports.Sprites;
    const Text = sceneryImports.Text;
    const VStrut = sceneryImports.VStrut;
    const WebGLNode = sceneryImports.WebGLNode;
    const CanvasNodeBoundsOverlay = sceneryImports.CanvasNodeBoundsOverlay;
    const FittedBlockBoundsOverlay = sceneryImports.FittedBlockBoundsOverlay;
    const HighlightOverlay = sceneryImports.HighlightOverlay;
    const PointerAreaOverlay = sceneryImports.PointerAreaOverlay;
    const PointerOverlay = sceneryImports.PointerOverlay;
    const scenery = sceneryImports.scenery;
    const Brightness = sceneryImports.Brightness;
    const CanvasContextWrapper = sceneryImports.CanvasContextWrapper;
    const Color = sceneryImports.Color;
    const ColorDef = sceneryImports.ColorDef;
    const Contrast = sceneryImports.Contrast;
    const CountMap = sceneryImports.CountMap;
    const DisplayedProperty = sceneryImports.DisplayedProperty;
    const DropShadow = sceneryImports.DropShadow;
    const Features = sceneryImports.Features;
    const Filter = sceneryImports.Filter;
    const Font = sceneryImports.Font;
    const FullScreen = sceneryImports.FullScreen;
    const GaussianBlur = sceneryImports.GaussianBlur;
    const Gradient = sceneryImports.Gradient;
    const Grayscale = sceneryImports.Grayscale;
    const HueRotate = sceneryImports.HueRotate;
    const Invert = sceneryImports.Invert;
    const LinearGradient = sceneryImports.LinearGradient;
    const Opacity = sceneryImports.Opacity;
    const Paint = sceneryImports.Paint;
    const PaintColorProperty = sceneryImports.PaintColorProperty;
    const PaintDef = sceneryImports.PaintDef;
    const Pattern = sceneryImports.Pattern;
    const Picker = sceneryImports.Picker;
    const RadialGradient = sceneryImports.RadialGradient;
    const RendererSummary = sceneryImports.RendererSummary;
    const Saturate = sceneryImports.Saturate;
    const SceneImage = sceneryImports.SceneImage;
    const sceneryCopy = sceneryImports.sceneryCopy;
    const sceneryDeserialize = sceneryImports.sceneryDeserialize;
    const scenerySerialize = sceneryImports.scenerySerialize;
    const SceneryStyle = sceneryImports.SceneryStyle;
    const Sepia = sceneryImports.Sepia;
    const ShaderProgram = sceneryImports.ShaderProgram;
    const Sprite = sceneryImports.Sprite;
    const SpriteImage = sceneryImports.SpriteImage;
    const SpriteInstance = sceneryImports.SpriteInstance;
    const SpriteSheet = sceneryImports.SpriteSheet;
    const TextBounds = sceneryImports.TextBounds;
    const Trail = sceneryImports.Trail;
    const TrailPointer = sceneryImports.TrailPointer;
    const TrailsBetweenProperty = sceneryImports.TrailsBetweenProperty;
    const TransformTracker = sceneryImports.TransformTracker;
    const Utils = sceneryImports.Utils;

    const colors = [
      new Color( 62, 171, 3 ),
      new Color( 23, 180, 77 ),
      new Color( 24, 183, 138 ),
      new Color( 23, 178, 194 ),
      new Color( 20, 163, 238 ),
      new Color( 71, 136, 255 ),
      new Color( 171, 101, 255 ),
      new Color( 228, 72, 235 ),
      new Color( 252, 66, 186 ),
      new Color( 252, 82, 127 )
    ];

    /*
  multipleRendererTest( 'Simple Rectangle',
    ( scene, display ) => {
      display.width = 40;
      display.height = 40;
      scene.addChild( new Rectangle( 6, 6, 28, 28, {
        fill: '#000000'
      } ) );
      display.updateDisplay();
    }, 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAAcElEQVRYR+3YwQoAIQhFUfv/j572NQRiQTOc1ipyn0+kFpe/dnl/ocGqQgieJPhUiyfzX9VcSazBgTCCyZGbwhFEcCRgzVgzVVcgiGDE8uS3ZpiESZgkNwMO1hyvORpBBD938lcl25Lv+62KEcHfE+wTtBwp2K8YwAAAAABJRU5ErkJggg==',
    DEFAULT_THRESHOLD, testedRenderers
  );
     */

    // scene.addChild( new GridBox( {
    //   xSpacing: [ 0, 5, 10, 5, 0 ],
    //   ySpacing: [ 5, 0, 10, 0, 5 ],
    //   rows: _.range( 0, 6 ).map( i => _.range( 0, 6 ).map( j => {
    //     return new Rectangle( 0, 0, 20, 20, { fill: colors[ ( i + j ) % 10 ], visible: i % 2 === 0 && j % 2 === 0 } );
    //   } ) ),
    //   x: 10,
    //   y: 10
    // } ) );
    //
    // display.width = 160;
    // display.height = 160;
    // display.updateDisplay();

    scene.addChild( new GridBox( {
      x: 10,
      y: 10,
      preferredWidth: 100,
      preferredHeight: 100,
      children: [
        new Rectangle( 0, 0, 15, 15, {
          fill: colors[ 0 ],
          layoutOptions: { column: 0, row: 0 }
        } ),
        new Rectangle( 0, 0, 30, 15, {
          fill: colors[ 2 ],
          sizable: true,
          localMinimumWidth: 30,
          localMinimumHeight: 15,
          layoutOptions: { column: 1, row: 0, horizontalSpan: 2, stretch: true, grow: 1 }
        } ),
        new Rectangle( 0, 0, 30, 30, {
          fill: colors[ 4 ],
          sizable: true,
          localMinimumWidth: 30,
          localMinimumHeight: 30,
          layoutOptions: { column: 0, row: 1, horizontalSpan: 2, verticalSpan: 2, stretch: true }
        } ),
        new Rectangle( 0, 0, 15, 15, {
          fill: colors[ 6 ],
          layoutOptions: { column: 2, row: 1 }
        } ),
        new Rectangle( 0, 0, 15, 15, {
          fill: colors[ 8 ],
          layoutOptions: { column: 2, row: 2 }
        } ),
        new Rectangle( 0, 0, 15, 15, {
          fill: colors[ 0 ],
          layoutOptions: { column: 0, row: 3 }
        } ),
        new Rectangle( 0, 0, 15, 15, {
          fill: colors[ 1 ],
          layoutOptions: { column: 1, row: 3 }
        } ),
        new Rectangle( 0, 0, 15, 15, {
          fill: colors[ 2 ],
          layoutOptions: { column: 2, row: 3 }
        } )
      ]
    } ) );

    // Well, eeek
    debugger;

    display.width = 120;
    display.height = 120;
    display.updateDisplay();






    display.foreignObjectRasterization( url => {
      console.log( url );
      // navigator.clipboard?.writeText( url );
    } );
  };

</script>
</body>
</html>
