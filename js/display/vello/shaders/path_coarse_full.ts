/* eslint-disable */
import bump from './shared/bump.js';
import cubic from './shared/cubic.js';
import segment from './shared/segment.js';
import tile from './shared/tile.js';
import pathtag from './shared/pathtag.js';
import config from './shared/config.js';
import pre from './shared/pre.js';

export default `${pre}${config}
${pathtag}
${tile}
${segment}
${cubic}
${bump}
@group(0)@binding(0)var<uniform>n:aR;@group(0)@binding(1)var<storage>u:aX;@group(0)@binding(2)var<storage>b6:array<ak>;@group(0)@binding(3)var<storage>eI:array<fu>;@group(0)@binding(4)var<storage>bN:array<cJ>;struct eZ{O:c9,aj:bT}@group(0)@binding(5)var<storage,read_write>ao:eE;@group(0)@binding(6)var<storage,read_write>X:array<eZ>;@group(0)@binding(7)var<storage,read_write>aj:array<dI>;struct cB{ah:h,af:h,by:h}const bz=.67;fn cA(x:h)->h{return x*inverseSqrt(sqrt(d-bz+(bz*bz*bz*bz+.25*x*x)));}const cy=.39;fn cz(x:h)->h{return x*sqrt(d-cy+(cy*cy+.5*x*x));}fn eY(s:B,v:B,H:B,db:h)->cB{let dr=v-s;let dq=H-v;let E=dr-dq;let cross=(H.x-s.x)*E.y-(H.y-s.y)*E.x;let dp=select(d/cross,1.e9,abs(cross)<1.e-9);let J=dot(dr,E)*dp;let cx=dot(dq,E)*dp;let bf=abs(cross/(length(E)*(cx-J)));let af=cA(J);let by=cA(cx);var ah=c;if bf<1e9{let eV=abs(by-af);let dn=sqrt(bf);if sign(J)==sign(cx){ah=dn;}else{let cE=db/dn;ah=db/cA(cE);}ah*=eV;}return cB(ah,af,by);}fn eX(s:B,v:B,H:B,A:h)->B{let aA=d-A;return s*(aA*aA)+(v*(aA*2.)+H*A)*A;}fn bZ(s:B,v:B,H:B,R:B,A:h)->B{let aA=d-A;return s*(aA*aA*aA)+(v*(aA*aA*3.)+(H*(aA*3.)+R*A)*A)*A;}fn eW()->j{var a7=atomicAdd(&ao.aj,f)+f;if a7+f>n.iB{a7=e;atomicOr(&ao.aq,hd);}return a7;}const dm=16u;@compute @workgroup_size(256)fn main(@builtin(global_invocation_id)N:M){if(atomicLoad(&ao.aq)&(eD|fy))!=e{return;}let p=N.x;let K=u[n.dO+(p>>2u)];let b8=(p&3u)*8u;var b7=(K>>b8)&255u;if(b7&fs)!=e{let bn=eI[N.x];let W=bN[bn.ac];let fM=(bn.aE&iz)!=e;let l=vec4i(W.l);let s=bn.s;let v=bn.v;let H=bn.H;let R=bn.R;let dl=3.*(H-v)+s-R;let eU=dot(dl,dl);let dk=.25;let cw=dk*.1;let dj=(dk-cw);let eT=432.*cw*cw;var bx=max(j(ceil(pow(eU*(d/eT),d/6.))),f);bx=min(bx,dm);var da:array<cB,dm>;var ah=c;var aZ=s;let step=d/h(bx);for(var i=e;i<bx;i+=f){let A=h(i+f)*step;let a_=bZ(s,v,H,R,A);var aY=bZ(s,v,H,R,A- .5*step);aY=2.*aY- .5*(aZ+a_);let az=eY(aZ,aY,a_,sqrt(dj));da[i]=az;ah+=az.ah;aZ=a_;}let bI=max(j(ceil(ah*(.5/sqrt(dj)))),f);var ae=s;aZ=s;let di=ah/h(bI);var bX=f;var ct=c;for(var i=e;i<bx;i+=f){let A=h(i+f)*step;let a_=bZ(s,v,H,R,A);var aY=bZ(s,v,H,R,A- .5*step);aY=2.*aY- .5*(aZ+a_);let az=da[i];let dh=cz(az.af);let eS=cz(az.by);let eR=d/(eS-dh);var cs=h(bX)*di;while bX==bI||cs<ct+az.ah{var ay:B;if bX==bI{ay=R;}else{let eQ=(cs-ct)/az.ah;let a=mix(az.af,az.by,eQ);let eP=cz(a);let A=(eP-dh)*eR;ay=eX(aZ,aY,a_,A);}let bY=min(ae,ay)-bn.a3;let dg=max(ae,ay)+bn.a3;let aI=ay-ae;let eO=d/aI.x;let cv=select(aI.x/aI.y,1.e9,abs(aI.y)<1.e-9);let aC=d/h(cQ);let bt=d/h(bv);let t=(bn.a3.x+abs(cv)*(.5*h(bv)+bn.a3.y))*aC;let b=cv;let a=(ae.x-(ae.y- .5*h(bv))*b)*aC;var J=m(floor(bY.x*aC));var T=m(floor(dg.x*aC)+d);var S=m(floor(bY.y*bt));var V=m(floor(dg.y*bt)+d);J=clamp(J,l.x,l.z);T=clamp(T,l.x,l.z);S=clamp(S,l.y,l.w);V=clamp(V,l.y,l.w);var cr=a+b*h(S);let dz=l.z-l.x;var aO=m(W.X)+(S-l.y)*dz-l.x;var bd=m(floor(ae.x*aC));var cq=m(floor(ay.x*aC));if aI.y<c{let eN=bd;bd=cq;cq=eN;}for(var y=S;y<V;y+=1){let eM=h(y)*h(bv);let df=max(bd+1,l.x);if!fM&&bY.y<eM&&df<l.z{let O=select(-1,1,aI.y<c);let aJ=aO+df;atomicAdd(&X[aJ].O,O);}var bW=cq;if y+1<V{let eL=h(y+1)*h(bv);let eK=ae.x+(eL-ae.y)*cv;bW=m(floor(eK*aC));}let de=min(bd,bW);let dd=max(bd,bW);var cp=min(m(floor(cr-t)),de);var co=max(m(ceil(cr+t)),dd+1);cp=clamp(cp,J,T);co=clamp(co,J,T);var ax:dI;for(var x=cp;x<co;x+=1){let cu=h(x)*h(cQ);let aJ=aO+x;let dc=eW();let eJ=atomicExchange(&X[aJ].aj,dc);ax.cK=ae;ax.aD=aI;var a9=c;if!fM{a9=mix(ae.y,ay.y,(cu-ae.x)*eO);if bY.x<cu{let bO=vec2(cu,a9);if aI.x<c{ax.aD=bO-ae;}else{ax.cK=bO;ax.aD=ay-bO;}if ax.aD.x==c{ax.aD.x=sign(aI.x)*1e-9;}}if x<=de||dd<x{a9=1e9;}}ax.a9=a9;ax.el=eJ;aj[dc]=ax;}cr+=b;aO+=dz;bd=bW;}bX+=f;cs+=di;ae=ay;}ct+=az.ah;aZ=a_;}}}`
