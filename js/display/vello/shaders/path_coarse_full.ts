/* eslint-disable */
import bump from './shared/bump.js';
import cubic from './shared/cubic.js';
import segment from './shared/segment.js';
import tile from './shared/tile.js';
import pathtag from './shared/pathtag.js';
import config from './shared/config.js';
import pre from './shared/pre.js';

export default `${pre}${config}
${pathtag}
${tile}
${segment}
${cubic}
${bump}
@group(0)@binding(0)var<uniform>j:aM;@group(0)@binding(1)var<storage>n:aS;@group(0)@binding(2)var<storage>b3:array<af>;@group(0)@binding(3)var<storage>ew:array<ft>;@group(0)@binding(4)var<storage>bM:array<cF>;struct eN{K:c7,ae:bS}@group(0)@binding(5)var<storage,read_write>ak:es;@group(0)@binding(6)var<storage,read_write>S:array<eN>;@group(0)@binding(7)var<storage,read_write>ae:array<dI>;struct cw{ac:c,bv:c,bu:c}const bw=.67;fn cv(x:c)->c{return x*inverseSqrt(sqrt(1.-bw+(bw*bw*bw*bw+.25*x*x)));}const ct=.39;fn cu(x:c)->c{return x*sqrt(1.-ct+(ct*ct+.5*x*x));}fn eM(o:t,q:t,D:t,da:c)->cw{let dq=q-o;let dp=D-q;let A=dq-dp;let cross=(D.x-o.x)*A.y-(D.y-o.y)*A.x;let dn=select(1./cross,1.e9,abs(cross)<1.e-9);let F=dot(dq,A)*dn;let cs=dot(dp,A)*dn;let a5=abs(cross/(length(A)*(cs-F)));let bv=cv(F);let bu=cv(cs);var ac=0.;if a5<1e9{let eJ=abs(bu-bv);let dm=sqrt(a5);if sign(F)==sign(cs){ac=dm;}else{let cz=da/dm;ac=da/cv(cz);}ac*=eJ;}return cw(ac,bv,bu);}fn eL(o:t,q:t,D:t,s:c)->t{let ax=1.-s;return o*(ax*ax)+(q*(ax*2.)+D*s)*s;}fn bY(o:t,q:t,D:t,L:t,s:c)->t{let ax=1.-s;return o*(ax*ax*ax)+(q*(ax*ax*3.)+(D*(ax*3.)+L*s)*s)*s;}fn eK()->d{var aZ=atomicAdd(&ak.ae,1u)+1u;if aZ+1u>j.iu{aZ=0u;atomicOr(&ak.am,g7);}return aZ;}const dl=16u;@compute @workgroup_size(256)fn main(@builtin(global_invocation_id)J:I){if(atomicLoad(&ak.am)&(er|fx))!=0u{return;}let l=J.x;let H=n[j.dO+(l>>2u)];let b5=(l&3u)*8u;var b4=(H>>b5)&255u;if(b4&fr)!=0u{let bf=ew[J.x];let T=bM[bf.W];let fL=(bf.aA&is)!=0u;let h=vec4i(T.h);let o=bf.o;let q=bf.q;let D=bf.D;let L=bf.L;let dk=3.*(D-q)+o-L;let eI=dot(dk,dk);let dj=.25;let cr=dj*.1;let di=(dj-cr);let eH=432.*cr*cr;var bt=max(d(ceil(pow(eI*(1./eH),1./6.))),1u);bt=min(bt,dl);var c9:array<cw,dl>;var ac=0.;var aU=o;let step=1./c(bt);for(var e=0u;e<bt;e+=1u){let s=c(e+1u)*step;let aV=bY(o,q,D,L,s);var aT=bY(o,q,D,L,s- .5*step);aT=2.*aT- .5*(aU+aV);let aw=eM(aU,aT,aV,sqrt(di));c9[e]=aw;ac+=aw.ac;aU=aV;}let bH=max(d(ceil(ac*(.5/sqrt(di)))),1u);var Y=o;aU=o;let dh=ac/c(bH);var bW=1u;var co=0.;for(var e=0u;e<bt;e+=1u){let s=c(e+1u)*step;let aV=bY(o,q,D,L,s);var aT=bY(o,q,D,L,s- .5*step);aT=2.*aT- .5*(aU+aV);let aw=c9[e];let dg=cu(aw.bv);let eG=cu(aw.bu);let eF=1./(eG-dg);var cn=c(bW)*dh;while bW==bH||cn<co+aw.ac{var av:t;if bW==bH{av=L;}else{let eE=(cn-co)/aw.ac;let a=mix(aw.bv,aw.bu,eE);let eD=cu(a);let s=(eD-dg)*eF;av=eL(aU,aT,aV,s);}let bX=min(Y,av)-bf.aW;let df=max(Y,av)+bf.aW;let aE=av-Y;let eC=1./aE.x;let cq=select(aE.x/aE.y,1.e9,abs(aE.y)<1.e-9);let ay=1./c(cM);let bm=1./c(bq);let p=(bf.aW.x+abs(cq)*(.5*c(bq)+bf.aW.y))*ay;let b=cq;let a=(Y.x-(Y.y- .5*c(bq))*b)*ay;var F=i(floor(bX.x*ay));var O=i(floor(df.x*ay)+1.);var N=i(floor(bX.y*bm));var R=i(floor(df.y*bm)+1.);F=clamp(F,h.x,h.z);O=clamp(O,h.x,h.z);N=clamp(N,h.y,h.w);R=clamp(R,h.y,h.w);var cm=a+b*c(N);let dz=h.z-h.x;var ai=i(T.S)+(N-h.y)*dz-h.x;var a3=i(floor(Y.x*ay));var cl=i(floor(av.x*ay));if aE.y<0.{let eB=a3;a3=cl;cl=eB;}for(var y=N;y<R;y+=1){let eA=c(y)*c(bq);let de=max(a3+1,h.x);if!fL&&bX.y<eA&&de<h.z{let K=select(-1,1,aE.y<0.);let aF=ai+de;atomicAdd(&S[aF].K,K);}var bV=cl;if y+1<R{let ez=c(y+1)*c(bq);let ey=Y.x+(ez-Y.y)*cq;bV=i(floor(ey*ay));}let dd=min(a3,bV);let dc=max(a3,bV);var ck=min(i(floor(cm-p)),dd);var cj=max(i(ceil(cm+p)),dc+1);ck=clamp(ck,F,O);cj=clamp(cj,F,O);var au:dI;for(var x=ck;x<cj;x+=1){let cp=c(x)*c(cM);let aF=ai+x;let db=eK();let ex=atomicExchange(&S[aF].ae,db);au.cG=Y;au.az=aE;var a0=0.;if!fL{a0=mix(Y.y,av.y,(cp-Y.x)*eC);if bX.x<cp{let bN=vec2(cp,a0);if aE.x<0.{au.az=bN-Y;}else{au.cG=bN;au.az=av-bN;}if au.az.x==0.{au.az.x=sign(aE.x)*1e-9;}}if x<=dd||dc<x{a0=1e9;}}au.a0=a0;au.ed=ex;ae[db]=au;}cm+=b;ai+=dz;a3=bV;}bW+=1u;cn+=dh;Y=av;}co+=aw.ac;aU=aV;}}}`
