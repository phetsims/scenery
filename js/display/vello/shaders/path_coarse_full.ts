/* eslint-disable */
import bump from './shared/bump.js';
import cubic from './shared/cubic.js';
import segment from './shared/segment.js';
import tile from './shared/tile.js';
import pathtag from './shared/pathtag.js';
import config from './shared/config.js';
import pre from './shared/pre.js';

export default `${pre}${config}
${pathtag}
${tile}
${segment}
${cubic}
${bump}
@group(0)@binding(0)var<uniform>n:aT;@group(0)@binding(1)var<storage>u:aZ;@group(0)@binding(2)var<storage>b7:array<al>;@group(0)@binding(3)var<storage>eK:array<fy>;@group(0)@binding(4)var<storage>bP:array<cK>;struct e0{O:db,aj:bW}@group(0)@binding(5)var<storage,read_write>ao:eG;@group(0)@binding(6)var<storage,read_write>X:array<e0>;@group(0)@binding(7)var<storage,read_write>aj:array<dL>;struct cC{ah:h,af:h,bA:h}const bB=.67;fn cB(x:h)->h{return x*inverseSqrt(sqrt(d-bB+(bB*bB*bB*bB+.25*x*x)));}const cz=.39;fn cA(x:h)->h{return x*sqrt(d-cz+(cz*cz+.5*x*x));}fn e_(s:B,v:B,H:B,dd:h)->cC{let dt=v-s;let ds=H-v;let E=dt-ds;let cross=(H.x-s.x)*E.y-(H.y-s.y)*E.x;let dr=select(d/cross,1.e9,abs(cross)<1.e-9);let J=dot(dt,E)*dr;let cy=dot(ds,E)*dr;let bh=abs(cross/(length(E)*(cy-J)));let af=cB(J);let bA=cB(cy);var ah=c;if bh<1e9{let eX=abs(bA-af);let dq=sqrt(bh);if sign(J)==sign(cy){ah=dq;}else{let cF=dd/dq;ah=dd/cB(cF);}ah*=eX;}return cC(ah,af,bA);}fn eZ(s:B,v:B,H:B,A:h)->B{let aA=d-A;return s*(aA*aA)+(v*(aA*2.)+H*A)*A;}fn b1(s:B,v:B,H:B,R:B,A:h)->B{let aA=d-A;return s*(aA*aA*aA)+(v*(aA*aA*3.)+(H*(aA*3.)+R*A)*A)*A;}fn eY()->j{var a4=atomicAdd(&ao.aj,f)+f;if a4+f>n.iB{a4=e;atomicOr(&ao.aq,hi);}return a4;}const dp=16u;@compute @workgroup_size(256)fn main(@builtin(global_invocation_id)N:M){if(atomicLoad(&ao.aq)&(eF|fC))!=e{return;}let p=N.x;let K=u[n.dR+(p>>2u)];let b9=(p&3u)*8u;var b8=(K>>b9)&255u;if(b8&fv)!=e{let bo=eK[N.x];let W=bP[bo.ac];let fQ=(bo.aE&iz)!=e;let l=vec4i(W.l);let s=bo.s;let v=bo.v;let H=bo.H;let R=bo.R;let dn=3.*(H-v)+s-R;let eW=dot(dn,dn);let dm=.25;let cx=dm*.1;let dl=(dm-cx);let eV=432.*cx*cx;var bz=max(j(ceil(pow(eW*(d/eV),d/6.))),f);bz=min(bz,dp);var dc:array<cC,dp>;var ah=c;var a0=s;let step=d/h(bz);for(var i=e;i<bz;i+=f){let A=h(i+f)*step;let a1=b1(s,v,H,R,A);var a_=b1(s,v,H,R,A- .5*step);a_=2.*a_- .5*(a0+a1);let az=e_(a0,a_,a1,sqrt(dl));dc[i]=az;ah+=az.ah;a0=a1;}let bK=max(j(ceil(ah*(.5/sqrt(dl)))),f);var ae=s;a0=s;let dk=ah/h(bK);var b_=f;var cu=c;for(var i=e;i<bz;i+=f){let A=h(i+f)*step;let a1=b1(s,v,H,R,A);var a_=b1(s,v,H,R,A- .5*step);a_=2.*a_- .5*(a0+a1);let az=dc[i];let dj=cA(az.af);let eU=cA(az.bA);let eT=d/(eU-dj);var ct=h(b_)*dk;while b_==bK||ct<cu+az.ah{var ay:B;if b_==bK{ay=R;}else{let eS=(ct-cu)/az.ah;let a=mix(az.af,az.bA,eS);let eR=cA(a);let A=(eR-dj)*eT;ay=eZ(a0,a_,a1,A);}let b0=min(ae,ay)-bo.a5;let di=max(ae,ay)+bo.a5;let aJ=ay-ae;let eQ=d/aJ.x;let cw=select(aJ.x/aJ.y,1.e9,abs(aJ.y)<1.e-9);let aC=d/h(cS);let bu=d/h(bw);let t=(bo.a5.x+abs(cw)*(.5*h(bw)+bo.a5.y))*aC;let b=cw;let a=(ae.x-(ae.y- .5*h(bw))*b)*aC;var J=m(floor(b0.x*aC));var T=m(floor(di.x*aC)+d);var S=m(floor(b0.y*bu));var V=m(floor(di.y*bu)+d);J=clamp(J,l.x,l.z);T=clamp(T,l.x,l.z);S=clamp(S,l.y,l.w);V=clamp(V,l.y,l.w);var cs=a+b*h(S);let dC=l.z-l.x;var aQ=m(W.X)+(S-l.y)*dC-l.x;var be=m(floor(ae.x*aC));var cr=m(floor(ay.x*aC));if aJ.y<c{let eP=be;be=cr;cr=eP;}for(var y=S;y<V;y+=1){let eO=h(y)*h(bw);let dh=max(be+1,l.x);if!fQ&&b0.y<eO&&dh<l.z{let O=select(-1,1,aJ.y<c);let aK=aQ+dh;atomicAdd(&X[aK].O,O);}var bZ=cr;if y+1<V{let eN=h(y+1)*h(bw);let eM=ae.x+(eN-ae.y)*cw;bZ=m(floor(eM*aC));}let dg=min(be,bZ);let df=max(be,bZ);var cq=min(m(floor(cs-t)),dg);var cp=max(m(ceil(cs+t)),df+1);cq=clamp(cq,J,T);cp=clamp(cp,J,T);var ax:dL;for(var x=cq;x<cp;x+=1){let cv=h(x)*h(cS);let aK=aQ+x;let de=eY();let eL=atomicExchange(&X[aK].aj,de);ax.cL=ae;ax.aD=aJ;var a9=c;if!fQ{a9=mix(ae.y,ay.y,(cv-ae.x)*eQ);if b0.x<cv{let bQ=vec2(cv,a9);if aJ.x<c{ax.aD=bQ-ae;}else{ax.cL=bQ;ax.aD=ay-bQ;}if ax.aD.x==c{ax.aD.x=sign(aJ.x)*1e-9;}}if x<=dg||df<x{a9=1e9;}}ax.a9=a9;ax.eq=eL;aj[de]=ax;}cs+=b;aQ+=dC;be=bZ;}b_+=f;ct+=dk;ae=ay;}cu+=az.ah;a0=a1;}}}`
