/* eslint-disable */
import bump from './shared/bump.js';
import cubic from './shared/cubic.js';
import segment from './shared/segment.js';
import tile from './shared/tile.js';
import pathtag from './shared/pathtag.js';
import config from './shared/config.js';
import pre from './shared/pre.js';

export default `${pre}${config}
${pathtag}
${tile}
${segment}
${cubic}
${bump}
@group(0)@binding(0)var<uniform>n:aR;@group(0)@binding(1)var<storage>s:aX;@group(0)@binding(2)var<storage>ca:array<al>;@group(0)@binding(3)var<storage>eA:array<fx>;@group(0)@binding(4)var<storage>bS:array<cK>;struct eR{O:db,ak:bY}@group(0)@binding(5)var<storage,read_write>aq:ew;@group(0)@binding(6)var<storage,read_write>W:array<eR>;@group(0)@binding(7)var<storage,read_write>ak:array<dM>;struct cC{ai:h,ah:h,bz:h}const bA=.67;fn cB(x:h)->h{return x*inverseSqrt(sqrt(d-bA+(bA*bA*bA*bA+.25*x*x)));}const cz=.39;fn cA(x:h)->h{return x*sqrt(d-cz+(cz*cz+.5*x*x));}fn eQ(t:B,v:B,H:B,de:h)->cC{let du=v-t;let dt=H-v;let E=du-dt;let cross=(H.x-t.x)*E.y-(H.y-t.y)*E.x;let ds=select(d/cross,1.e9,abs(cross)<1.e-9);let J=dot(du,E)*ds;let cy=dot(dt,E)*ds;let bd=abs(cross/(length(E)*(cy-J)));let ah=cB(J);let bz=cB(cy);var ai=c;if bd<1e9{let eN=abs(bz-ah);let dr=sqrt(bd);if sign(J)==sign(cy){ai=dr;}else{let cF=de/dr;ai=de/cB(cF);}ai*=eN;}return cC(ai,ah,bz);}fn eP(t:B,v:B,H:B,A:h)->B{let aC=d-A;return t*(aC*aC)+(v*(aC*2.)+H*A)*A;}fn b3(t:B,v:B,H:B,P:B,A:h)->B{let aC=d-A;return t*(aC*aC*aC)+(v*(aC*aC*3.)+(H*(aC*3.)+P*A)*A)*A;}fn eO()->i{var a5=atomicAdd(&aq.ak,f)+f;if a5+f>n.iy{a5=e;atomicOr(&aq.au,hb);}return a5;}const dq=16u;@compute @workgroup_size(256)fn main(@builtin(global_invocation_id)N:M){if(atomicLoad(&aq.au)&(ev|fB))!=e{return;}let p=N.x;let L=s[n.dS+(p>>2u)];let cc=(p&3u)*8u;var cb=(L>>cc)&255u;if(cb&fv)!=e{let bm=eA[N.x];let X=bS[bm.ac];let fP=(bm.aF&iw)!=e;let l=vec4i(X.l);let t=bm.t;let v=bm.v;let H=bm.H;let P=bm.P;let dp=3.*(H-v)+t-P;let eM=dot(dp,dp);let dn=.25;let cx=dn*.1;let dm=(dn-cx);let eL=432.*cx*cx;var by=max(i(ceil(pow(eM*(d/eL),d/6.))),f);by=min(by,dq);var dd:array<cC,dq>;var ai=c;var aZ=t;let step=d/h(by);for(var j=e;j<by;j+=f){let A=h(j+f)*step;let a_=b3(t,v,H,P,A);var aY=b3(t,v,H,P,A- .5*step);aY=2.*aY- .5*(aZ+a_);let aB=eQ(aZ,aY,a_,sqrt(dm));dd[j]=aB;ai+=aB.ai;aZ=a_;}let bN=max(i(ceil(ai*(.5/sqrt(dm)))),f);var ae=t;aZ=t;let dl=ai/h(bN);var b1=f;var cu=c;for(var j=e;j<by;j+=f){let A=h(j+f)*step;let a_=b3(t,v,H,P,A);var aY=b3(t,v,H,P,A- .5*step);aY=2.*aY- .5*(aZ+a_);let aB=dd[j];let dk=cA(aB.ah);let eK=cA(aB.bz);let eJ=d/(eK-dk);var ct=h(b1)*dl;while b1==bN||ct<cu+aB.ai{var aA:B;if b1==bN{aA=P;}else{let eI=(ct-cu)/aB.ai;let a=mix(aB.ah,aB.bz,eI);let eH=cA(a);let A=(eH-dk)*eJ;aA=eP(aZ,aY,a_,A);}let b2=min(ae,aA)-bm.a2;let dj=max(ae,aA)+bm.a2;let aJ=aA-ae;let eG=d/aJ.x;let cw=select(aJ.x/aJ.y,1.e9,abs(aJ.y)<1.e-9);let aD=d/h(cR);let bs=d/h(bw);let u=(bm.a2.x+abs(cw)*(.5*h(bw)+bm.a2.y))*aD;let b=cw;let a=(ae.x-(ae.y- .5*h(bw))*b)*aD;var J=m(floor(b2.x*aD));var T=m(floor(dj.x*aD)+d);var R=m(floor(b2.y*bs));var V=m(floor(dj.y*bs)+d);J=clamp(J,l.x,l.z);T=clamp(T,l.x,l.z);R=clamp(R,l.y,l.w);V=clamp(V,l.y,l.w);var cs=a+b*h(R);let dD=l.z-l.x;var an=m(X.W)+(R-l.y)*dD-l.x;var a9=m(floor(ae.x*aD));var cr=m(floor(aA.x*aD));if aJ.y<c{let eF=a9;a9=cr;cr=eF;}for(var y=R;y<V;y+=1){let eE=h(y)*h(bw);let di=max(a9+1,l.x);if!fP&&b2.y<eE&&di<l.z{let O=select(-1,1,aJ.y<c);let aK=an+di;atomicAdd(&W[aK].O,O);}var b0=cr;if y+1<V{let eD=h(y+1)*h(bw);let eC=ae.x+(eD-ae.y)*cw;b0=m(floor(eC*aD));}let dh=min(a9,b0);let dg=max(a9,b0);var cq=min(m(floor(cs-u)),dh);var cp=max(m(ceil(cs+u)),dg+1);cq=clamp(cq,J,T);cp=clamp(cp,J,T);var az:dM;for(var x=cq;x<cp;x+=1){let cv=h(x)*h(cR);let aK=an+x;let df=eO();let eB=atomicExchange(&W[aK].ak,df);az.cL=ae;az.aE=aJ;var a7=c;if!fP{a7=mix(ae.y,aA.y,(cv-ae.x)*eG);if b2.x<cv{let bT=vec2(cv,a7);if aJ.x<c{az.aE=bT-ae;}else{az.cL=bT;az.aE=aA-bT;}if az.aE.x==c{az.aE.x=sign(aJ.x)*1e-9;}}if x<=dh||dg<x{a7=1e9;}}az.a7=a7;az.eh=eB;ak[df]=az;}cs+=b;an+=dD;a9=b0;}b1+=f;ct+=dl;ae=aA;}cu+=aB.ai;aZ=a_;}}}`
