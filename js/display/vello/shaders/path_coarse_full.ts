/* eslint-disable */
import bump from './shared/bump.js';
import cubic from './shared/cubic.js';
import segment from './shared/segment.js';
import tile from './shared/tile.js';
import pathtag from './shared/pathtag.js';
import config from './shared/config.js';
import pre from './shared/pre.js';

export default `${pre}${config}
${pathtag}
${tile}
${segment}
${cubic}
${bump}
@group(0)@binding(0)var<uniform>n:aV;@group(0)@binding(1)var<storage>u:a0;@group(0)@binding(2)var<storage>b8:array<al>;@group(0)@binding(3)var<storage>eL:array<fA>;@group(0)@binding(4)var<storage>bQ:array<cL>;struct e1{O:dc,ak:bX}@group(0)@binding(5)var<storage,read_write>ao:eH;@group(0)@binding(6)var<storage,read_write>Y:array<e1>;@group(0)@binding(7)var<storage,read_write>ak:array<dM>;struct cD{ah:h,af:h,bB:h}const bC=.67;fn cC(x:h)->h{return x*inverseSqrt(sqrt(d-bC+(bC*bC*bC*bC+.25*x*x)));}const cA=.39;fn cB(x:h)->h{return x*sqrt(d-cA+(cA*cA+.5*x*x));}fn e0(s:B,v:B,H:B,de:h)->cD{let du=v-s;let dt=H-v;let E=du-dt;let cross=(H.x-s.x)*E.y-(H.y-s.y)*E.x;let ds=select(d/cross,1.e9,abs(cross)<1.e-9);let J=dot(du,E)*ds;let cz=dot(dt,E)*ds;let bj=abs(cross/(length(E)*(cz-J)));let af=cC(J);let bB=cC(cz);var ah=c;if bj<1e9{let eY=abs(bB-af);let dr=sqrt(bj);if sign(J)==sign(cz){ah=dr;}else{let cG=de/dr;ah=de/cC(cG);}ah*=eY;}return cD(ah,af,bB);}fn e_(s:B,v:B,H:B,A:h)->B{let aA=d-A;return s*(aA*aA)+(v*(aA*2.)+H*A)*A;}fn b2(s:B,v:B,H:B,R:B,A:h)->B{let aA=d-A;return s*(aA*aA*aA)+(v*(aA*aA*3.)+(H*(aA*3.)+R*A)*A)*A;}fn eZ()->j{var a5=atomicAdd(&ao.ak,f)+f;if a5+f>n.iC{a5=e;atomicOr(&ao.aq,hk);}return a5;}const dq=16u;@compute @workgroup_size(256)fn main(@builtin(global_invocation_id)N:M){if(atomicLoad(&ao.aq)&(eG|fE))!=e{return;}let p=N.x;let K=u[n.dS+(p>>2u)];let ca=(p&3u)*8u;var b9=(K>>ca)&255u;if(b9&fx)!=e{let bq=eL[N.x];let X=bQ[bq.ac];let fS=(bq.aF&iA)!=e;let l=vec4i(X.l);let s=bq.s;let v=bq.v;let H=bq.H;let R=bq.R;let dp=3.*(H-v)+s-R;let eX=dot(dp,dp);let dn=.25;let cy=dn*.1;let dm=(dn-cy);let eW=432.*cy*cy;var bA=max(j(ceil(pow(eX*(d/eW),d/6.))),f);bA=min(bA,dq);var dd:array<cD,dq>;var ah=c;var a2=s;let step=d/h(bA);for(var i=e;i<bA;i+=f){let A=h(i+f)*step;let a3=b2(s,v,H,R,A);var a1=b2(s,v,H,R,A- .5*step);a1=2.*a1- .5*(a2+a3);let az=e0(a2,a1,a3,sqrt(dm));dd[i]=az;ah+=az.ah;a2=a3;}let bL=max(j(ceil(ah*(.5/sqrt(dm)))),f);var ae=s;a2=s;let dl=ah/h(bL);var b0=f;var cv=c;for(var i=e;i<bA;i+=f){let A=h(i+f)*step;let a3=b2(s,v,H,R,A);var a1=b2(s,v,H,R,A- .5*step);a1=2.*a1- .5*(a2+a3);let az=dd[i];let dk=cB(az.af);let eV=cB(az.bB);let eU=d/(eV-dk);var cu=h(b0)*dl;while b0==bL||cu<cv+az.ah{var ay:B;if b0==bL{ay=R;}else{let eT=(cu-cv)/az.ah;let a=mix(az.af,az.bB,eT);let eS=cB(a);let A=(eS-dk)*eU;ay=e_(a2,a1,a3,A);}let b1=min(ae,ay)-bq.a6;let dj=max(ae,ay)+bq.a6;let aJ=ay-ae;let eR=d/aJ.x;let cx=select(aJ.x/aJ.y,1.e9,abs(aJ.y)<1.e-9);let aD=d/h(cT);let bv=d/h(bx);let t=(bq.a6.x+abs(cx)*(.5*h(bx)+bq.a6.y))*aD;let b=cx;let a=(ae.x-(ae.y- .5*h(bx))*b)*aD;var J=m(floor(b1.x*aD));var T=m(floor(dj.x*aD)+d);var S=m(floor(b1.y*bv));var V=m(floor(dj.y*bv)+d);J=clamp(J,l.x,l.z);T=clamp(T,l.x,l.z);S=clamp(S,l.y,l.w);V=clamp(V,l.y,l.w);var ct=a+b*h(S);let dD=l.z-l.x;var aS=m(X.Y)+(S-l.y)*dD-l.x;var bh=m(floor(ae.x*aD));var cs=m(floor(ay.x*aD));if aJ.y<c{let eQ=bh;bh=cs;cs=eQ;}for(var y=S;y<V;y+=1){let eP=h(y)*h(bx);let di=max(bh+1,l.x);if!fS&&b1.y<eP&&di<l.z{let O=select(-1,1,aJ.y<c);let aK=aS+di;atomicAdd(&Y[aK].O,O);}var b_=cs;if y+1<V{let eO=h(y+1)*h(bx);let eN=ae.x+(eO-ae.y)*cx;b_=m(floor(eN*aD));}let dh=min(bh,b_);let dg=max(bh,b_);var cr=min(m(floor(ct-t)),dh);var cq=max(m(ceil(ct+t)),dg+1);cr=clamp(cr,J,T);cq=clamp(cq,J,T);var ax:dM;for(var x=cr;x<cq;x+=1){let cw=h(x)*h(cT);let aK=aS+x;let df=eZ();let eM=atomicExchange(&Y[aK].ak,df);ax.cM=ae;ax.aE=aJ;var bc=c;if!fS{bc=mix(ae.y,ay.y,(cw-ae.x)*eR);if b1.x<cw{let bR=vec2(cw,bc);if aJ.x<c{ax.aE=bR-ae;}else{ax.cM=bR;ax.aE=ay-bR;}if ax.aE.x==c{ax.aE.x=sign(aJ.x)*1e-9;}}if x<=dh||dg<x{bc=1e9;}}ax.bc=bc;ax.er=eM;ak[df]=ax;}ct+=b;aS+=dD;bh=b_;}b0+=f;cu+=dl;ae=ay;}cv+=az.ah;a2=a3;}}}`
