/* eslint-disable */
import bump from './shared/bump.js';
import cubic from './shared/cubic.js';
import segment from './shared/segment.js';
import tile from './shared/tile.js';
import pathtag from './shared/pathtag.js';
import config from './shared/config.js';
import pre from './shared/pre.js';

export default `${pre}${config}
${pathtag}
${tile}
${segment}
${cubic}
${bump}
@group(0)@binding(0)var<uniform>n:aR;@group(0)@binding(1)var<storage>u:aX;@group(0)@binding(2)var<storage>b5:array<ak>;@group(0)@binding(3)var<storage>eH:array<fu>;@group(0)@binding(4)var<storage>bM:array<cJ>;struct eY{O:c9,aj:bS}@group(0)@binding(5)var<storage,read_write>ao:eD;@group(0)@binding(6)var<storage,read_write>X:array<eY>;@group(0)@binding(7)var<storage,read_write>aj:array<dJ>;struct cB{ah:h,af:h,bx:h}const by=.67;fn cA(x:h)->h{return x*inverseSqrt(sqrt(d-by+(by*by*by*by+.25*x*x)));}const cy=.39;fn cz(x:h)->h{return x*sqrt(d-cy+(cy*cy+.5*x*x));}fn eX(s:B,v:B,H:B,dc:h)->cB{let ds=v-s;let dr=H-v;let E=ds-dr;let cross=(H.x-s.x)*E.y-(H.y-s.y)*E.x;let dq=select(d/cross,1.e9,abs(cross)<1.e-9);let J=dot(ds,E)*dq;let cx=dot(dr,E)*dq;let bd=abs(cross/(length(E)*(cx-J)));let af=cA(J);let bx=cA(cx);var ah=c;if bd<1e9{let eU=abs(bx-af);let dp=sqrt(bd);if sign(J)==sign(cx){ah=dp;}else{let cE=dc/dp;ah=dc/cA(cE);}ah*=eU;}return cB(ah,af,bx);}fn eW(s:B,v:B,H:B,A:h)->B{let aA=d-A;return s*(aA*aA)+(v*(aA*2.)+H*A)*A;}fn bY(s:B,v:B,H:B,R:B,A:h)->B{let aA=d-A;return s*(aA*aA*aA)+(v*(aA*aA*3.)+(H*(aA*3.)+R*A)*A)*A;}fn eV()->j{var a5=atomicAdd(&ao.aj,f)+f;if a5+f>n.iz{a5=e;atomicOr(&ao.aq,hd);}return a5;}const dn=16u;@compute @workgroup_size(256)fn main(@builtin(global_invocation_id)N:M){if(atomicLoad(&ao.aq)&(eC|fy))!=e{return;}let p=N.x;let K=u[n.dP+(p>>2u)];let b7=(p&3u)*8u;var b6=(K>>b7)&255u;if(b6&fs)!=e{let bm=eH[N.x];let W=bM[bm.ac];let fM=(bm.aE&ix)!=e;let l=vec4i(W.l);let s=bm.s;let v=bm.v;let H=bm.H;let R=bm.R;let dm=3.*(H-v)+s-R;let eT=dot(dm,dm);let dl=.25;let cw=dl*.1;let dk=(dl-cw);let eS=432.*cw*cw;var bw=max(j(ceil(pow(eT*(d/eS),d/6.))),f);bw=min(bw,dn);var db:array<cB,dn>;var ah=c;var aZ=s;let step=d/h(bw);for(var i=e;i<bw;i+=f){let A=h(i+f)*step;let a_=bY(s,v,H,R,A);var aY=bY(s,v,H,R,A- .5*step);aY=2.*aY- .5*(aZ+a_);let az=eX(aZ,aY,a_,sqrt(dk));db[i]=az;ah+=az.ah;aZ=a_;}let bH=max(j(ceil(ah*(.5/sqrt(dk)))),f);var ae=s;aZ=s;let dj=ah/h(bH);var bW=f;var ct=c;for(var i=e;i<bw;i+=f){let A=h(i+f)*step;let a_=bY(s,v,H,R,A);var aY=bY(s,v,H,R,A- .5*step);aY=2.*aY- .5*(aZ+a_);let az=db[i];let di=cz(az.af);let eR=cz(az.bx);let eQ=d/(eR-di);var cs=h(bW)*dj;while bW==bH||cs<ct+az.ah{var ay:B;if bW==bH{ay=R;}else{let eP=(cs-ct)/az.ah;let a=mix(az.af,az.bx,eP);let eO=cz(a);let A=(eO-di)*eQ;ay=eW(aZ,aY,a_,A);}let bX=min(ae,ay)-bm.a2;let dh=max(ae,ay)+bm.a2;let aI=ay-ae;let eN=d/aI.x;let cv=select(aI.x/aI.y,1.e9,abs(aI.y)<1.e-9);let aC=d/h(cQ);let bs=d/h(bu);let t=(bm.a2.x+abs(cv)*(.5*h(bu)+bm.a2.y))*aC;let b=cv;let a=(ae.x-(ae.y- .5*h(bu))*b)*aC;var J=m(floor(bX.x*aC));var T=m(floor(dh.x*aC)+d);var S=m(floor(bX.y*bs));var V=m(floor(dh.y*bs)+d);J=clamp(J,l.x,l.z);T=clamp(T,l.x,l.z);S=clamp(S,l.y,l.w);V=clamp(V,l.y,l.w);var cr=a+b*h(S);let dA=l.z-l.x;var aO=m(W.X)+(S-l.y)*dA-l.x;var a9=m(floor(ae.x*aC));var cq=m(floor(ay.x*aC));if aI.y<c{let eM=a9;a9=cq;cq=eM;}for(var y=S;y<V;y+=1){let eL=h(y)*h(bu);let dg=max(a9+1,l.x);if!fM&&bX.y<eL&&dg<l.z{let O=select(-1,1,aI.y<c);let aJ=aO+dg;atomicAdd(&X[aJ].O,O);}var bV=cq;if y+1<V{let eK=h(y+1)*h(bu);let eJ=ae.x+(eK-ae.y)*cv;bV=m(floor(eJ*aC));}let df=min(a9,bV);let de=max(a9,bV);var cp=min(m(floor(cr-t)),df);var co=max(m(ceil(cr+t)),de+1);cp=clamp(cp,J,T);co=clamp(co,J,T);var ax:dJ;for(var x=cp;x<co;x+=1){let cu=h(x)*h(cQ);let aJ=aO+x;let dd=eV();let eI=atomicExchange(&X[aJ].aj,dd);ax.cK=ae;ax.aD=aI;var a7=c;if!fM{a7=mix(ae.y,ay.y,(cu-ae.x)*eN);if bX.x<cu{let bN=vec2(cu,a7);if aI.x<c{ax.aD=bN-ae;}else{ax.cK=bN;ax.aD=ay-bN;}if ax.aD.x==c{ax.aD.x=sign(aI.x)*1e-9;}}if x<=df||de<x{a7=1e9;}}ax.a7=a7;ax.en=eI;aj[dd]=ax;}cr+=b;aO+=dA;a9=bV;}bW+=f;cs+=dj;ae=ay;}ct+=az.ah;aZ=a_;}}}`
