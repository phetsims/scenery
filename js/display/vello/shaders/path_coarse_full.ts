/* eslint-disable */
import bump from './shared/bump.js';
import cubic from './shared/cubic.js';
import segment from './shared/segment.js';
import tile from './shared/tile.js';
import pathtag from './shared/pathtag.js';
import config from './shared/config.js';
import pre from './shared/pre.js';

export default `${pre}${config}
${pathtag}
${tile}
${segment}
${cubic}
${bump}
@group(0)@binding(0)var<uniform>n:aQ;@group(0)@binding(1)var<storage>s:aW;@group(0)@binding(2)var<storage>b7:array<ak>;@group(0)@binding(3)var<storage>eA:array<fx>;@group(0)@binding(4)var<storage>bQ:array<cJ>;struct eR{O:db,aj:bW}@group(0)@binding(5)var<storage,read_write>ao:ew;@group(0)@binding(6)var<storage,read_write>W:array<eR>;@group(0)@binding(7)var<storage,read_write>aj:array<dM>;struct cA{ah:h,bz:h,by:h}const bA=.67;fn cz(x:h)->h{return x*inverseSqrt(sqrt(d-bA+(bA*bA*bA*bA+.25*x*x)));}const cx=.39;fn cy(x:h)->h{return x*sqrt(d-cx+(cx*cx+.5*x*x));}fn eQ(t:B,v:B,H:B,de:h)->cA{let du=v-t;let dt=H-v;let E=du-dt;let cross=(H.x-t.x)*E.y-(H.y-t.y)*E.x;let ds=select(d/cross,1.e9,abs(cross)<1.e-9);let J=dot(du,E)*ds;let cw=dot(dt,E)*ds;let a9=abs(cross/(length(E)*(cw-J)));let bz=cz(J);let by=cz(cw);var ah=c;if a9<1e9{let eN=abs(by-bz);let dr=sqrt(a9);if sign(J)==sign(cw){ah=dr;}else{let cD=de/dr;ah=de/cz(cD);}ah*=eN;}return cA(ah,bz,by);}fn eP(t:B,v:B,H:B,A:h)->B{let aB=d-A;return t*(aB*aB)+(v*(aB*2.)+H*A)*A;}fn b1(t:B,v:B,H:B,P:B,A:h)->B{let aB=d-A;return t*(aB*aB*aB)+(v*(aB*aB*3.)+(H*(aB*3.)+P*A)*A)*A;}fn eO()->i{var a2=atomicAdd(&ao.aj,f)+f;if a2+f>n.iy{a2=e;atomicOr(&ao.aq,hb);}return a2;}const dq=16u;@compute @workgroup_size(256)fn main(@builtin(global_invocation_id)N:M){if(atomicLoad(&ao.aq)&(ev|fB))!=e{return;}let p=N.x;let L=s[n.dS+(p>>2u)];let b9=(p&3u)*8u;var b8=(L>>b9)&255u;if(b8&fv)!=e{let bk=eA[N.x];let X=bQ[bk.ac];let fP=(bk.aE&iw)!=e;let l=vec4i(X.l);let t=bk.t;let v=bk.v;let H=bk.H;let P=bk.P;let dp=3.*(H-v)+t-P;let eM=dot(dp,dp);let dn=.25;let cv=dn*.1;let dm=(dn-cv);let eL=432.*cv*cv;var bx=max(i(ceil(pow(eM*(d/eL),d/6.))),f);bx=min(bx,dq);var dd:array<cA,dq>;var ah=c;var aY=t;let step=d/h(bx);for(var j=e;j<bx;j+=f){let A=h(j+f)*step;let aZ=b1(t,v,H,P,A);var aX=b1(t,v,H,P,A- .5*step);aX=2.*aX- .5*(aY+aZ);let aA=eQ(aY,aX,aZ,sqrt(dm));dd[j]=aA;ah+=aA.ah;aY=aZ;}let bL=max(i(ceil(ah*(.5/sqrt(dm)))),f);var ae=t;aY=t;let dl=ah/h(bL);var b_=f;var cs=c;for(var j=e;j<bx;j+=f){let A=h(j+f)*step;let aZ=b1(t,v,H,P,A);var aX=b1(t,v,H,P,A- .5*step);aX=2.*aX- .5*(aY+aZ);let aA=dd[j];let dk=cy(aA.bz);let eK=cy(aA.by);let eJ=d/(eK-dk);var cr=h(b_)*dl;while b_==bL||cr<cs+aA.ah{var az:B;if b_==bL{az=P;}else{let eI=(cr-cs)/aA.ah;let a=mix(aA.bz,aA.by,eI);let eH=cy(a);let A=(eH-dk)*eJ;az=eP(aY,aX,aZ,A);}let b0=min(ae,az)-bk.a_;let dj=max(ae,az)+bk.a_;let aI=az-ae;let eG=d/aI.x;let cu=select(aI.x/aI.y,1.e9,abs(aI.y)<1.e-9);let aC=d/h(cQ);let bq=d/h(bv);let u=(bk.a_.x+abs(cu)*(.5*h(bv)+bk.a_.y))*aC;let b=cu;let a=(ae.x-(ae.y- .5*h(bv))*b)*aC;var J=m(floor(b0.x*aC));var S=m(floor(dj.x*aC)+d);var R=m(floor(b0.y*bq));var V=m(floor(dj.y*bq)+d);J=clamp(J,l.x,l.z);S=clamp(S,l.x,l.z);R=clamp(R,l.y,l.w);V=clamp(V,l.y,l.w);var cq=a+b*h(R);let dD=l.z-l.x;var am=m(X.W)+(R-l.y)*dD-l.x;var a7=m(floor(ae.x*aC));var cp=m(floor(az.x*aC));if aI.y<c{let eF=a7;a7=cp;cp=eF;}for(var y=R;y<V;y+=1){let eE=h(y)*h(bv);let di=max(a7+1,l.x);if!fP&&b0.y<eE&&di<l.z{let O=select(-1,1,aI.y<c);let aJ=am+di;atomicAdd(&W[aJ].O,O);}var bZ=cp;if y+1<V{let eD=h(y+1)*h(bv);let eC=ae.x+(eD-ae.y)*cu;bZ=m(floor(eC*aC));}let dh=min(a7,bZ);let dg=max(a7,bZ);var co=min(m(floor(cq-u)),dh);var cn=max(m(ceil(cq+u)),dg+1);co=clamp(co,J,S);cn=clamp(cn,J,S);var ay:dM;for(var x=co;x<cn;x+=1){let ct=h(x)*h(cQ);let aJ=am+x;let df=eO();let eB=atomicExchange(&W[aJ].aj,df);ay.cK=ae;ay.aD=aI;var a4=c;if!fP{a4=mix(ae.y,az.y,(ct-ae.x)*eG);if b0.x<ct{let bR=vec2(ct,a4);if aI.x<c{ay.aD=bR-ae;}else{ay.cK=bR;ay.aD=az-bR;}if ay.aD.x==c{ay.aD.x=sign(aI.x)*1e-9;}}if x<=dh||dg<x{a4=1e9;}}ay.a4=a4;ay.eh=eB;aj[df]=ay;}cq+=b;am+=dD;a7=bZ;}b_+=f;cr+=dl;ae=az;}cs+=aA.ah;aY=aZ;}}}`
