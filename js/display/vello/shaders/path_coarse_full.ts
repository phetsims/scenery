/* eslint-disable */
import bump from './shared/bump.js';
import cubic from './shared/cubic.js';
import segment from './shared/segment.js';
import tile from './shared/tile.js';
import pathtag from './shared/pathtag.js';
import config from './shared/config.js';
import pre from './shared/pre.js';

export default `${pre}${config}
${pathtag}
${tile}
${segment}
${cubic}
${bump}
@group(0)@binding(0)var<uniform>n:aR;@group(0)@binding(1)var<storage>s:aX;@group(0)@binding(2)var<storage>b6:array<ak>;@group(0)@binding(3)var<storage>eI:array<fv>;@group(0)@binding(4)var<storage>bN:array<cJ>;struct eZ{P:da,aj:bT}@group(0)@binding(5)var<storage,read_write>ap:eE;@group(0)@binding(6)var<storage,read_write>W:array<eZ>;@group(0)@binding(7)var<storage,read_write>aj:array<dL>;struct cB{ah:h,af:h,bx:h}const by=.67;fn cA(x:h)->h{return x*inverseSqrt(sqrt(d-by+(by*by*by*by+.25*x*x)));}const cy=.39;fn cz(x:h)->h{return x*sqrt(d-cy+(cy*cy+.5*x*x));}fn eY(t:v,A:v,H:v,dd:h)->cB{let dt=A-t;let ds=H-A;let E=dt-ds;let cross=(H.x-t.x)*E.y-(H.y-t.y)*E.x;let dr=select(d/cross,1.e9,abs(cross)<1.e-9);let J=dot(dt,E)*dr;let cx=dot(ds,E)*dr;let bd=abs(cross/(length(E)*(cx-J)));let af=cA(J);let bx=cA(cx);var ah=c;if bd<1e9{let eV=abs(bx-af);let dq=sqrt(bd);if sign(J)==sign(cx){ah=dq;}else{let cE=dd/dq;ah=dd/cA(cE);}ah*=eV;}return cB(ah,af,bx);}fn eX(t:v,A:v,H:v,B:h)->v{let aB=d-B;return t*(aB*aB)+(A*(aB*2.)+H*B)*B;}fn bZ(t:v,A:v,H:v,Q:v,B:h)->v{let aB=d-B;return t*(aB*aB*aB)+(A*(aB*aB*3.)+(H*(aB*3.)+Q*B)*B)*B;}fn eW()->j{var a5=atomicAdd(&ap.aj,f)+f;if a5+f>n.iy{a5=e;atomicOr(&ap.at,hb);}return a5;}const dp=16u;@compute @workgroup_size(256)fn main(@builtin(global_invocation_id)N:M){if(atomicLoad(&ap.at)&(eD|fz))!=e{return;}let p=N.x;let K=s[n.dR+(p>>2u)];let b8=(p&3u)*8u;var b7=(K>>b8)&255u;if(b7&ft)!=e{let bl=eI[N.x];let X=bN[bl.ac];let fN=(bl.aF&iw)!=e;let l=vec4i(X.l);let t=bl.t;let A=bl.A;let H=bl.H;let Q=bl.Q;let dn=3.*(H-A)+t-Q;let eU=dot(dn,dn);let dm=.25;let cw=dm*.1;let dl=(dm-cw);let eT=432.*cw*cw;var bw=max(j(ceil(pow(eU*(d/eT),d/6.))),f);bw=min(bw,dp);var dc:array<cB,dp>;var ah=c;var aZ=t;let step=d/h(bw);for(var i=e;i<bw;i+=f){let B=h(i+f)*step;let a_=bZ(t,A,H,Q,B);var aY=bZ(t,A,H,Q,B- .5*step);aY=2.*aY- .5*(aZ+a_);let aA=eY(aZ,aY,a_,sqrt(dl));dc[i]=aA;ah+=aA.ah;aZ=a_;}let bI=max(j(ceil(ah*(.5/sqrt(dl)))),f);var ae=t;aZ=t;let dk=ah/h(bI);var bX=f;var ct=c;for(var i=e;i<bw;i+=f){let B=h(i+f)*step;let a_=bZ(t,A,H,Q,B);var aY=bZ(t,A,H,Q,B- .5*step);aY=2.*aY- .5*(aZ+a_);let aA=dc[i];let dj=cz(aA.af);let eS=cz(aA.bx);let eR=d/(eS-dj);var cs=h(bX)*dk;while bX==bI||cs<ct+aA.ah{var az:v;if bX==bI{az=Q;}else{let eQ=(cs-ct)/aA.ah;let a=mix(aA.af,aA.bx,eQ);let eP=cz(a);let B=(eP-dj)*eR;az=eX(aZ,aY,a_,B);}let bY=min(ae,az)-bl.a2;let di=max(ae,az)+bl.a2;let aJ=az-ae;let eO=d/aJ.x;let cv=select(aJ.x/aJ.y,1.e9,abs(aJ.y)<1.e-9);let aD=d/h(cQ);let bq=d/h(bu);let u=(bl.a2.x+abs(cv)*(.5*h(bu)+bl.a2.y))*aD;let b=cv;let a=(ae.x-(ae.y- .5*h(bu))*b)*aD;var J=m(floor(bY.x*aD));var T=m(floor(di.x*aD)+d);var S=m(floor(bY.y*bq));var V=m(floor(di.y*bq)+d);J=clamp(J,l.x,l.z);T=clamp(T,l.x,l.z);S=clamp(S,l.y,l.w);V=clamp(V,l.y,l.w);var cr=a+b*h(S);let dC=l.z-l.x;var am=m(X.W)+(S-l.y)*dC-l.x;var a9=m(floor(ae.x*aD));var cq=m(floor(az.x*aD));if aJ.y<c{let eN=a9;a9=cq;cq=eN;}for(var y=S;y<V;y+=1){let eM=h(y)*h(bu);let dh=max(a9+1,l.x);if!fN&&bY.y<eM&&dh<l.z{let P=select(-1,1,aJ.y<c);let aK=am+dh;atomicAdd(&W[aK].P,P);}var bW=cq;if y+1<V{let eL=h(y+1)*h(bu);let eK=ae.x+(eL-ae.y)*cv;bW=m(floor(eK*aD));}let dg=min(a9,bW);let df=max(a9,bW);var cp=min(m(floor(cr-u)),dg);var co=max(m(ceil(cr+u)),df+1);cp=clamp(cp,J,T);co=clamp(co,J,T);var ay:dL;for(var x=cp;x<co;x+=1){let cu=h(x)*h(cQ);let aK=am+x;let de=eW();let eJ=atomicExchange(&W[aK].aj,de);ay.cK=ae;ay.aE=aJ;var a7=c;if!fN{a7=mix(ae.y,az.y,(cu-ae.x)*eO);if bY.x<cu{let bO=vec2(cu,a7);if aJ.x<c{ay.aE=bO-ae;}else{ay.cK=bO;ay.aE=az-bO;}if ay.aE.x==c{ay.aE.x=sign(aJ.x)*1e-9;}}if x<=dg||df<x{a7=1e9;}}ay.a7=a7;ay.ep=eJ;aj[de]=ay;}cr+=b;am+=dC;a9=bW;}bX+=f;cs+=dk;ae=az;}ct+=aA.ah;aZ=a_;}}}`
