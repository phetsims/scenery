/* eslint-disable */
import bump from './shared/bump.js';
import cubic from './shared/cubic.js';
import segment from './shared/segment.js';
import tile from './shared/tile.js';
import pathtag from './shared/pathtag.js';
import config from './shared/config.js';
import pre from './shared/pre.js';

export default `${pre}${config}
${pathtag}
${tile}
${segment}
${cubic}
${bump}
@group(0)@binding(0)var<uniform>n:aR;@group(0)@binding(1)var<storage>u:aX;@group(0)@binding(2)var<storage>b6:array<ak>;@group(0)@binding(3)var<storage>eI:array<fu>;@group(0)@binding(4)var<storage>bM:array<cJ>;struct eZ{O:c9,aj:bS}@group(0)@binding(5)var<storage,read_write>ao:eE;@group(0)@binding(6)var<storage,read_write>W:array<eZ>;@group(0)@binding(7)var<storage,read_write>aj:array<dK>;struct cB{ah:h,af:h,bx:h}const by=.67;fn cA(x:h)->h{return x*inverseSqrt(sqrt(d-by+(by*by*by*by+.25*x*x)));}const cy=.39;fn cz(x:h)->h{return x*sqrt(d-cy+(cy*cy+.5*x*x));}fn eY(s:A,v:A,H:A,dc:h)->cB{let ds=v-s;let dr=H-v;let E=ds-dr;let cross=(H.x-s.x)*E.y-(H.y-s.y)*E.x;let dq=select(d/cross,1.e9,abs(cross)<1.e-9);let J=dot(ds,E)*dq;let cx=dot(dr,E)*dq;let bd=abs(cross/(length(E)*(cx-J)));let af=cA(J);let bx=cA(cx);var ah=c;if bd<1e9{let eV=abs(bx-af);let dp=sqrt(bd);if sign(J)==sign(cx){ah=dp;}else{let cE=dc/dp;ah=dc/cA(cE);}ah*=eV;}return cB(ah,af,bx);}fn eX(s:A,v:A,H:A,B:h)->A{let aA=d-B;return s*(aA*aA)+(v*(aA*2.)+H*B)*B;}fn bY(s:A,v:A,H:A,Q:A,B:h)->A{let aA=d-B;return s*(aA*aA*aA)+(v*(aA*aA*3.)+(H*(aA*3.)+Q*B)*B)*B;}fn eW()->j{var a5=atomicAdd(&ao.aj,f)+f;if a5+f>n.iy{a5=e;atomicOr(&ao.aq,hb);}return a5;}const dn=16u;@compute @workgroup_size(256)fn main(@builtin(global_invocation_id)N:M){if(atomicLoad(&ao.aq)&(eD|fy))!=e{return;}let p=N.x;let K=u[n.dQ+(p>>2u)];let b8=(p&3u)*8u;var b7=(K>>b8)&255u;if(b7&fs)!=e{let bl=eI[N.x];let X=bM[bl.ac];let fM=(bl.aE&iw)!=e;let l=vec4i(X.l);let s=bl.s;let v=bl.v;let H=bl.H;let Q=bl.Q;let dm=3.*(H-v)+s-Q;let eU=dot(dm,dm);let dl=.25;let cw=dl*.1;let dk=(dl-cw);let eT=432.*cw*cw;var bw=max(j(ceil(pow(eU*(d/eT),d/6.))),f);bw=min(bw,dn);var db:array<cB,dn>;var ah=c;var aZ=s;let step=d/h(bw);for(var i=e;i<bw;i+=f){let B=h(i+f)*step;let a_=bY(s,v,H,Q,B);var aY=bY(s,v,H,Q,B- .5*step);aY=2.*aY- .5*(aZ+a_);let az=eY(aZ,aY,a_,sqrt(dk));db[i]=az;ah+=az.ah;aZ=a_;}let bH=max(j(ceil(ah*(.5/sqrt(dk)))),f);var ae=s;aZ=s;let dj=ah/h(bH);var bW=f;var ct=c;for(var i=e;i<bw;i+=f){let B=h(i+f)*step;let a_=bY(s,v,H,Q,B);var aY=bY(s,v,H,Q,B- .5*step);aY=2.*aY- .5*(aZ+a_);let az=db[i];let di=cz(az.af);let eS=cz(az.bx);let eR=d/(eS-di);var cs=h(bW)*dj;while bW==bH||cs<ct+az.ah{var ay:A;if bW==bH{ay=Q;}else{let eQ=(cs-ct)/az.ah;let a=mix(az.af,az.bx,eQ);let eP=cz(a);let B=(eP-di)*eR;ay=eX(aZ,aY,a_,B);}let bX=min(ae,ay)-bl.a2;let dh=max(ae,ay)+bl.a2;let aI=ay-ae;let eO=d/aI.x;let cv=select(aI.x/aI.y,1.e9,abs(aI.y)<1.e-9);let aC=d/h(cQ);let bq=d/h(bu);let t=(bl.a2.x+abs(cv)*(.5*h(bu)+bl.a2.y))*aC;let b=cv;let a=(ae.x-(ae.y- .5*h(bu))*b)*aC;var J=m(floor(bX.x*aC));var T=m(floor(dh.x*aC)+d);var S=m(floor(bX.y*bq));var V=m(floor(dh.y*bq)+d);J=clamp(J,l.x,l.z);T=clamp(T,l.x,l.z);S=clamp(S,l.y,l.w);V=clamp(V,l.y,l.w);var cr=a+b*h(S);let dB=l.z-l.x;var aO=m(X.W)+(S-l.y)*dB-l.x;var a9=m(floor(ae.x*aC));var cq=m(floor(ay.x*aC));if aI.y<c{let eN=a9;a9=cq;cq=eN;}for(var y=S;y<V;y+=1){let eM=h(y)*h(bu);let dg=max(a9+1,l.x);if!fM&&bX.y<eM&&dg<l.z{let O=select(-1,1,aI.y<c);let aJ=aO+dg;atomicAdd(&W[aJ].O,O);}var bV=cq;if y+1<V{let eL=h(y+1)*h(bu);let eK=ae.x+(eL-ae.y)*cv;bV=m(floor(eK*aC));}let df=min(a9,bV);let de=max(a9,bV);var cp=min(m(floor(cr-t)),df);var co=max(m(ceil(cr+t)),de+1);cp=clamp(cp,J,T);co=clamp(co,J,T);var ax:dK;for(var x=cp;x<co;x+=1){let cu=h(x)*h(cQ);let aJ=aO+x;let dd=eW();let eJ=atomicExchange(&W[aJ].aj,dd);ax.cK=ae;ax.aD=aI;var a7=c;if!fM{a7=mix(ae.y,ay.y,(cu-ae.x)*eO);if bX.x<cu{let bN=vec2(cu,a7);if aI.x<c{ax.aD=bN-ae;}else{ax.cK=bN;ax.aD=ay-bN;}if ax.aD.x==c{ax.aD.x=sign(aI.x)*1e-9;}}if x<=df||de<x{a7=1e9;}}ax.a7=a7;ax.eo=eJ;aj[dd]=ax;}cr+=b;aO+=dB;a9=bV;}bW+=f;cs+=dj;ae=ay;}ct+=az.ah;aZ=a_;}}}`
