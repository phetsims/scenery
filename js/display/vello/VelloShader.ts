// Copyright 2023, University of Colorado Boulder

// Shaders and info have the following license:

/*
Copyright (c) 2020 Raph Levien

Permission is hereby granted, free of charge, to any
person obtaining a copy of this software and associated
documentation files (the "Software"), to deal in the
Software without restriction, including without
limitation the rights to use, copy, modify, merge,
publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software
is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice
shall be included in all copies or substantial portions
of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
 */


/**
 * Shader data for Vello.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

import { scenery, WorkgroupSize } from '../../imports.js';

// TODO: autogenerate from crates/shaders/build.rs
// TODO: minify/compress shaders (get rid of comments?)

// Data temporarily from vello/target/release/build/vello_shaders-333625b1f69e3492/out/shaders.rs
// Will improve in the future

/*
Generated from (create vello-tests/shaders dir, apply patch, then `cargo build --release`), then get each shader output here:
TODO: naga seems to create sometimes longer names for local variables. Just "minifying" and removing comments might be better currently

Subject: [PATCH] Diff for generating somewhat more compressed shaders
---
Index: crates/shaders/Cargo.toml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/crates/shaders/Cargo.toml b/crates/shaders/Cargo.toml
--- a/crates/shaders/Cargo.toml (revision ea224b459c48267e0e63747c9b192d62ef432ac9)
+++ b/crates/shaders/Cargo.toml (date 1686894671923)
@@ -10,10 +10,13 @@
 msl = []

 [dependencies]
-naga = { git = "https://github.com/gfx-rs/naga", rev = "53d62b9", features = ["wgsl-in", "msl-out", "validate"], optional = true }
+naga = { git = "https://github.com/gfx-rs/naga", rev = "53d62b9", features = ["wgsl-in", "wgsl-out", "msl-out", "validate"], optional = true }
 thiserror = { version = "1.0.40", optional = true }
+regex = { version = "1.8.4" }
+serde_json = "1.0"

 [build-dependencies]
-naga = { git = "https://github.com/gfx-rs/naga", rev = "53d62b9",  features = ["wgsl-in", "msl-out", "validate"] }
+naga = { git = "https://github.com/gfx-rs/naga", rev = "53d62b9",  features = ["wgsl-in", "wgsl-out", "msl-out", "validate"] }
 thiserror = "1.0.40"
-
+regex = { version = "1.8.4" }
+serde_json = "1.0"
Index: crates/shaders/src/compile/mod.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/crates/shaders/src/compile/mod.rs b/crates/shaders/src/compile/mod.rs
--- a/crates/shaders/src/compile/mod.rs (revision ea224b459c48267e0e63747c9b192d62ef432ac9)
+++ b/crates/shaders/src/compile/mod.rs (date 1686895981849)
@@ -45,13 +45,68 @@
 }

 impl ShaderInfo {
-    pub fn new(source: String, entry_point: &str) -> Result<ShaderInfo, Error> {
+    pub fn new(source: String, entry_point: &str, shader_name: &str) -> Result<ShaderInfo, Error> {
         let module = wgsl::parse_str(&source)?;
         let module_info = naga::valid::Validator::new(
             ValidationFlags::all() & !ValidationFlags::CONTROL_FLOW_UNIFORMITY,
             Capabilities::all(),
         )
         .validate(&module)?;
+
+        use std::fmt::Write;
+
+        let writer_flags = naga::back::wgsl::WriterFlags::empty();
+        let wgsl_text = naga::back::wgsl::write_string(&module, &module_info, writer_flags).unwrap();
+
+        use regex::Regex;
+
+        // According to WGSL spec:
+        // line breaks: \u000A\u000B\u000C\u000D\u0085\u2028\u2029
+        // white space: \u0020\u0009\u000A\u000B\u000C\u000D\u0085\u200E\u200F\u2028\u2029
+
+        let linebreak = r"[\u000A\u000B\u000C\u000D\u0085\u2028\u2029]";
+        let whitespace = r"[\u0020\u0009\u0085\u200E\u200F\u2028\u2029]";
+
+        // Collapse newlines
+        let wgsl_text = Regex::new( format!( "{whitespace}*{linebreak}+{whitespace}*" ).as_str() ).unwrap().replace_all( wgsl_text.as_str(), "\n" ).to_string();
+
+        // Collapse other whitespace
+        let wgsl_text = Regex::new( format!( "{whitespace}+" ).as_str() ).unwrap().replace_all( wgsl_text.as_str(), " " ).to_string();
+
+        // Semicolon + newline => semicolon
+        let wgsl_text = Regex::new( format!( ";{linebreak}" ).as_str() ).unwrap().replace_all( wgsl_text.as_str(), ";" ).to_string();
+
+        // Comma + newline => comma
+        let wgsl_text = Regex::new( format!( ",{linebreak}" ).as_str() ).unwrap().replace_all( wgsl_text.as_str(), "," ).to_string();
+
+        // newlines around {}
+        let wgsl_text = Regex::new( format!( r"{linebreak}*\u007B{linebreak}*" ).as_str() ).unwrap().replace_all( wgsl_text.as_str(), "{" ).to_string();
+        let wgsl_text = Regex::new( format!( r"{linebreak}*\u007D{linebreak}*" ).as_str() ).unwrap().replace_all( wgsl_text.as_str(), "}" ).to_string();
+
+        let wgsl_text = Regex::new( format!( r": " ).as_str() ).unwrap().replace_all( wgsl_text.as_str(), ":" ).to_string();
+        let wgsl_text = Regex::new( format!( r", " ).as_str() ).unwrap().replace_all( wgsl_text.as_str(), "," ).to_string();
+        let wgsl_text = Regex::new( format!( r"{whitespace}*\+{whitespace}*" ).as_str() ).unwrap().replace_all( wgsl_text.as_str(), "+" ).to_string();
+        let wgsl_text = Regex::new( format!( r"{whitespace}*\-{whitespace}*" ).as_str() ).unwrap().replace_all( wgsl_text.as_str(), "-" ).to_string();
+        let wgsl_text = Regex::new( format!( r"{whitespace}*\*{whitespace}*" ).as_str() ).unwrap().replace_all( wgsl_text.as_str(), "*" ).to_string();
+        let wgsl_text = Regex::new( format!( r"{whitespace}*<{whitespace}*" ).as_str() ).unwrap().replace_all( wgsl_text.as_str(), "<" ).to_string();
+        let wgsl_text = Regex::new( format!( r"{whitespace}*>{whitespace}*" ).as_str() ).unwrap().replace_all( wgsl_text.as_str(), ">" ).to_string();
+        let wgsl_text = Regex::new( format!( r"{whitespace}*={whitespace}*" ).as_str() ).unwrap().replace_all( wgsl_text.as_str(), "=" ).to_string();
+
+        // TODO: operator spacing
+        // TODO: ": "
+
+        let mut wgsl_buf = String::default();
+
+        writeln!(&mut wgsl_buf, "{}", wgsl_text).expect("Buffer write");
+
+        std::fs::write(format!("/Users/jon/phet/git/vello-tests/shaders/{}.wgsl", shader_name), &wgsl_buf).unwrap();
+
+        use serde_json::Value;
+
+        let json: String = Value::String( wgsl_buf.to_string() ).to_string();
+
+        std::fs::write(format!("/Users/jon/phet/git/vello-tests/shaders/{}.json", shader_name), &json).unwrap();
+
         let (entry_index, entry) = module
             .entry_points
             .iter()
@@ -182,12 +237,12 @@
                             let mut defines = defines.clone();
                             defines.extend(permutation.defines.iter().cloned());
                             let source = preprocess::preprocess(&contents, &defines, &imports);
-                            let shader_info = Self::new(source.clone(), "main").unwrap();
+                            let shader_info = Self::new(source.clone(), "main", permutation.name.as_str()).unwrap();
                             info.insert(permutation.name.clone(), shader_info);
                         }
                     } else {
                         let source = preprocess::preprocess(&contents, &defines, &imports);
-                        let shader_info = Self::new(source.clone(), "main").unwrap();
+                        let shader_info = Self::new(source.clone(), "main", shader_name).unwrap();
                         info.insert(shader_name.to_string(), shader_info);
                     }
                 }

 */

type Binding = 'Uniform' | 'BufReadOnly' | 'Buffer' | 'Image' | 'ImageRead';

type WorkgroupBuffer = {
  size_in_bytes: number;
  index: number;
};

type ShaderOptions = {
  wgsl: string;
  workgroup_size: WorkgroupSize;
  bindings: Binding[];
  workgroup_buffers: WorkgroupBuffer[];
};

type VelloShaderFormat = 'rgba8unorm' | 'bgra8unorm';

const BUFFER_TYPE_MAP = {
  Buffer: 'storage',
  BufReadOnly: 'read-only-storage',
  Uniform: 'uniform'
} as const;

export type ShaderMap = {
  backdrop_dyn: VelloShader;
  bbox_clear: VelloShader;
  binning: VelloShader;
  clip_leaf: VelloShader;
  clip_reduce: VelloShader;
  coarse: VelloShader;
  draw_leaf: VelloShader;
  draw_reduce: VelloShader;
  fine_rgba8unorm: VelloShader;
  fine_bgra8unorm: VelloShader;
  path_coarse: VelloShader;
  path_coarse_full: VelloShader;
  pathseg: VelloShader;
  pathtag_reduce: VelloShader;
  pathtag_reduce2: VelloShader;
  pathtag_scan1: VelloShader;
  pathtag_scan_large: VelloShader;
  pathtag_scan_small: VelloShader;
  tile_alloc: VelloShader;
};

// device => shader map
const shaderDeviceMap = new WeakMap<GPUDevice, ShaderMap>();

export default class VelloShader {

  public wgsl: string;

    // TODO: ditch workgroup_buffers/workgroup_size if not used later
  public workgroup_size: WorkgroupSize;
  public bindings: Binding[];
  public workgroup_buffers: WorkgroupBuffer[];

  public module: GPUShaderModule;
  public bindGroupLayout: GPUBindGroupLayout;
  public pipeline: GPUComputePipeline;

  public constructor( public name: string, data: ShaderOptions, public device: GPUDevice, format: VelloShaderFormat = 'rgba8unorm' ) {
    this.wgsl = data.wgsl;

    this.workgroup_size = data.workgroup_size;
    this.bindings = data.bindings;
    this.workgroup_buffers = data.workgroup_buffers;

    this.module = device.createShaderModule( {
      label: name,
      code: this.wgsl
    } );

    this.bindGroupLayout = device.createBindGroupLayout( {
      label: `${name} bindGroupLayout`,
      entries: this.bindings.map( ( binding, i ) => {
        const entry: GPUBindGroupLayoutEntry = {
          binding: i,
          visibility: GPUShaderStage.COMPUTE
        };

        if ( binding === 'Buffer' || binding === 'BufReadOnly' || binding === 'Uniform' ) {
          entry.buffer = {
            type: BUFFER_TYPE_MAP[ binding ],
            hasDynamicOffset: false
          };
        }
        else if ( binding === 'Image' ) {
          entry.storageTexture = {
            access: 'write-only',
            format: format,
            viewDimension: '2d'
          };
        }
        else if ( binding === 'ImageRead' ) {
          // Note: fine takes ImageFormat::Rgba8 for Image/ImageRead
          entry.texture = {
            sampleType: 'float',
            viewDimension: '2d',
            multisampled: false
          };
        }
        else {
          throw new Error( `unknown binding: ${binding}` );
        }

        return entry;
      } )
    } );

    this.pipeline = device.createComputePipeline( {
      label: `${name} pipeline`,
      layout: device.createPipelineLayout( {
        bindGroupLayouts: [ this.bindGroupLayout ]
      } ),
      compute: {
        module: this.module,
        entryPoint: 'main'
      }
    } );
  }

  public dispatch( encoder: GPUCommandEncoder, wg_counts: WorkgroupSize, resources: ( GPUBuffer | GPUTextureView )[] ): void {
    const bindGroup = this.device.createBindGroup( {
      label: `${this.name} bindGroup`,
      layout: this.bindGroupLayout,
      entries: VelloShader.resourcesToEntries( resources )
    } );
    const computePass = encoder.beginComputePass( {
      label: `${this.name} compute pass`
    } );
    computePass.setPipeline( this.pipeline );
    computePass.setBindGroup( 0, bindGroup );
    computePass.dispatchWorkgroups( wg_counts.x, wg_counts.y, wg_counts.z );
    computePass.end(); // TODO: does this mess stuff up?
  }

  private static resourcesToEntries( resources: ( GPUBuffer | GPUTextureView )[] ): GPUBindGroupEntry[] {
    return resources.map( ( resources, i ) => ( {
      binding: i,
      // handle GPUTextureView
      resource: resources instanceof GPUBuffer ? { buffer: resources } : resources
    } ) );
  }

  public static getShaders( device: GPUDevice ): ShaderMap {
    if ( !shaderDeviceMap.has( device ) ) {
      shaderDeviceMap.set( device, VelloShader.loadShaders( device ) );
    }

    const map = shaderDeviceMap.get( device );

    assert && assert( map, 'Should have a map!' );
    return map!;
  }

  private static loadShaders( device: GPUDevice ): ShaderMap {
    const getFineShaderWGSL = ( format: VelloShaderFormat ) => `struct Tile {backdrop:i32,segments:u32,}struct Segment {origin:vec2<f32>,delta:vec2<f32>,y_edge:f32,next:u32,}struct Config {width_in_tiles:u32,height_in_tiles:u32,target_width:u32,target_height:u32,base_color:u32,n_drawobj:u32,n_path:u32,n_clip:u32,bin_data_start:u32,pathtag_base:u32,pathdata_base:u32,drawtag_base:u32,drawdata_base:u32,transform_base:u32,linewidth_base:u32,binning_size:u32,tiles_size:u32,segments_size:u32,ptcl_size:u32,}struct CmdFill {tile:u32,backdrop:i32,}struct CmdStroke {tile:u32,half_width:f32,}struct CmdJump {new_ix:u32,}struct CmdColor {rgba_color:u32,}struct CmdLinGrad {index:u32,extend_mode:u32,line_x:f32,line_y:f32,line_c:f32,}struct CmdRadGrad {index:u32,extend_mode:u32,matrx:vec4<f32>,xlat:vec2<f32>,focal_x:f32,radius:f32,kind:u32,flags:u32,}struct CmdImage {matrx:vec4<f32>,xlat:vec2<f32>,atlas_offset:vec2<f32>,extents:vec2<f32>,}struct CmdEndClip {blend:u32,alpha:f32,}const TILE_WIDTH:u32=16u;const TILE_HEIGHT:u32=16u;const N_TILE_X:u32=16u;const N_TILE_Y:u32=16u;const N_TILE:u32=256u;const BLEND_STACK_SPLIT:u32=4u;const RAD_GRAD_KIND_CIRCULAR:u32=1u;const RAD_GRAD_KIND_STRIP:u32=2u;const RAD_GRAD_KIND_FOCAL_ON_CIRCLE:u32=3u;const RAD_GRAD_KIND_CONE:u32=4u;const RAD_GRAD_SWAPPED:u32=1u;const MIX_NORMAL:u32=0u;const MIX_MULTIPLY:u32=1u;const MIX_SCREEN:u32=2u;const MIX_OVERLAY:u32=3u;const MIX_DARKEN:u32=4u;const MIX_LIGHTEN:u32=5u;const MIX_COLOR_DODGE:u32=6u;const MIX_COLOR_BURN:u32=7u;const MIX_HARD_LIGHT:u32=8u;const MIX_SOFT_LIGHT:u32=9u;const MIX_DIFFERENCE:u32=10u;const MIX_EXCLUSION:u32=11u;const MIX_HUE:u32=12u;const MIX_SATURATION:u32=13u;const MIX_COLOR:u32=14u;const MIX_LUMINOSITY:u32=15u;const MIX_CLIP:u32=128u;const COMPOSE_CLEAR:u32=0u;const COMPOSE_COPY:u32=1u;const COMPOSE_DEST:u32=2u;const COMPOSE_SRC_OVER:u32=3u;const COMPOSE_DEST_OVER:u32=4u;const COMPOSE_SRC_IN:u32=5u;const COMPOSE_DEST_IN:u32=6u;const COMPOSE_SRC_OUT:u32=7u;const COMPOSE_DEST_OUT:u32=8u;const COMPOSE_SRC_ATOP:u32=9u;const COMPOSE_DEST_ATOP:u32=10u;const COMPOSE_XOR:u32=11u;const COMPOSE_PLUS:u32=12u;const COMPOSE_PLUS_LIGHTER:u32=13u;const PTCL_INITIAL_ALLOC:u32=64u;const PTCL_INCREMENT:u32=256u;const PTCL_HEADROOM:u32=2u;const CMD_END:u32=0u;const CMD_FILL:u32=1u;const CMD_STROKE:u32=2u;const CMD_SOLID:u32=3u;const CMD_COLOR:u32=5u;const CMD_LIN_GRAD:u32=6u;const CMD_RAD_GRAD:u32=7u;const CMD_IMAGE:u32=8u;const CMD_BEGIN_CLIP:u32=9u;const CMD_END_CLIP:u32=10u;const CMD_JUMP:u32=11u;const GRADIENT_WIDTH:i32=512;const PIXELS_PER_THREAD:u32=4u;@group(0) @binding(0)\nvar<uniform>config:Config;@group(0) @binding(1)\nvar<storage>tiles:array<Tile>;@group(0) @binding(2)\nvar<storage>segments:array<Segment>;@group(0) @binding(3)\nvar output:texture_storage_2d<${format},write>;@group(0) @binding(4)\nvar<storage>ptcl:array<u32>;@group(0) @binding(5)\nvar gradients:texture_2d<f32>;@group(0) @binding(6)\nvar<storage>info:array<u32>;@group(0) @binding(7)\nvar image_atlas:texture_2d<f32>;fn screen(cb:vec3<f32>,cs:vec3<f32>)->vec3<f32>{return ((cb+cs)-(cb*cs));}fn color_dodge(cb_1:f32,cs_1:f32)->f32 {if (cb_1==0.0) {return 0.0;} else {if (cs_1==1.0) {return 1.0;} else {return min(1.0,(cb_1 / (1.0-cs_1)));}}}fn color_burn(cb_2:f32,cs_2:f32)->f32 {if (cb_2==1.0) {return 1.0;} else {if (cs_2==0.0) {return 0.0;} else {return (1.0-min(1.0,((1.0-cb_2) / cs_2)));}}}fn hard_light(cb_3:vec3<f32>,cs_3:vec3<f32>)->vec3<f32>{let _e7=screen(cb_3,((2.0*cs_3)-vec3<f32>(1.0)));return select(_e7,((cb_3*2.0)*cs_3),(cs_3<=vec3<f32>(0.5)));}fn soft_light(cb_4:vec3<f32>,cs_4:vec3<f32>)->vec3<f32>{let d=select(sqrt(cb_4),(((((16.0*cb_4)-vec3<f32>(12.0))*cb_4)+vec3<f32>(4.0))*cb_4),(cb_4<=vec3<f32>(0.25)));return select((cb_4+(((2.0*cs_4)-vec3<f32>(1.0))*(d-cb_4))),(cb_4-(((vec3<f32>(1.0)-(2.0*cs_4))*cb_4)*(vec3<f32>(1.0)-cb_4))),(cs_4<=vec3<f32>(0.5)));}fn sat(c:vec3<f32>)->f32 {return (max(c.x,max(c.y,c.z))-min(c.x,min(c.y,c.z)));}fn lum(c_1:vec3<f32>)->f32 {let f=vec3<f32>(0.30000001192092896,0.5899999737739563,0.10999999940395355);return dot(c_1,f);}fn clip_color(c_in:vec3<f32>)->vec3<f32>{var c_2:vec3<f32>;c_2=c_in;let _e2=c_2;let _e3=lum(_e2);let _e5=c_2.x;let _e7=c_2.y;let _e9=c_2.z;let n=min(_e5,min(_e7,_e9));let _e13=c_2.x;let _e15=c_2.y;let _e17=c_2.z;let x=max(_e13,max(_e15,_e17));if (n<0.0) {let _e22=c_2;c_2=(vec3<f32>(_e3)+(((_e22-vec3<f32>(_e3))*_e3) / vec3<f32>((_e3-n))));}if (x>1.0) {let _e33=c_2;c_2=(vec3<f32>(_e3)+(((_e33-vec3<f32>(_e3))*(1.0-_e3)) / vec3<f32>((x-_e3))));}let _e44=c_2;return _e44;}fn set_lum(c_3:vec3<f32>,l:f32)->vec3<f32>{let _e2=lum(c_3);let _e6=clip_color((c_3+vec3<f32>((l-_e2))));return _e6;}fn set_sat_inner(cmin:ptr<function,f32>,cmid:ptr<function,f32>,cmax:ptr<function,f32>,s:f32) {let _e4=(*cmax);let _e5=(*cmin);if (_e4>_e5) {let _e7=(*cmid);let _e8=(*cmin);let _e11=(*cmax);let _e12=(*cmin);(*cmid)=(((_e7-_e8)*s) / (_e11-_e12));(*cmax)=s;} else {(*cmid)=0.0;(*cmax)=0.0;}(*cmin)=0.0;return;}fn set_sat(c_4:vec3<f32>,s_1:f32)->vec3<f32>{var r:f32;var g:f32;var b:f32;r=c_4.x;g=c_4.y;b=c_4.z;let _e8=r;let _e9=g;if (_e8<=_e9) {let _e11=g;let _e12=b;if (_e11<=_e12) {set_sat_inner((&r),(&g),(&b),s_1);} else {let _e14=r;let _e15=b;if (_e14<=_e15) {set_sat_inner((&r),(&b),(&g),s_1);} else {set_sat_inner((&b),(&r),(&g),s_1);}}} else {let _e17=r;let _e18=b;if (_e17<=_e18) {set_sat_inner((&g),(&r),(&b),s_1);} else {let _e20=g;let _e21=b;if (_e20<=_e21) {set_sat_inner((&g),(&b),(&r),s_1);} else {set_sat_inner((&b),(&g),(&r),s_1);}}}let _e23=r;let _e24=g;let _e25=b;return vec3<f32>(_e23,_e24,_e25);}fn blend_mix(cb_5:vec3<f32>,cs_5:vec3<f32>,mode:u32)->vec3<f32>{var b_1:vec3<f32>;b_1=vec3<f32>(0.0);switch mode {case 1u:{b_1=(cb_5*cs_5);}case 2u:{let _e7=screen(cb_5,cs_5);b_1=_e7;}case 3u:{let _e8=hard_light(cs_5,cb_5);b_1=_e8;}case 4u:{b_1=min(cb_5,cs_5);}case 5u:{b_1=max(cb_5,cs_5);}case 6u:{let _e13=color_dodge(cb_5.x,cs_5.x);let _e16=color_dodge(cb_5.y,cs_5.y);let _e19=color_dodge(cb_5.z,cs_5.z);b_1=vec3<f32>(_e13,_e16,_e19);}case 7u:{let _e23=color_burn(cb_5.x,cs_5.x);let _e26=color_burn(cb_5.y,cs_5.y);let _e29=color_burn(cb_5.z,cs_5.z);b_1=vec3<f32>(_e23,_e26,_e29);}case 8u:{let _e31=hard_light(cb_5,cs_5);b_1=_e31;}case 9u:{let _e32=soft_light(cb_5,cs_5);b_1=_e32;}case 10u:{b_1=abs((cb_5-cs_5));}case 11u:{b_1=((cb_5+cs_5)-((2.0*cb_5)*cs_5));}case 12u:{let _e40=sat(cb_5);let _e41=set_sat(cs_5,_e40);let _e42=lum(cb_5);let _e43=set_lum(_e41,_e42);b_1=_e43;}case 13u:{let _e44=sat(cs_5);let _e45=set_sat(cb_5,_e44);let _e46=lum(cb_5);let _e47=set_lum(_e45,_e46);b_1=_e47;}case 14u:{let _e48=lum(cb_5);let _e49=set_lum(cs_5,_e48);b_1=_e49;}case 15u:{let _e50=lum(cs_5);let _e51=set_lum(cb_5,_e50);b_1=_e51;}default:{b_1=cs_5;}}let _e52=b_1;return _e52;}fn blend_compose(cb_6:vec3<f32>,cs_6:vec3<f32>,ab:f32,as_:f32,mode_1:u32)->vec4<f32>{var fa:f32;var fb:f32;fa=0.0;fb=0.0;switch mode_1 {case 1u:{fa=1.0;fb=0.0;}case 2u:{fa=0.0;fb=1.0;}case 3u:{fa=1.0;fb=(1.0-as_);}case 4u:{fa=(1.0-ab);fb=1.0;}case 5u:{fa=ab;fb=0.0;}case 6u:{fa=0.0;fb=as_;}case 7u:{fa=(1.0-ab);fb=0.0;}case 8u:{fa=0.0;fb=(1.0-as_);}case 9u:{fa=ab;fb=(1.0-as_);}case 10u:{fa=(1.0-ab);fb=as_;}case 11u:{fa=(1.0-ab);fb=(1.0-as_);}case 12u:{fa=1.0;fb=1.0;}case 13u:{return min(vec4<f32>(1.0),vec4<f32>(((as_*cs_6)+(ab*cb_6)),(as_+ab)));}default:{}}let _e45=fa;let as_fa=(as_*_e45);let _e47=fb;let ab_fb=(ab*_e47);let co=((as_fa*cs_6)+(ab_fb*cb_6));return vec4<f32>(co,min((as_fa+ab_fb),1.0));}fn blend_mix_compose(backdrop:vec4<f32>,src:vec4<f32>,mode_2:u32)->vec4<f32>{var cs_7:vec3<f32>;let BLEND_DEFAULT=((MIX_NORMAL<<8u) | COMPOSE_SRC_OVER);if ((mode_2 & 32767u)==BLEND_DEFAULT) {return ((backdrop*(1.0-src.w))+src);}let inv_src_a=(1.0 / max(src.w,1.0000000036274937e-15));cs_7=(src.xyz*inv_src_a);let inv_backdrop_a=(1.0 / max(backdrop.w,1.0000000036274937e-15));let cb_7=(backdrop.xyz*inv_backdrop_a);let mix_mode=(mode_2>>8u);let _e32=cs_7;let _e33=blend_mix(cb_7,_e32,mix_mode);let _e34=cs_7;cs_7=mix(_e34,_e33,backdrop.w);let compose_mode=(mode_2 & 255u);if (compose_mode==COMPOSE_SRC_OVER) {let _e42=cs_7;let co_1=mix(backdrop.xyz,_e42,src.w);return vec4<f32>(co_1,(src.w+(backdrop.w*(1.0-src.w))));} else {let _e53=cs_7;let _e56=blend_compose(cb_7,_e53,backdrop.w,src.w,compose_mode);return _e56;}}fn read_fill(cmd_ix_1:u32)->CmdFill {let tile_1=ptcl[(cmd_ix_1+1u)];let _e10=ptcl[(cmd_ix_1+2u)];let backdrop_1=i32(_e10);return CmdFill(tile_1,backdrop_1);}fn read_stroke(cmd_ix_2:u32)->CmdStroke {let tile_2=ptcl[(cmd_ix_2+1u)];let _e10=ptcl[(cmd_ix_2+2u)];let half_width_1=bitcast<f32>(_e10);return CmdStroke(tile_2,half_width_1);}fn read_color(cmd_ix_3:u32)->CmdColor {let rgba_color=ptcl[(cmd_ix_3+1u)];return CmdColor(rgba_color);}fn read_lin_grad(cmd_ix_4:u32)->CmdLinGrad {let index_mode=ptcl[(cmd_ix_4+1u)];let index=(index_mode>>2u);let extend_mode_1=(index_mode & 3u);let info_offset=ptcl[(cmd_ix_4+2u)];let _e17=info[info_offset];let line_x=bitcast<f32>(_e17);let _e23=info[(info_offset+1u)];let line_y=bitcast<f32>(_e23);let _e29=info[(info_offset+2u)];let line_c=bitcast<f32>(_e29);return CmdLinGrad(index,extend_mode_1,line_x,line_y,line_c);}fn read_rad_grad(cmd_ix_5:u32)->CmdRadGrad {let index_mode_1=ptcl[(cmd_ix_5+1u)];let index_1=(index_mode_1>>2u);let extend_mode_2=(index_mode_1 & 3u);let info_offset_1=ptcl[(cmd_ix_5+2u)];let _e17=info[info_offset_1];let m0_=bitcast<f32>(_e17);let _e23=info[(info_offset_1+1u)];let m1_=bitcast<f32>(_e23);let _e29=info[(info_offset_1+2u)];let m2_=bitcast<f32>(_e29);let _e35=info[(info_offset_1+3u)];let m3_=bitcast<f32>(_e35);let matrx=vec4<f32>(m0_,m1_,m2_,m3_);let _e42=info[(info_offset_1+4u)];let _e48=info[(info_offset_1+5u)];let xlat=vec2<f32>(bitcast<f32>(_e42),bitcast<f32>(_e48));let _e55=info[(info_offset_1+6u)];let focal_x=bitcast<f32>(_e55);let _e61=info[(info_offset_1+7u)];let radius=bitcast<f32>(_e61);let flags_kind=info[(info_offset_1+8u)];let flags=(flags_kind>>3u);let kind=(flags_kind & 7u);return CmdRadGrad(index_1,extend_mode_2,matrx,xlat,focal_x,radius,kind,flags);}fn read_image(cmd_ix_6:u32)->CmdImage {let info_offset_2=ptcl[(cmd_ix_6+1u)];let _e8=info[info_offset_2];let m0_1=bitcast<f32>(_e8);let _e14=info[(info_offset_2+1u)];let m1_1=bitcast<f32>(_e14);let _e20=info[(info_offset_2+2u)];let m2_1=bitcast<f32>(_e20);let _e26=info[(info_offset_2+3u)];let m3_1=bitcast<f32>(_e26);let matrx_1=vec4<f32>(m0_1,m1_1,m2_1,m3_1);let _e33=info[(info_offset_2+4u)];let _e39=info[(info_offset_2+5u)];let xlat_1=vec2<f32>(bitcast<f32>(_e33),bitcast<f32>(_e39));let xy_2=info[(info_offset_2+6u)];let width_height=info[(info_offset_2+7u)];let x_1=f32((xy_2>>16u));let y=f32((xy_2 & 65535u));let width=f32((width_height>>16u));let height=f32((width_height & 65535u));return CmdImage(matrx_1,xlat_1,vec2<f32>(x_1,y),vec2<f32>(width,height));}fn read_end_clip(cmd_ix_7:u32)->CmdEndClip {let blend=ptcl[(cmd_ix_7+1u)];let _e10=ptcl[(cmd_ix_7+2u)];let alpha=bitcast<f32>(_e10);return CmdEndClip(blend,alpha);}fn extend_mode(t_1:f32,mode_3:u32)->f32 {switch mode_3 {case 0u:{return clamp(t_1,0.0,1.0);}case 1u:{return fract(t_1);}default:{return abs((t_1-(2.0*round((0.5*t_1)))));}}}fn fill_path(tile:Tile,xy:vec2<f32>,even_odd:bool)->array<f32,PIXELS_PER_THREAD>{var area_1:array<f32,PIXELS_PER_THREAD>;var i_9:u32;var segment_ix:u32;var i_10:u32;var i_11:u32;var i_12:u32;var i_13:u32;let backdrop_f=f32(tile.backdrop);i_9=0u;loop {let _e8=i_9;if (_e8<PIXELS_PER_THREAD) {} else {break;}{let _e11=i_9;area_1[_e11]=backdrop_f;}continuing {let _e14=i_9;i_9=(_e14+1u);}}segment_ix=tile.segments;loop {let _e18=segment_ix;if (_e18 !=0u) {} else {break;}{let _e22=segment_ix;let segment=segments[_e22];let y_1=(segment.origin.y-xy.y);let y0_=clamp(y_1,0.0,1.0);let y1_=clamp((y_1+segment.delta.y),0.0,1.0);let dy=(y0_-y1_);if (dy !=0.0) {let vec_y_recip=(1.0 / segment.delta.y);let t0_=((y0_-y_1)*vec_y_recip);let t1_=((y1_-y_1)*vec_y_recip);let startx=(segment.origin.x-xy.x);let x0_=(startx+(t0_*segment.delta.x));let x1_=(startx+(t1_*segment.delta.x));let xmin0_=min(x0_,x1_);let xmax0_=max(x0_,x1_);i_10=0u;loop {let _e65=i_10;if (_e65<PIXELS_PER_THREAD) {} else {break;}{let _e68=i_10;let i_f=f32(_e68);let xmin=(min((xmin0_-i_f),1.0)-9.999999974752427e-7);let xmax=(xmax0_-i_f);let b_2=min(xmax,1.0);let c_5=max(b_2,0.0);let d_1=max(xmin,0.0);let a=(((b_2+(0.5*((d_1*d_1)-(c_5*c_5))))-xmin) / (xmax-xmin));let _e91=i_10;let _e94=area_1[_e91];area_1[_e91]=(_e94+(a*dy));}continuing {let _e97=i_10;i_10=(_e97+1u);}}}let y_edge=(sign(segment.delta.x)*clamp(((xy.y-segment.y_edge)+1.0),0.0,1.0));i_11=0u;loop {let _e113=i_11;if (_e113<PIXELS_PER_THREAD) {} else {break;}{let _e116=i_11;let _e118=area_1[_e116];area_1[_e116]=(_e118+y_edge);}continuing {let _e121=i_11;i_11=(_e121+1u);}}segment_ix=segment.next;}}if even_odd {i_12=0u;loop {let _e126=i_12;if (_e126<PIXELS_PER_THREAD) {} else {break;}{let _e129=i_12;let a_1=area_1[_e129];let _e132=i_12;area_1[_e132]=abs((a_1-(2.0*round((0.5*a_1)))));}continuing {let _e142=i_12;i_12=(_e142+1u);}}} else {i_13=0u;loop {let _e146=i_13;if (_e146<PIXELS_PER_THREAD) {} else {break;}{let _e149=i_13;let _e151=i_13;let _e153=area_1[_e151];area_1[_e149]=min(abs(_e153),1.0);}continuing {let _e158=i_13;i_13=(_e158+1u);}}}let _e160=area_1;return _e160;}fn stroke_path(seg:u32,half_width:f32,xy_1:vec2<f32>)->array<f32,PIXELS_PER_THREAD>{var df:array<f32,PIXELS_PER_THREAD>;var i_14:u32;var segment_ix_1:u32;var i_15:u32;var i_16:u32;i_14=0u;loop {let _e6=i_14;if (_e6<PIXELS_PER_THREAD) {} else {break;}{let _e9=i_14;df[_e9]=1000000000.0;}continuing {let _e13=i_14;i_14=(_e13+1u);}}segment_ix_1=seg;loop {let _e16=segment_ix_1;if (_e16 !=0u) {} else {break;}{let _e20=segment_ix_1;let segment_1=segments[_e20];let delta=segment_1.delta;let dpos0_=((xy_1+vec2<f32>(0.5,0.5))-segment_1.origin);let scale=(1.0 / dot(delta,delta));i_15=0u;loop {let _e35=i_15;if (_e35<PIXELS_PER_THREAD) {} else {break;}{let _e39=i_15;let dpos=vec2<f32>((dpos0_.x+f32(_e39)),dpos0_.y);let t_2=clamp((dot(dpos,delta)*scale),0.0,1.0);let _e49=i_15;let _e51=i_15;let _e53=df[_e51];df[_e49]=min(_e53,length(((delta*t_2)-dpos)));}continuing {let _e59=i_15;i_15=(_e59+1u);}}segment_ix_1=segment_1.next;}}i_16=0u;loop {let _e64=i_16;if (_e64<PIXELS_PER_THREAD) {} else {break;}{let _e67=i_16;let _e71=i_16;let _e73=df[_e71];df[_e67]=clamp(((half_width+0.5)-_e73),0.0,1.0);}continuing {let _e79=i_16;i_16=(_e79+1u);}}let _e81=df;return _e81;}fn premul_alpha(rgba_1:vec4<f32>)->vec4<f32>{return vec4<f32>((rgba_1.xyz*rgba_1.w),rgba_1.w);}@compute @workgroup_size(4,16,1)\nfn main(@builtin(global_invocation_id) global_id:vec3<u32>,@builtin(local_invocation_id) local_id:vec3<u32>,@builtin(workgroup_id) wg_id:vec3<u32>) {var rgba:array<vec4<f32>,PIXELS_PER_THREAD>;var i:u32;var blend_stack:array<array<u32,PIXELS_PER_THREAD>,BLEND_STACK_SPLIT>;var clip_depth:u32;var area:array<f32,PIXELS_PER_THREAD>;var cmd_ix:u32;var i_1:u32;var i_2:u32;var i_3:u32;var i_4:u32;var t:f32;var is_valid:bool;var i_5:u32;var i_6:u32;var i_7:u32;var bg_rgba:u32;var i_8:u32;let _e6=config.width_in_tiles;let tile_ix=((wg_id.y*_e6)+wg_id.x);let xy_3=vec2<f32>(f32((global_id.x*PIXELS_PER_THREAD)),f32(global_id.y));i=0u;loop {let _e20=i;if (_e20<PIXELS_PER_THREAD) {} else {break;}{let _e23=i;let _e27=config.base_color;rgba[_e23]=unpack4x8unorm(_e27).wzyx;}continuing {let _e31=i;i=(_e31+1u);}}clip_depth=0u;cmd_ix=(tile_ix*PTCL_INITIAL_ALLOC);let _e41=cmd_ix;let blend_offset=ptcl[_e41];let _e45=cmd_ix;cmd_ix=(_e45+1u);loop {if true {} else {break;}{let _e49=cmd_ix;let tag=ptcl[_e49];if (tag==CMD_END) {break;}switch tag {case 1u:{let _e54=cmd_ix;let _e55=read_fill(_e54);let segments_1=(_e55.tile>>1u);let even_odd_1=((_e55.tile & 1u) !=0u);let tile_3=Tile(_e55.backdrop,segments_1);let _e66=fill_path(tile_3,xy_3,even_odd_1);area=_e66;let _e68=cmd_ix;cmd_ix=(_e68+3u);}case 2u:{let _e70=cmd_ix;let _e71=read_stroke(_e70);let _e74=stroke_path(_e71.tile,_e71.half_width,xy_3);area=_e74;let _e76=cmd_ix;cmd_ix=(_e76+3u);}case 3u:{i_1=0u;loop {let _e80=i_1;if (_e80<PIXELS_PER_THREAD) {} else {break;}{let _e83=i_1;area[_e83]=1.0;}continuing {let _e87=i_1;i_1=(_e87+1u);}}let _e90=cmd_ix;cmd_ix=(_e90+1u);}case 5u:{let _e92=cmd_ix;let _e93=read_color(_e92);let fg=unpack4x8unorm(_e93.rgba_color).wzyx;i_2=0u;loop {let _e99=i_2;if (_e99<PIXELS_PER_THREAD) {} else {break;}{let _e102=i_2;let _e104=area[_e102];let fg_i=(fg*_e104);let _e106=i_2;let _e108=i_2;let _e110=rgba[_e108];rgba[_e106]=((_e110*(1.0-fg_i.w))+fg_i);}continuing {let _e117=i_2;i_2=(_e117+1u);}}let _e120=cmd_ix;cmd_ix=(_e120+2u);}case 6u:{let _e122=cmd_ix;let _e123=read_lin_grad(_e122);let d_2=(((_e123.line_x*xy_3.x)+(_e123.line_y*xy_3.y))+_e123.line_c);i_3=0u;loop {let _e135=i_3;if (_e135<PIXELS_PER_THREAD) {} else {break;}{let _e139=i_3;let my_d=(d_2+(_e123.line_x*f32(_e139)));let _e144=extend_mode(my_d,_e123.extend_mode);let x_2=i32(round((_e144*f32((GRADIENT_WIDTH-1)))));let fg_rgba=textureLoad(gradients,vec2<i32>(x_2,i32(_e123.index)),0);let _e158=i_3;let _e160=area[_e158];let fg_i_1=(fg_rgba*_e160);let _e162=i_3;let _e164=i_3;let _e166=rgba[_e164];rgba[_e162]=((_e166*(1.0-fg_i_1.w))+fg_i_1);}continuing {let _e173=i_3;i_3=(_e173+1u);}}let _e176=cmd_ix;cmd_ix=(_e176+3u);}case 7u:{let _e178=cmd_ix;let _e179=read_rad_grad(_e178);let focal_x_1=_e179.focal_x;let radius_1=_e179.radius;let is_strip=(_e179.kind==RAD_GRAD_KIND_STRIP);let is_circular=(_e179.kind==RAD_GRAD_KIND_CIRCULAR);let is_focal_on_circle=(_e179.kind==RAD_GRAD_KIND_FOCAL_ON_CIRCLE);let is_swapped=((_e179.flags & RAD_GRAD_SWAPPED) !=0u);let r1_recip=select((1.0 / radius_1),0.0,is_circular);let less_scale=select(1.0,-1.0,(is_swapped || ((1.0-focal_x_1)<0.0)));let t_sign=sign((1.0-focal_x_1));i_4=0u;loop {let _e213=i_4;if (_e213<PIXELS_PER_THREAD) {} else {break;}{let _e217=i_4;let my_xy=vec2<f32>((xy_3.x+f32(_e217)),xy_3.y);let local_xy=(((_e179.matrx.xy*my_xy.x)+(_e179.matrx.zw*my_xy.y))+_e179.xlat);let x_3=local_xy.x;let y_2=local_xy.y;let xx=(x_3*x_3);let yy=(y_2*y_2);t=0.0;is_valid=true;if is_strip {let a_2=(radius_1-yy);t=(sqrt(a_2)+x_3);is_valid=(a_2>=0.0);} else {if is_focal_on_circle {t=((xx+yy) / x_3);let _e248=t;is_valid=((_e248>=0.0) && (x_3 !=0.0));} else {if (radius_1>1.0) {t=(sqrt((xx+yy))-(x_3*r1_recip));} else {let a_3=(xx-yy);t=((less_scale*sqrt(a_3))-(x_3*r1_recip));let _e267=t;is_valid=((a_3>=0.0) && (_e267>=0.0));}}}let _e271=is_valid;if _e271 {let _e272=t;let _e276=extend_mode((focal_x_1+(t_sign*_e272)),_e179.extend_mode);t=_e276;let _e277=t;let _e279=t;t=select(_e277,(1.0-_e279),is_swapped);let _e282=t;let x_4=i32(round((_e282*f32((GRADIENT_WIDTH-1)))));let fg_rgba_1=textureLoad(gradients,vec2<i32>(x_4,i32(_e179.index)),0);let _e296=i_4;let _e298=area[_e296];let fg_i_2=(fg_rgba_1*_e298);let _e300=i_4;let _e302=i_4;let _e304=rgba[_e302];rgba[_e300]=((_e304*(1.0-fg_i_2.w))+fg_i_2);}}continuing {let _e311=i_4;i_4=(_e311+1u);}}let _e314=cmd_ix;cmd_ix=(_e314+3u);}case 8u:{let _e316=cmd_ix;let _e317=read_image(_e316);let atlas_extents=(_e317.atlas_offset+_e317.extents);i_5=0u;loop {let _e323=i_5;if (_e323<PIXELS_PER_THREAD) {} else {break;}{let _e327=i_5;let my_xy_1=vec2<f32>((xy_3.x+f32(_e327)),xy_3.y);let atlas_uv=((((_e317.matrx.xy*my_xy_1.x)+(_e317.matrx.zw*my_xy_1.y))+_e317.xlat)+_e317.atlas_offset);let _e347=i_5;let _e349=area[_e347];if (all((atlas_uv<atlas_extents)) && (_e349 !=0.0)) {let uv_quad=vec4<f32>(max(floor(atlas_uv),_e317.atlas_offset),min(ceil(atlas_uv),atlas_extents));let uv_frac=fract(atlas_uv);let _e364=textureLoad(image_atlas,vec2<i32>(uv_quad.xy),0);let _e365=premul_alpha(_e364);let _e370=textureLoad(image_atlas,vec2<i32>(uv_quad.xw),0);let _e371=premul_alpha(_e370);let _e376=textureLoad(image_atlas,vec2<i32>(uv_quad.zy),0);let _e377=premul_alpha(_e376);let _e382=textureLoad(image_atlas,vec2<i32>(uv_quad.zw),0);let _e383=premul_alpha(_e382);let fg_rgba_2=mix(mix(_e365,_e371,uv_frac.y),mix(_e377,_e383,uv_frac.y),uv_frac.x);let _e390=i_5;let _e392=area[_e390];let fg_i_3=(fg_rgba_2*_e392);let _e394=i_5;let _e396=i_5;let _e398=rgba[_e396];rgba[_e394]=((_e398*(1.0-fg_i_3.w))+fg_i_3);}}continuing {let _e405=i_5;i_5=(_e405+1u);}}let _e408=cmd_ix;cmd_ix=(_e408+2u);}case 9u:{let _e410=clip_depth;if (_e410<BLEND_STACK_SPLIT) {i_6=0u;loop {let _e415=i_6;if (_e415<PIXELS_PER_THREAD) {} else {break;}{let _e418=clip_depth;let _e420=i_6;let _e422=i_6;let _e424=rgba[_e422];blend_stack[_e418][_e420]=pack4x8unorm(_e424);let _e426=i_6;rgba[_e426]=vec4<f32>(0.0);}continuing {let _e431=i_6;i_6=(_e431+1u);}}}let _e434=clip_depth;clip_depth=(_e434+1u);let _e437=cmd_ix;cmd_ix=(_e437+1u);}case 10u:{let _e439=cmd_ix;let _e440=read_end_clip(_e439);let _e442=clip_depth;clip_depth=(_e442-1u);i_7=0u;loop {let _e446=i_7;if (_e446<PIXELS_PER_THREAD) {} else {break;}{let _e450=clip_depth;if (_e450<BLEND_STACK_SPLIT) {let _e453=clip_depth;let _e455=i_7;let _e457=blend_stack[_e453][_e455];bg_rgba=_e457;}let _e458=bg_rgba;let bg=unpack4x8unorm(_e458);let _e460=i_7;let _e462=rgba[_e460];let _e463=i_7;let _e465=area[_e463];let fg_1=((_e462*_e465)*_e440.alpha);let _e469=i_7;let _e472=blend_mix_compose(bg,fg_1,_e440.blend);rgba[_e469]=_e472;}continuing {let _e474=i_7;i_7=(_e474+1u);}}let _e477=cmd_ix;cmd_ix=(_e477+3u);}case 11u:{let _e480=cmd_ix;let _e484=ptcl[(_e480+1u)];cmd_ix=_e484;}default:{}}}}let xy_uint=vec2<u32>(xy_3);i_8=0u;loop {let _e488=i_8;if (_e488<PIXELS_PER_THREAD) {} else {break;}{let _e491=i_8;let coords=(xy_uint+vec2<u32>(_e491,0u));let _e498=config.target_width;let _e503=config.target_height;if ((coords.x<_e498) && (coords.y<_e503)) {let _e506=i_8;let fg_2=rgba[_e506];let a_inv=(1.0 / max(fg_2.w,9.999999974752427e-7));let rgba_sep=vec4<f32>((fg_2.xyz*a_inv),fg_2.w);textureStore(output,vec2<i32>(coords),rgba_sep);}}continuing {let _e521=i_8;i_8=(_e521+1u);}}return;}\n`;

    return {
      backdrop_dyn: new VelloShader( 'backdrop_dyn', {
        wgsl: 'struct Config {width_in_tiles:u32,height_in_tiles:u32,target_width:u32,target_height:u32,base_color:u32,n_drawobj:u32,n_path:u32,n_clip:u32,bin_data_start:u32,pathtag_base:u32,pathdata_base:u32,drawtag_base:u32,drawdata_base:u32,transform_base:u32,linewidth_base:u32,binning_size:u32,tiles_size:u32,segments_size:u32,ptcl_size:u32,}struct Path {bbox:vec4<u32>,tiles:u32,}struct Tile {backdrop:i32,segments:u32,}const TILE_WIDTH:u32=16u;const TILE_HEIGHT:u32=16u;const N_TILE_X:u32=16u;const N_TILE_Y:u32=16u;const N_TILE:u32=256u;const BLEND_STACK_SPLIT:u32=4u;const RAD_GRAD_KIND_CIRCULAR:u32=1u;const RAD_GRAD_KIND_STRIP:u32=2u;const RAD_GRAD_KIND_FOCAL_ON_CIRCLE:u32=3u;const RAD_GRAD_KIND_CONE:u32=4u;const RAD_GRAD_SWAPPED:u32=1u;const WG_SIZE:u32=256u;@group(0) @binding(0)\nvar<uniform>config:Config;@group(0) @binding(1)\nvar<storage>paths:array<Path>;@group(0) @binding(2)\nvar<storage,read_write>tiles:array<Tile>;var<workgroup>sh_row_width:array<u32,WG_SIZE>;var<workgroup>sh_row_count:array<u32,WG_SIZE>;var<workgroup>sh_offset:array<u32,WG_SIZE>;@compute @workgroup_size(256,1,1)\nfn main(@builtin(global_invocation_id) global_id:vec3<u32>,@builtin(local_invocation_id) local_id:vec3<u32>) {var row_count:u32;var i:u32;var row:u32;var el_ix:u32;var i_1:u32;var seq_ix:u32;var tile_ix:u32;var sum:i32;var x:u32;let drawobj_ix=global_id.x;row_count=0u;let _e7=config.n_drawobj;if (drawobj_ix<_e7) {let path=paths[drawobj_ix];sh_row_width[local_id.x]=(path.bbox.z-path.bbox.x);row_count=(path.bbox.w-path.bbox.y);sh_offset[local_id.x]=path.tiles;}let _e32=row_count;sh_row_count[local_id.x]=_e32;i=0u;loop {let _e35=i;if (_e35<firstTrailingBit(WG_SIZE)) {} else {break;}{workgroupBarrier();let _e41=i;if (local_id.x>=(1u<<_e41)) {let _e47=i;let _e51=sh_row_count[(local_id.x-(1u<<_e47))];let _e52=row_count;row_count=(_e52+_e51);}workgroupBarrier();let _e57=row_count;sh_row_count[local_id.x]=_e57;}continuing {let _e59=i;i=(_e59+1u);}}workgroupBarrier();let total_rows=sh_row_count[(WG_SIZE-1u)];row=local_id.x;loop {let _e69=row;if (_e69<total_rows) {} else {break;}{el_ix=0u;i_1=0u;loop {let _e75=i_1;if (_e75<firstTrailingBit(WG_SIZE)) {} else {break;}{let _e79=el_ix;let _e83=i_1;let probe=(_e79+((WG_SIZE / 2u)>>_e83));let _e86=row;let _e91=sh_row_count[(probe-1u)];if (_e86>=_e91) {el_ix=probe;}}continuing {let _e94=i_1;i_1=(_e94+1u);}}let _e97=el_ix;let width=sh_row_width[_e97];if (width>0u) {let _e102=row;let _e105=el_ix;let _e109=sh_row_count[(_e105-1u)];let _e110=el_ix;seq_ix=(_e102-select(0u,_e109,(_e110>0u)));let _e117=el_ix;let _e119=sh_offset[_e117];let _e120=seq_ix;tile_ix=(_e119+(_e120*width));let _e125=tile_ix;let _e128=tiles[_e125].backdrop;sum=_e128;x=1u;loop {let _e132=x;if (_e132<width) {} else {break;}{let _e135=tile_ix;tile_ix=(_e135+1u);let _e138=tile_ix;let _e141=tiles[_e138].backdrop;let _e142=sum;sum=(_e142+_e141);let _e145=tile_ix;let _e148=sum;tiles[_e145].backdrop=_e148;}continuing {let _e150=x;x=(_e150+1u);}}}}continuing {let _e153=row;row=(_e153+WG_SIZE);}}return;}\n',
        workgroup_size: new WorkgroupSize( 256, 1, 1 ),
        bindings: [ 'Uniform', 'BufReadOnly', 'Buffer' ],
        workgroup_buffers: [
          { size_in_bytes: 1024, index: 0 },
          { size_in_bytes: 1024, index: 1 },
          { size_in_bytes: 1024, index: 2 }
        ]
      }, device ),
      bbox_clear: new VelloShader( 'bbox_clear', {
        wgsl: 'struct Config {width_in_tiles:u32,height_in_tiles:u32,target_width:u32,target_height:u32,base_color:u32,n_drawobj:u32,n_path:u32,n_clip:u32,bin_data_start:u32,pathtag_base:u32,pathdata_base:u32,drawtag_base:u32,drawdata_base:u32,transform_base:u32,linewidth_base:u32,binning_size:u32,tiles_size:u32,segments_size:u32,ptcl_size:u32,}struct PathBbox {x0_:i32,y0_:i32,x1_:i32,y1_:i32,linewidth:f32,trans_ix:u32,}const TILE_WIDTH:u32=16u;const TILE_HEIGHT:u32=16u;const N_TILE_X:u32=16u;const N_TILE_Y:u32=16u;const N_TILE:u32=256u;const BLEND_STACK_SPLIT:u32=4u;const RAD_GRAD_KIND_CIRCULAR:u32=1u;const RAD_GRAD_KIND_STRIP:u32=2u;const RAD_GRAD_KIND_FOCAL_ON_CIRCLE:u32=3u;const RAD_GRAD_KIND_CONE:u32=4u;const RAD_GRAD_SWAPPED:u32=1u;@group(0) @binding(0)\nvar<uniform>config:Config;@group(0) @binding(1)\nvar<storage,read_write>path_bboxes:array<PathBbox>;@compute @workgroup_size(256,1,1)\nfn main(@builtin(global_invocation_id) global_id:vec3<u32>) {let ix=global_id.x;let _e4=config.n_path;if (ix<_e4) {path_bboxes[ix].x0_=2147483647;path_bboxes[ix].y0_=2147483647;path_bboxes[ix].x1_=-2147483648;path_bboxes[ix].y1_=-2147483648;return;} else {return;}}\n',
        workgroup_size: new WorkgroupSize( 256, 1, 1 ),
        bindings: [ 'Uniform', 'Buffer' ],
        workgroup_buffers: []
      }, device ),
      binning: new VelloShader( 'binning', {
        wgsl: 'struct Config {width_in_tiles:u32,height_in_tiles:u32,target_width:u32,target_height:u32,base_color:u32,n_drawobj:u32,n_path:u32,n_clip:u32,bin_data_start:u32,pathtag_base:u32,pathdata_base:u32,drawtag_base:u32,drawdata_base:u32,transform_base:u32,linewidth_base:u32,binning_size:u32,tiles_size:u32,segments_size:u32,ptcl_size:u32,}struct DrawMonoid {path_ix:u32,clip_ix:u32,scene_offset:u32,info_offset:u32,}struct PathBbox {x0_:i32,y0_:i32,x1_:i32,y1_:i32,linewidth:f32,trans_ix:u32,}struct BumpAllocators {failed:atomic<u32>,binning:atomic<u32>,ptcl:atomic<u32>,tile:atomic<u32>,segments:atomic<u32>,blend:atomic<u32>,}struct BinHeader {element_count:u32,chunk_offset:u32,}const TILE_WIDTH:u32=16u;const TILE_HEIGHT:u32=16u;const N_TILE_X:u32=16u;const N_TILE_Y:u32=16u;const N_TILE:u32=256u;const BLEND_STACK_SPLIT:u32=4u;const RAD_GRAD_KIND_CIRCULAR:u32=1u;const RAD_GRAD_KIND_STRIP:u32=2u;const RAD_GRAD_KIND_FOCAL_ON_CIRCLE:u32=3u;const RAD_GRAD_KIND_CONE:u32=4u;const RAD_GRAD_SWAPPED:u32=1u;const DRAWTAG_NOP:u32=0u;const DRAWTAG_FILL_COLOR:u32=68u;const DRAWTAG_FILL_LIN_GRADIENT:u32=276u;const DRAWTAG_FILL_RAD_GRADIENT:u32=668u;const DRAWTAG_FILL_IMAGE:u32=584u;const DRAWTAG_BEGIN_CLIP:u32=9u;const DRAWTAG_END_CLIP:u32=33u;const STAGE_BINNING:u32=1u;const STAGE_TILE_ALLOC:u32=2u;const STAGE_PATH_COARSE:u32=4u;const STAGE_COARSE:u32=8u;const SX:f32=0.00390625;const SY:f32=0.00390625;const WG_SIZE:u32=256u;const N_SLICE:u32=8u;const N_SUBSLICE:u32=4u;@group(0) @binding(0)\nvar<uniform>config:Config;@group(0) @binding(1)\nvar<storage>draw_monoids:array<DrawMonoid>;@group(0) @binding(2)\nvar<storage>path_bbox_buf:array<PathBbox>;@group(0) @binding(3)\nvar<storage>clip_bbox_buf:array<vec4<f32>>;@group(0) @binding(4)\nvar<storage,read_write>intersected_bbox:array<vec4<f32>>;@group(0) @binding(5)\nvar<storage,read_write>bump:BumpAllocators;@group(0) @binding(6)\nvar<storage,read_write>bin_data:array<u32>;@group(0) @binding(7)\nvar<storage,read_write>bin_header:array<BinHeader>;var<workgroup>sh_bitmaps:array<array<atomic<u32>,N_TILE>,N_SLICE>;var<workgroup>sh_count:array<array<u32,N_TILE>,N_SUBSLICE>;var<workgroup>sh_chunk_offset:array<u32,N_TILE>;fn draw_monoid_identity()->DrawMonoid {return DrawMonoid(0u,0u,0u,0u);}fn combine_draw_monoid(a:DrawMonoid,b:DrawMonoid)->DrawMonoid {var c:DrawMonoid;c.path_ix=(a.path_ix+b.path_ix);c.clip_ix=(a.clip_ix+b.clip_ix);c.scene_offset=(a.scene_offset+b.scene_offset);c.info_offset=(a.info_offset+b.info_offset);let _e19=c;return _e19;}fn map_draw_tag(tag_word:u32)->DrawMonoid {var c_1:DrawMonoid;c_1.path_ix=u32((tag_word !=DRAWTAG_NOP));c_1.clip_ix=(tag_word & 1u);c_1.scene_offset=((tag_word>>2u) & 7u);c_1.info_offset=((tag_word>>6u) & 15u);let _e19=c_1;return _e19;}fn bbox_intersect(a_1:vec4<f32>,b_1:vec4<f32>)->vec4<f32>{return vec4<f32>(max(a_1.xy,b_1.xy),min(a_1.zw,b_1.zw));}@compute @workgroup_size(256,1,1)\nfn main(@builtin(global_invocation_id) global_id:vec3<u32>,@builtin(local_invocation_id) local_id:vec3<u32>,@builtin(workgroup_id) wg_id:vec3<u32>) {var i:u32;var x0_:i32;var y0_:i32;var x1_:i32;var y1_:i32;var clip_bbox:vec4<f32>;var x:i32;var y:i32;var element_count:u32;var i_1:u32;var chunk_offset:u32;var idx:u32;i=0u;loop {let _e5=i;if (_e5<N_SLICE) {} else {break;}{let _e9=i;atomicStore((&sh_bitmaps[_e9][local_id.x]),0u);}continuing {let _e15=i;i=(_e15+1u);}}workgroupBarrier();let element_ix=global_id.x;x0_=0;y0_=0;x1_=0;y1_=0;let _e28=config.n_drawobj;if (element_ix<_e28) {let draw_monoid=draw_monoids[element_ix];clip_bbox=vec4<f32>(-1000000000.0,-1000000000.0,1000000000.0,1000000000.0);if (draw_monoid.clip_ix>0u) {let _e47=clip_bbox_buf[(draw_monoid.clip_ix-1u)];clip_bbox=_e47;}let path_bbox=path_bbox_buf[draw_monoid.path_ix];let pb=vec4<f32>(vec4<i32>(path_bbox.x0_,path_bbox.y0_,path_bbox.x1_,path_bbox.y1_));let _e58=clip_bbox;let _e59=bbox_intersect(_e58,pb);let bbox=vec4<f32>(_e59.xy,max(_e59.xy,_e59.zw));intersected_bbox[element_ix]=bbox;x0_=i32(floor((bbox.x*SX)));y0_=i32(floor((bbox.y*SY)));x1_=i32(ceil((bbox.z*SX)));y1_=i32(ceil((bbox.w*SY)));}let _e89=config.width_in_tiles;let width_in_bins=i32((((_e89+N_TILE_X)-1u) / N_TILE_X));let _e99=config.height_in_tiles;let height_in_bins=i32((((_e99+N_TILE_Y)-1u) / N_TILE_Y));let _e107=x0_;x0_=clamp(_e107,0,width_in_bins);let _e110=y0_;y0_=clamp(_e110,0,height_in_bins);let _e113=x1_;x1_=clamp(_e113,0,width_in_bins);let _e116=y1_;y1_=clamp(_e116,0,height_in_bins);let _e119=x0_;let _e120=x1_;if (_e119==_e120) {let _e122=y0_;y1_=_e122;}let _e123=x0_;x=_e123;let _e125=y0_;y=_e125;let my_slice=(local_id.x / 32u);let my_mask=(1u<<(local_id.x & 31u));loop {let _e135=y;let _e136=y1_;if (_e135<_e136) {} else {break;}{let _e140=y;let _e142=x;let _e145=atomicOr((&sh_bitmaps[my_slice][((_e140*width_in_bins)+_e142)]),my_mask);let _e147=x;x=(_e147+1);let _e149=x;let _e150=x1_;if (_e149==_e150) {let _e152=x0_;x=_e152;let _e154=y;y=(_e154+1);}}}workgroupBarrier();element_count=0u;i_1=0u;loop {let _e160=i_1;if (_e160<N_SUBSLICE) {} else {break;}{let _e164=i_1;let _e170=atomicLoad((&sh_bitmaps[(_e164*2u)][local_id.x]));let _e172=element_count;element_count=(_e172+countOneBits(_e170));let element_count_lo=element_count;let _e176=i_1;let _e184=atomicLoad((&sh_bitmaps[((_e176*2u)+1u)][local_id.x]));let _e186=element_count;element_count=(_e186+countOneBits(_e184));let element_count_hi=element_count;let element_count_packed=(element_count_lo | (element_count_hi<<16u));let _e193=i_1;sh_count[_e193][local_id.x]=element_count_packed;}continuing {let _e198=i_1;i_1=(_e198+1u);}}let _e202=element_count;let _e203=atomicAdd((&bump.binning),_e202);chunk_offset=_e203;let _e205=chunk_offset;let _e206=element_count;let _e210=config.binning_size;if ((_e205+_e206)>_e210) {chunk_offset=0u;let _e216=atomicOr((&bump.failed),STAGE_BINNING);}let _e220=chunk_offset;sh_chunk_offset[local_id.x]=_e220;let _e225=element_count;bin_header[global_id.x].element_count=_e225;let _e230=chunk_offset;bin_header[global_id.x].chunk_offset=_e230;workgroupBarrier();let _e231=x0_;x=_e231;let _e232=y0_;y=_e232;loop {let _e233=y;let _e234=y1_;if (_e233<_e234) {} else {break;}{let _e236=y;let _e238=x;let bin_ix=((_e236*width_in_bins)+_e238);let out_mask=atomicLoad((&sh_bitmaps[my_slice][bin_ix]));if ((out_mask & my_mask) !=0u) {idx=countOneBits((out_mask & (my_mask-1u)));if (my_slice>0u) {let count_ix=(my_slice-1u);let count_packed=sh_count[(count_ix / 2u)][bin_ix];let _e269=idx;idx=(_e269+((count_packed>>(16u*(count_ix & 1u))) & 65535u));}let _e273=config.bin_data_start;let _e276=sh_chunk_offset[bin_ix];let offset=(_e273+_e276);let _e279=idx;bin_data[(offset+_e279)]=element_ix;}let _e283=x;x=(_e283+1);let _e285=x;let _e286=x1_;if (_e285==_e286) {let _e288=x0_;x=_e288;let _e290=y;y=(_e290+1);}}}return;}\n',
        workgroup_size: new WorkgroupSize( 256, 1, 1 ),
        bindings: [ 'Uniform', 'BufReadOnly', 'BufReadOnly', 'BufReadOnly', 'Buffer', 'Buffer', 'Buffer', 'Buffer' ],
        workgroup_buffers: [
          { size_in_bytes: 8192, index: 0 },
          { size_in_bytes: 4096, index: 1 },
          { size_in_bytes: 1024, index: 2 }
        ]
      }, device ),
      clip_leaf: new VelloShader( 'clip_leaf', {
        wgsl: 'struct Config {width_in_tiles:u32,height_in_tiles:u32,target_width:u32,target_height:u32,base_color:u32,n_drawobj:u32,n_path:u32,n_clip:u32,bin_data_start:u32,pathtag_base:u32,pathdata_base:u32,drawtag_base:u32,drawdata_base:u32,transform_base:u32,linewidth_base:u32,binning_size:u32,tiles_size:u32,segments_size:u32,ptcl_size:u32,}struct PathBbox {x0_:i32,y0_:i32,x1_:i32,y1_:i32,linewidth:f32,trans_ix:u32,}struct Bic {a:u32,b:u32,}struct ClipInp {ix:u32,path_ix:i32,}struct ClipEl {parent_ix:u32,bbox:vec4<f32>,}struct DrawMonoid {path_ix:u32,clip_ix:u32,scene_offset:u32,info_offset:u32,}const TILE_WIDTH:u32=16u;const TILE_HEIGHT:u32=16u;const N_TILE_X:u32=16u;const N_TILE_Y:u32=16u;const N_TILE:u32=256u;const BLEND_STACK_SPLIT:u32=4u;const RAD_GRAD_KIND_CIRCULAR:u32=1u;const RAD_GRAD_KIND_STRIP:u32=2u;const RAD_GRAD_KIND_FOCAL_ON_CIRCLE:u32=3u;const RAD_GRAD_KIND_CONE:u32=4u;const RAD_GRAD_SWAPPED:u32=1u;const DRAWTAG_NOP:u32=0u;const DRAWTAG_FILL_COLOR:u32=68u;const DRAWTAG_FILL_LIN_GRADIENT:u32=276u;const DRAWTAG_FILL_RAD_GRADIENT:u32=668u;const DRAWTAG_FILL_IMAGE:u32=584u;const DRAWTAG_BEGIN_CLIP:u32=9u;const DRAWTAG_END_CLIP:u32=33u;const WG_SIZE:u32=256u;@group(0) @binding(0)\nvar<uniform>config:Config;@group(0) @binding(1)\nvar<storage>clip_inp:array<ClipInp>;@group(0) @binding(2)\nvar<storage>path_bboxes:array<PathBbox>;@group(0) @binding(3)\nvar<storage>reduced:array<Bic>;@group(0) @binding(4)\nvar<storage>clip_els:array<ClipEl>;@group(0) @binding(5)\nvar<storage,read_write>draw_monoids:array<DrawMonoid>;@group(0) @binding(6)\nvar<storage,read_write>clip_bboxes:array<vec4<f32>>;var<workgroup>sh_bic:array<Bic,510>;var<workgroup>sh_stack:array<u32,WG_SIZE>;var<workgroup>sh_stack_bbox:array<vec4<f32>,WG_SIZE>;var<workgroup>sh_bbox:array<vec4<f32>,WG_SIZE>;var<workgroup>sh_link:array<i32,WG_SIZE>;fn bbox_intersect(a:vec4<f32>,b:vec4<f32>)->vec4<f32>{return vec4<f32>(max(a.xy,b.xy),min(a.zw,b.zw));}fn bic_combine(x:Bic,y:Bic)->Bic {let m=min(x.b,y.a);return Bic(((x.a+y.a)-m),((x.b+y.b)-m));}fn draw_monoid_identity()->DrawMonoid {return DrawMonoid(0u,0u,0u,0u);}fn combine_draw_monoid(a_1:DrawMonoid,b_1:DrawMonoid)->DrawMonoid {var c:DrawMonoid;c.path_ix=(a_1.path_ix+b_1.path_ix);c.clip_ix=(a_1.clip_ix+b_1.clip_ix);c.scene_offset=(a_1.scene_offset+b_1.scene_offset);c.info_offset=(a_1.info_offset+b_1.info_offset);let _e19=c;return _e19;}fn map_draw_tag(tag_word:u32)->DrawMonoid {var c_1:DrawMonoid;c_1.path_ix=u32((tag_word !=DRAWTAG_NOP));c_1.clip_ix=(tag_word & 1u);c_1.scene_offset=((tag_word>>2u) & 7u);c_1.info_offset=((tag_word>>6u) & 15u);let _e19=c_1;return _e19;}fn search_link(bic_1:ptr<function,Bic>,ix_in:u32)->i32 {var ix_1:u32;var j:u32;ix_1=ix_in;j=0u;loop {let _e5=j;if (_e5<firstTrailingBit(WG_SIZE)) {} else {break;}{let _e15=j;let base=((2u*WG_SIZE)-(2u<<(firstTrailingBit(WG_SIZE)-_e15)));let _e19=ix_1;let _e20=j;if (((_e19>>_e20) & 1u) !=0u) {let _e27=ix_1;let _e28=j;let _e34=sh_bic[((base+(_e27>>_e28))-1u)];let _e35=(*bic_1);let _e36=bic_combine(_e34,_e35);if (_e36.b>0u) {break;}(*bic_1)=_e36;let _e41=j;let _e43=ix_1;ix_1=(_e43-(1u<<_e41));}let _e46=j;j=(_e46+1u);}}let _e48=ix_1;if (_e48>0u) {loop {let _e51=j;if (_e51>0u) {} else {break;}{let _e55=j;j=(_e55-1u);let _e63=j;let base_1=((2u*WG_SIZE)-(2u<<(firstTrailingBit(WG_SIZE)-_e63)));let _e68=ix_1;let _e69=j;let _e75=sh_bic[((base_1+(_e68>>_e69))-1u)];let _e76=(*bic_1);let _e77=bic_combine(_e75,_e76);if (_e77.b==0u) {(*bic_1)=_e77;let _e82=j;let _e84=ix_1;ix_1=(_e84-(1u<<_e82));}}}}let _e86=ix_1;if (_e86>0u) {let _e89=ix_1;return (i32(_e89)-1);} else {let _e96=(*bic_1).a;return i32((~(0u)-_e96));}}fn load_clip_path(ix_2:u32)->i32 {let _e3=config.n_clip;if (ix_2<_e3) {let _e8=clip_inp[ix_2].path_ix;return _e8;} else {return-2147483648;}}@compute @workgroup_size(256,1,1)\nfn main(@builtin(global_invocation_id) global_id:vec3<u32>,@builtin(local_invocation_id) local_id:vec3<u32>,@builtin(workgroup_id) wg_id:vec3<u32>) {var bic:Bic;var i:u32;var ix:u32;var i_1:u32;var bbox:vec4<f32>;var i_2:u32;var inbase:u32;var i_3:u32;var link:i32;var parent:i32;var i_4:u32;if (local_id.x<wg_id.x) {let _e10=reduced[local_id.x];bic=_e10;}let _e14=bic;sh_bic[local_id.x]=_e14;i=0u;loop {let _e17=i;if (_e17<firstTrailingBit(WG_SIZE)) {} else {break;}{workgroupBarrier();let _e23=i;if ((local_id.x+(1u<<_e23))<WG_SIZE) {let _e31=i;let other=sh_bic[(local_id.x+(1u<<_e31))];let _e36=bic;let _e37=bic_combine(_e36,other);bic=_e37;}workgroupBarrier();let _e41=bic;sh_bic[local_id.x]=_e41;}continuing {let _e43=i;i=(_e43+1u);}}workgroupBarrier();let stack_size=sh_bic[0].b;let sp=((WG_SIZE-1u)-local_id.x);ix=0u;i_1=0u;loop {let _e59=i_1;if (_e59<firstTrailingBit(WG_SIZE)) {} else {break;}{let _e63=ix;let _e67=i_1;let probe=(_e63+((WG_SIZE / 2u)>>_e67));let _e73=sh_bic[probe].b;if (sp<_e73) {ix=probe;}}continuing {let _e76=i_1;i_1=(_e76+1u);}}let _e79=ix;let b_2=sh_bic[_e79].b;bbox=vec4<f32>(-1000000000.0,-1000000000.0,1000000000.0,1000000000.0);if (sp<b_2) {let _e91=ix;let el=clip_els[((((_e91*WG_SIZE)+b_2)-sp)-1u)];sh_stack[local_id.x]=el.parent_ix;bbox=el.bbox;}i_2=0u;loop {let _e107=i_2;if (_e107<firstTrailingBit(WG_SIZE)) {} else {break;}{let _e114=bbox;sh_stack_bbox[local_id.x]=_e114;workgroupBarrier();let _e117=i_2;if (local_id.x>=(1u<<_e117)) {let _e123=i_2;let _e127=sh_stack_bbox[(local_id.x-(1u<<_e123))];let _e128=bbox;let _e129=bbox_intersect(_e127,_e128);bbox=_e129;}workgroupBarrier();}continuing {let _e131=i_2;i_2=(_e131+1u);}}let _e136=bbox;sh_stack_bbox[local_id.x]=_e136;let _e138=load_clip_path(global_id.x);let is_push=(_e138>=0);bic=Bic((1u-u32(is_push)),u32(is_push));let _e149=bic;sh_bic[local_id.x]=_e149;if is_push {let path_bbox=path_bboxes[_e138];bbox=vec4<f32>(f32(path_bbox.x0_),f32(path_bbox.y0_),f32(path_bbox.x1_),f32(path_bbox.y1_));} else {bbox=vec4<f32>(-1000000000.0,-1000000000.0,1000000000.0,1000000000.0);}inbase=0u;i_3=0u;loop {let _e171=i_3;if (_e171<(firstTrailingBit(WG_SIZE)-1u)) {} else {break;}{let _e183=i_3;let outbase=((2u*WG_SIZE)-(1u<<(firstTrailingBit(WG_SIZE)-_e183)));workgroupBarrier();let _e193=i_3;if (local_id.x<(1u<<((firstTrailingBit(WG_SIZE)-1u)-_e193))) {let _e197=inbase;let in_off=(_e197+(local_id.x*2u));let _e208=sh_bic[in_off];let _e213=sh_bic[(in_off+1u)];let _e214=bic_combine(_e208,_e213);sh_bic[(outbase+local_id.x)]=_e214;}inbase=outbase;}continuing {let _e216=i_3;i_3=(_e216+1u);}}workgroupBarrier();bic=Bic(0u,0u);let _e220=search_link((&bic),local_id.x);link=_e220;let _e225=link;sh_link[local_id.x]=_e225;workgroupBarrier();let _e226=link;let _e230=link;let _e232=sh_link[_e230];let _e233=link;let grandparent=select((_e226-1),_e232,(_e233>=0));let _e238=link;if (_e238>=0) {let _e245=link;parent=(i32((wg_id.x*WG_SIZE))+_e245);} else {let _e247=link;if ((_e247+i32(stack_size))>=0) {let _e255=link;let _e258=sh_stack[(i32(WG_SIZE)+_e255)];parent=i32(_e258);} else {parent=-1;}}i_4=0u;loop {let _e263=i_4;if (_e263<firstTrailingBit(WG_SIZE)) {} else {break;}{let _e267=i_4;if (_e267 !=0u) {let _e273=link;sh_link[local_id.x]=_e273;}let _e277=bbox;sh_bbox[local_id.x]=_e277;workgroupBarrier();let _e278=link;if (_e278>=0) {let _e282=link;let _e284=sh_bbox[_e282];let _e285=bbox;let _e286=bbox_intersect(_e284,_e285);bbox=_e286;let _e288=link;let _e290=sh_link[_e288];link=_e290;}workgroupBarrier();}continuing {let _e292=i_4;i_4=(_e292+1u);}}let _e294=link;if ((_e294+i32(stack_size))>=0) {let _e302=link;let _e305=sh_stack_bbox[(i32(WG_SIZE)+_e302)];let _e306=bbox;let _e307=bbox_intersect(_e305,_e306);bbox=_e307;}let _e311=bbox;sh_bbox[local_id.x]=_e311;workgroupBarrier();let _e316=config.n_clip;if (!(is_push) && (global_id.x<_e316)) {let _e320=parent;let parent_clip=clip_inp[_e320];let path_ix=parent_clip.path_ix;let parent_ix=parent_clip.ix;let ix_3=~(_e138);draw_monoids[ix_3].path_ix=u32(path_ix);let _e336=draw_monoids[parent_ix].scene_offset;draw_monoids[ix_3].scene_offset=_e336;if (grandparent>=0) {let _e341=sh_bbox[grandparent];bbox=_e341;} else {if ((grandparent+i32(stack_size))>=0) {let _e351=sh_stack_bbox[(i32(WG_SIZE)+grandparent)];bbox=_e351;} else {bbox=vec4<f32>(-1000000000.0,-1000000000.0,1000000000.0,1000000000.0);}}}let _e360=config.n_clip;if (global_id.x<_e360) {let _e365=bbox;clip_bboxes[global_id.x]=_e365;return;} else {return;}}\n',
        workgroup_size: new WorkgroupSize( 256, 1, 1 ),
        bindings: [ 'Uniform', 'BufReadOnly', 'BufReadOnly', 'BufReadOnly', 'BufReadOnly', 'Buffer', 'Buffer' ],
        workgroup_buffers: [
          { size_in_bytes: 4080, index: 0 },
          { size_in_bytes: 1024, index: 1 },
          { size_in_bytes: 4096, index: 2 },
          { size_in_bytes: 4096, index: 3 },
          { size_in_bytes: 1024, index: 4 }
        ]
      }, device ),
      clip_reduce: new VelloShader( 'clip_reduce', {
        wgsl: 'struct Config {width_in_tiles:u32,height_in_tiles:u32,target_width:u32,target_height:u32,base_color:u32,n_drawobj:u32,n_path:u32,n_clip:u32,bin_data_start:u32,pathtag_base:u32,pathdata_base:u32,drawtag_base:u32,drawdata_base:u32,transform_base:u32,linewidth_base:u32,binning_size:u32,tiles_size:u32,segments_size:u32,ptcl_size:u32,}struct PathBbox {x0_:i32,y0_:i32,x1_:i32,y1_:i32,linewidth:f32,trans_ix:u32,}struct Bic {a:u32,b:u32,}struct ClipInp {ix:u32,path_ix:i32,}struct ClipEl {parent_ix:u32,bbox:vec4<f32>,}const TILE_WIDTH:u32=16u;const TILE_HEIGHT:u32=16u;const N_TILE_X:u32=16u;const N_TILE_Y:u32=16u;const N_TILE:u32=256u;const BLEND_STACK_SPLIT:u32=4u;const RAD_GRAD_KIND_CIRCULAR:u32=1u;const RAD_GRAD_KIND_STRIP:u32=2u;const RAD_GRAD_KIND_FOCAL_ON_CIRCLE:u32=3u;const RAD_GRAD_KIND_CONE:u32=4u;const RAD_GRAD_SWAPPED:u32=1u;const WG_SIZE:u32=256u;@group(0) @binding(0)\nvar<uniform>config:Config;@group(0) @binding(1)\nvar<storage>clip_inp:array<ClipInp>;@group(0) @binding(2)\nvar<storage>path_bboxes:array<PathBbox>;@group(0) @binding(3)\nvar<storage,read_write>reduced:array<Bic>;@group(0) @binding(4)\nvar<storage,read_write>clip_out:array<ClipEl>;var<workgroup>sh_bic:array<Bic,WG_SIZE>;var<workgroup>sh_parent:array<u32,WG_SIZE>;var<workgroup>sh_path_ix:array<u32,WG_SIZE>;fn bbox_intersect(a:vec4<f32>,b:vec4<f32>)->vec4<f32>{return vec4<f32>(max(a.xy,b.xy),min(a.zw,b.zw));}fn bic_combine(x:Bic,y:Bic)->Bic {let m=min(x.b,y.a);return Bic(((x.a+y.a)-m),((x.b+y.b)-m));}@compute @workgroup_size(256,1,1)\nfn main(@builtin(global_invocation_id) global_id:vec3<u32>,@builtin(local_invocation_id) local_id:vec3<u32>,@builtin(workgroup_id) wg_id:vec3<u32>) {var bic:Bic;var i:u32;let inp=clip_inp[global_id.x].path_ix;let is_push=(inp>=0);bic=Bic((1u-u32(is_push)),u32(is_push));let _e19=bic;sh_bic[local_id.x]=_e19;i=0u;loop {let _e22=i;if (_e22<firstTrailingBit(WG_SIZE)) {} else {break;}{workgroupBarrier();let _e28=i;if ((local_id.x+(1u<<_e28))<WG_SIZE) {let _e36=i;let other=sh_bic[(local_id.x+(1u<<_e36))];let _e41=bic;let _e42=bic_combine(_e41,other);bic=_e42;}workgroupBarrier();let _e46=bic;sh_bic[local_id.x]=_e46;}continuing {let _e48=i;i=(_e48+1u);}}if (local_id.x==0u) {let _e56=bic;reduced[wg_id.x]=_e56;}workgroupBarrier();let size=sh_bic[0].b;bic=Bic(0u,0u);let _e64=bic.a;if (is_push && (_e64==0u)) {let _e69=bic.b;let local_ix=((size-_e69)-1u);sh_parent[local_ix]=local_id.x;sh_path_ix[local_ix]=u32(inp);}workgroupBarrier();if (local_id.x<size) {let path_ix=sh_path_ix[local_id.x];let path_bbox=path_bboxes[path_ix];let _e91=sh_parent[local_id.x];let parent_ix=(_e91+(wg_id.x*WG_SIZE));let bbox=vec4<f32>(f32(path_bbox.x0_),f32(path_bbox.y0_),f32(path_bbox.x1_),f32(path_bbox.y1_));clip_out[global_id.x]=ClipEl(parent_ix,bbox);return;} else {return;}}\n',
        workgroup_size: new WorkgroupSize( 256, 1, 1 ),
        bindings: [ 'Uniform', 'BufReadOnly', 'BufReadOnly', 'Buffer', 'Buffer' ],
        workgroup_buffers: [
          { size_in_bytes: 2048, index: 0 },
          { size_in_bytes: 1024, index: 1 },
          { size_in_bytes: 1024, index: 2 }
        ]
      }, device ),
      coarse: new VelloShader( 'coarse', {
        wgsl: 'struct Config {width_in_tiles:u32,height_in_tiles:u32,target_width:u32,target_height:u32,base_color:u32,n_drawobj:u32,n_path:u32,n_clip:u32,bin_data_start:u32,pathtag_base:u32,pathdata_base:u32,drawtag_base:u32,drawdata_base:u32,transform_base:u32,linewidth_base:u32,binning_size:u32,tiles_size:u32,segments_size:u32,ptcl_size:u32,}struct BumpAllocators {failed:atomic<u32>,binning:atomic<u32>,ptcl:atomic<u32>,tile:atomic<u32>,segments:atomic<u32>,blend:atomic<u32>,}struct DrawMonoid {path_ix:u32,clip_ix:u32,scene_offset:u32,info_offset:u32,}struct CmdFill {tile:u32,backdrop:i32,}struct CmdStroke {tile:u32,half_width:f32,}struct CmdJump {new_ix:u32,}struct CmdColor {rgba_color:u32,}struct CmdLinGrad {index:u32,extend_mode:u32,line_x:f32,line_y:f32,line_c:f32,}struct CmdRadGrad {index:u32,extend_mode:u32,matrx:vec4<f32>,xlat:vec2<f32>,focal_x:f32,radius:f32,kind:u32,flags:u32,}struct CmdImage {matrx:vec4<f32>,xlat:vec2<f32>,atlas_offset:vec2<f32>,extents:vec2<f32>,}struct CmdEndClip {blend:u32,alpha:f32,}struct Path {bbox:vec4<u32>,tiles:u32,}struct Tile {backdrop:i32,segments:u32,}struct BinHeader {element_count:u32,chunk_offset:u32,}const TILE_WIDTH:u32=16u;const TILE_HEIGHT:u32=16u;const N_TILE_X:u32=16u;const N_TILE_Y:u32=16u;const N_TILE:u32=256u;const BLEND_STACK_SPLIT:u32=4u;const RAD_GRAD_KIND_CIRCULAR:u32=1u;const RAD_GRAD_KIND_STRIP:u32=2u;const RAD_GRAD_KIND_FOCAL_ON_CIRCLE:u32=3u;const RAD_GRAD_KIND_CONE:u32=4u;const RAD_GRAD_SWAPPED:u32=1u;const STAGE_BINNING:u32=1u;const STAGE_TILE_ALLOC:u32=2u;const STAGE_PATH_COARSE:u32=4u;const STAGE_COARSE:u32=8u;const DRAWTAG_NOP:u32=0u;const DRAWTAG_FILL_COLOR:u32=68u;const DRAWTAG_FILL_LIN_GRADIENT:u32=276u;const DRAWTAG_FILL_RAD_GRADIENT:u32=668u;const DRAWTAG_FILL_IMAGE:u32=584u;const DRAWTAG_BEGIN_CLIP:u32=9u;const DRAWTAG_END_CLIP:u32=33u;const PTCL_INITIAL_ALLOC:u32=64u;const PTCL_INCREMENT:u32=256u;const PTCL_HEADROOM:u32=2u;const CMD_END:u32=0u;const CMD_FILL:u32=1u;const CMD_STROKE:u32=2u;const CMD_SOLID:u32=3u;const CMD_COLOR:u32=5u;const CMD_LIN_GRAD:u32=6u;const CMD_RAD_GRAD:u32=7u;const CMD_IMAGE:u32=8u;const CMD_BEGIN_CLIP:u32=9u;const CMD_END_CLIP:u32=10u;const CMD_JUMP:u32=11u;const WG_SIZE:u32=256u;const N_SLICE:u32=8u;@group(0) @binding(0)\nvar<uniform>config:Config;@group(0) @binding(1)\nvar<storage>scene:array<u32>;@group(0) @binding(2)\nvar<storage>draw_monoids:array<DrawMonoid>;@group(0) @binding(3)\nvar<storage>bin_headers:array<BinHeader>;@group(0) @binding(4)\nvar<storage>info_bin_data:array<u32>;@group(0) @binding(5)\nvar<storage>paths:array<Path>;@group(0) @binding(6)\nvar<storage>tiles:array<Tile>;@group(0) @binding(7)\nvar<storage,read_write>bump:BumpAllocators;@group(0) @binding(8)\nvar<storage,read_write>ptcl:array<u32>;var<workgroup>sh_bitmaps:array<array<atomic<u32>,N_TILE>,N_SLICE>;var<workgroup>sh_part_count:array<u32,WG_SIZE>;var<workgroup>sh_part_offsets:array<u32,WG_SIZE>;var<workgroup>sh_drawobj_ix:array<u32,WG_SIZE>;var<workgroup>sh_tile_stride:array<u32,WG_SIZE>;var<workgroup>sh_tile_width:array<u32,WG_SIZE>;var<workgroup>sh_tile_x0y0_:array<u32,WG_SIZE>;var<workgroup>sh_tile_count:array<u32,WG_SIZE>;var<workgroup>sh_tile_base:array<u32,WG_SIZE>;var<private>cmd_offset:u32;var<private>cmd_limit:u32;fn draw_monoid_identity()->DrawMonoid {return DrawMonoid(0u,0u,0u,0u);}fn combine_draw_monoid(a:DrawMonoid,b:DrawMonoid)->DrawMonoid {var c:DrawMonoid;c.path_ix=(a.path_ix+b.path_ix);c.clip_ix=(a.clip_ix+b.clip_ix);c.scene_offset=(a.scene_offset+b.scene_offset);c.info_offset=(a.info_offset+b.info_offset);let _e19=c;return _e19;}fn map_draw_tag(tag_word:u32)->DrawMonoid {var c_1:DrawMonoid;c_1.path_ix=u32((tag_word !=DRAWTAG_NOP));c_1.clip_ix=(tag_word & 1u);c_1.scene_offset=((tag_word>>2u) & 7u);c_1.info_offset=((tag_word>>6u) & 15u);let _e19=c_1;return _e19;}fn alloc_cmd(size:u32) {var new_cmd:u32;let _e2=cmd_offset;let _e5=cmd_limit;if ((_e2+size)>=_e5) {let _e9=config.width_in_tiles;let _e12=config.height_in_tiles;let ptcl_dyn_start=((_e9*_e12)*PTCL_INITIAL_ALLOC);let _e19=atomicAdd((&bump.ptcl),PTCL_INCREMENT);new_cmd=(ptcl_dyn_start+_e19);let _e22=new_cmd;let _e27=config.ptcl_size;if ((_e22+PTCL_INCREMENT)>_e27) {new_cmd=0u;let _e33=atomicOr((&bump.failed),STAGE_COARSE);}let _e36=cmd_offset;ptcl[_e36]=CMD_JUMP;let _e41=cmd_offset;let _e45=new_cmd;ptcl[(_e41+1u)]=_e45;let _e47=new_cmd;cmd_offset=_e47;let _e50=cmd_offset;cmd_limit=(_e50+(PTCL_INCREMENT-PTCL_HEADROOM));return;} else {return;}}fn write_path(tile:Tile,linewidth:f32)->bool {alloc_cmd(3u);if (linewidth<0.0) {let even_odd=(linewidth<-1.0);if (tile.segments !=0u) {let fill=CmdFill(tile.segments,tile.backdrop);let _e15=cmd_offset;ptcl[_e15]=CMD_FILL;let segments_and_rule=select((fill.tile<<1u),((fill.tile<<1u) | 1u),even_odd);let _e29=cmd_offset;ptcl[(_e29+1u)]=segments_and_rule;let _e35=cmd_offset;ptcl[(_e35+2u)]=u32(fill.backdrop);let _e43=cmd_offset;cmd_offset=(_e43+3u);} else {if (even_odd && ((abs(tile.backdrop) & 1)==0)) {return false;}let _e55=cmd_offset;ptcl[_e55]=CMD_SOLID;let _e60=cmd_offset;cmd_offset=(_e60+1u);}} else {let stroke=CmdStroke(tile.segments,(0.5*linewidth));let _e68=cmd_offset;ptcl[_e68]=CMD_STROKE;let _e73=cmd_offset;ptcl[(_e73+1u)]=stroke.tile;let _e80=cmd_offset;ptcl[(_e80+2u)]=bitcast<u32>(stroke.half_width);let _e88=cmd_offset;cmd_offset=(_e88+3u);}return true;}fn write_color(color:CmdColor) {alloc_cmd(2u);let _e4=cmd_offset;ptcl[_e4]=CMD_COLOR;let _e9=cmd_offset;ptcl[(_e9+1u)]=color.rgba_color;let _e16=cmd_offset;cmd_offset=(_e16+2u);return;}fn write_grad(ty:u32,index:u32,info_offset:u32) {alloc_cmd(3u);let _e6=cmd_offset;ptcl[_e6]=ty;let _e10=cmd_offset;ptcl[(_e10+1u)]=index;let _e16=cmd_offset;ptcl[(_e16+2u)]=info_offset;let _e22=cmd_offset;cmd_offset=(_e22+3u);return;}fn write_image(info_offset_1:u32) {alloc_cmd(2u);let _e4=cmd_offset;ptcl[_e4]=CMD_IMAGE;let _e9=cmd_offset;ptcl[(_e9+1u)]=info_offset_1;let _e15=cmd_offset;cmd_offset=(_e15+2u);return;}fn write_begin_clip() {alloc_cmd(1u);let _e3=cmd_offset;ptcl[_e3]=CMD_BEGIN_CLIP;let _e8=cmd_offset;cmd_offset=(_e8+1u);return;}fn write_end_clip(end_clip:CmdEndClip) {alloc_cmd(3u);let _e4=cmd_offset;ptcl[_e4]=CMD_END_CLIP;let _e9=cmd_offset;ptcl[(_e9+1u)]=end_clip.blend;let _e16=cmd_offset;ptcl[(_e16+2u)]=bitcast<u32>(end_clip.alpha);let _e24=cmd_offset;cmd_offset=(_e24+3u);return;}@compute @workgroup_size(256,1,1)\nfn main(@builtin(local_invocation_id) local_id:vec3<u32>,@builtin(workgroup_id) wg_id:vec3<u32>) {var clip_zero_depth:u32;var clip_depth:u32;var partition_ix:u32;var rd_ix:u32;var wr_ix:u32;var part_start_ix:u32;var ready_ix:u32;var render_blend_depth:u32;var max_blend_depth:u32;var i:u32;var count:u32;var i_1:u32;var ix:u32;var part_ix:u32;var i_2:u32;var tag:u32;var drawobj_ix:u32;var tile_count:u32;var i_3:u32;var ix_1:u32;var el_ix:u32;var i_4:u32;var is_blend:bool;var slice_ix:u32;var bitmap:u32;let failed=atomicLoad((&bump.failed));if ((failed & ((STAGE_BINNING | STAGE_TILE_ALLOC) | STAGE_PATH_COARSE)) !=0u) {return;}let _e15=config.width_in_tiles;let width_in_bins=(((_e15+N_TILE_X)-1u) / N_TILE_X);let bin_ix=((width_in_bins*wg_id.y)+wg_id.x);let _e28=config.n_drawobj;let n_partitions=(((_e28+N_TILE)-1u) / N_TILE);let bin_tile_x=(N_TILE_X*wg_id.x);let bin_tile_y=(N_TILE_Y*wg_id.y);let tile_x=(local_id.x % N_TILE_X);let tile_y=(local_id.x / N_TILE_X);let _e50=config.width_in_tiles;let this_tile_ix=((((bin_tile_y+tile_y)*_e50)+bin_tile_x)+tile_x);cmd_offset=(this_tile_ix*PTCL_INITIAL_ALLOC);let _e59=cmd_offset;cmd_limit=(_e59+(PTCL_INITIAL_ALLOC-PTCL_HEADROOM));clip_zero_depth=0u;clip_depth=0u;partition_ix=0u;rd_ix=0u;wr_ix=0u;part_start_ix=0u;ready_ix=0u;render_blend_depth=0u;max_blend_depth=0u;let blend_offset=cmd_offset;let _e86=cmd_offset;cmd_offset=(_e86+1u);loop {if true {} else {break;}{i=0u;loop {let _e91=i;if (_e91<N_SLICE) {} else {break;}{let _e95=i;atomicStore((&sh_bitmaps[_e95][local_id.x]),0u);}continuing {let _e101=i;i=(_e101+1u);}}loop {if true {} else {break;}{let _e104=ready_ix;let _e105=wr_ix;let _e107=partition_ix;if ((_e104==_e105) && (_e107<n_partitions)) {let _e110=ready_ix;part_start_ix=_e110;count=0u;let _e113=partition_ix;if ((_e113+local_id.x)<n_partitions) {let _e117=partition_ix;let in_ix=(((_e117+local_id.x)*N_TILE)+bin_ix);let bin_header=bin_headers[in_ix];count=bin_header.element_count;sh_part_offsets[local_id.x]=bin_header.chunk_offset;}i_1=0u;loop {let _e133=i_1;if (_e133<firstTrailingBit(WG_SIZE)) {} else {break;}{let _e140=count;sh_part_count[local_id.x]=_e140;workgroupBarrier();let _e143=i_1;if (local_id.x>=(1u<<_e143)) {let _e149=i_1;let _e153=sh_part_count[(local_id.x-(1u<<_e149))];let _e154=count;count=(_e154+_e153);}workgroupBarrier();}continuing {let _e157=i_1;i_1=(_e157+1u);}}let _e162=part_start_ix;let _e163=count;sh_part_count[local_id.x]=(_e162+_e163);workgroupBarrier();let _e170=sh_part_count[(WG_SIZE-1u)];ready_ix=_e170;let _e172=partition_ix;partition_ix=(_e172+WG_SIZE);}let _e174=rd_ix;ix=(_e174+local_id.x);let _e178=ix;let _e179=wr_ix;let _e181=ix;let _e182=ready_ix;if ((_e178>=_e179) && (_e181<_e182)) {part_ix=0u;i_2=0u;loop {let _e189=i_2;if (_e189<firstTrailingBit(WG_SIZE)) {} else {break;}{let _e193=part_ix;let _e197=i_2;let probe=(_e193+((N_TILE / 2u)>>_e197));let _e200=ix;let _e205=sh_part_count[(probe-1u)];if (_e200>=_e205) {part_ix=probe;}}continuing {let _e208=i_2;i_2=(_e208+1u);}}let _e210=part_start_ix;let _e212=part_ix;let _e216=sh_part_count[(_e212-1u)];let _e217=part_ix;let _e221=ix;ix=(_e221-select(_e210,_e216,(_e217>0u)));let _e225=config.bin_data_start;let _e227=part_ix;let _e229=sh_part_offsets[_e227];let offset=(_e225+_e229);let _e235=ix;let _e238=info_bin_data[(offset+_e235)];sh_drawobj_ix[local_id.x]=_e238;}let _e239=rd_ix;let _e242=ready_ix;wr_ix=min((_e239+N_TILE),_e242);let _e244=wr_ix;let _e245=rd_ix;let _e249=wr_ix;let _e250=ready_ix;let _e252=partition_ix;if (((_e244-_e245)>=N_TILE) || ((_e249>=_e250) && (_e252>=n_partitions))) {break;}}}tag=DRAWTAG_NOP;let _e260=rd_ix;let _e262=wr_ix;if ((local_id.x+_e260)<_e262) {let _e267=sh_drawobj_ix[local_id.x];drawobj_ix=_e267;let _e271=config.drawtag_base;let _e272=drawobj_ix;let _e275=scene[(_e271+_e272)];tag=_e275;}tile_count=0u;let _e278=tag;if (_e278 !=DRAWTAG_NOP) {let _e282=drawobj_ix;let path_ix=draw_monoids[_e282].path_ix;let path=paths[path_ix];let stride=(path.bbox.z-path.bbox.x);sh_tile_stride[local_id.x]=stride;let dx=(i32(path.bbox.x)-i32(bin_tile_x));let dy=(i32(path.bbox.y)-i32(bin_tile_y));let x0_=clamp(dx,0,i32(N_TILE_X));let y0_=clamp(dy,0,i32(N_TILE_Y));let x1_=clamp((i32(path.bbox.z)-i32(bin_tile_x)),0,i32(N_TILE_X));let y1_=clamp((i32(path.bbox.w)-i32(bin_tile_y)),0,i32(N_TILE_Y));sh_tile_width[local_id.x]=u32((x1_-x0_));sh_tile_x0y0_[local_id.x]=(u32(x0_) | u32((y0_<<16u)));tile_count=(u32((x1_-x0_))*u32((y1_-y0_)));let base=(path.tiles-u32(((dy*i32(stride))+dx)));sh_tile_base[local_id.x]=base;}let _e363=tile_count;sh_tile_count[local_id.x]=_e363;i_3=0u;loop {let _e366=i_3;if (_e366<firstTrailingBit(N_TILE)) {} else {break;}{workgroupBarrier();let _e372=i_3;if (local_id.x>=(1u<<_e372)) {let _e378=i_3;let _e382=sh_tile_count[(local_id.x-(1u<<_e378))];let _e383=tile_count;tile_count=(_e383+_e382);}workgroupBarrier();let _e388=tile_count;sh_tile_count[local_id.x]=_e388;}continuing {let _e390=i_3;i_3=(_e390+1u);}}workgroupBarrier();let total_tile_count=sh_tile_count[(N_TILE-1u)];ix_1=local_id.x;loop {let _e400=ix_1;if (_e400<total_tile_count) {} else {break;}{el_ix=0u;i_4=0u;loop {let _e406=i_4;if (_e406<firstTrailingBit(N_TILE)) {} else {break;}{let _e410=el_ix;let _e414=i_4;let probe_1=(_e410+((N_TILE / 2u)>>_e414));let _e417=ix_1;let _e422=sh_tile_count[(probe_1-1u)];if (_e417>=_e422) {el_ix=probe_1;}}continuing {let _e425=i_4;i_4=(_e425+1u);}}let _e428=el_ix;let _e430=sh_drawobj_ix[_e428];drawobj_ix=_e430;let _e434=config.drawtag_base;let _e435=drawobj_ix;let _e438=scene[(_e434+_e435)];tag=_e438;let _e439=ix_1;let _e442=el_ix;let _e446=sh_tile_count[(_e442-1u)];let _e447=el_ix;let seq_ix=(_e439-select(0u,_e446,(_e447>0u)));let _e453=el_ix;let width=sh_tile_width[_e453];let _e457=el_ix;let x0y0_=sh_tile_x0y0_[_e457];let x=((x0y0_ & 65535u)+(seq_ix % width));let y=((x0y0_>>16u)+(seq_ix / width));let _e469=el_ix;let _e471=sh_tile_base[_e469];let _e473=el_ix;let _e475=sh_tile_stride[_e473];let tile_ix=((_e471+(_e475*y))+x);let tile_1=tiles[tile_ix];let _e482=tag;let is_clip=((_e482 & 1u) !=0u);is_blend=false;if is_clip {let BLEND_CLIP=((128u<<8u) | 3u);let _e495=drawobj_ix;let scene_offset=draw_monoids[_e495].scene_offset;let _e501=config.drawdata_base;let dd=(_e501+scene_offset);let blend=scene[dd];is_blend=(blend !=BLEND_CLIP);}let _e515=is_blend;let include_tile=(((tile_1.segments !=0u) || ((tile_1.backdrop==0)==is_clip)) || _e515);if include_tile {let _e517=el_ix;let el_slice=(_e517 / 32u);let _e521=el_ix;let el_mask=(1u<<(_e521 & 31u));let _e531=atomicOr((&sh_bitmaps[el_slice][((y*N_TILE_X)+x)]),el_mask);}}continuing {let _e533=ix_1;ix_1=(_e533+N_TILE);}}workgroupBarrier();slice_ix=0u;let _e542=atomicLoad((&sh_bitmaps[0][local_id.x]));bitmap=_e542;loop {if true {} else {break;}{let _e545=bitmap;if (_e545==0u) {let _e549=slice_ix;slice_ix=(_e549+1u);let _e551=slice_ix;if (_e551==N_SLICE) {break;}let _e555=slice_ix;let _e559=atomicLoad((&sh_bitmaps[_e555][local_id.x]));bitmap=_e559;let _e560=bitmap;if (_e560==0u) {continue;}}let _e563=slice_ix;let _e566=bitmap;let el_ix_1=((_e563*32u)+firstTrailingBit(_e566));let _e571=sh_drawobj_ix[el_ix_1];drawobj_ix=_e571;let _e572=bitmap;let _e575=bitmap;bitmap=(_e575 & (_e572-1u));let _e580=config.drawtag_base;let _e581=drawobj_ix;let drawtag=scene[(_e580+_e581)];let _e586=drawobj_ix;let dm=draw_monoids[_e586];let _e591=config.drawdata_base;let dd_1=(_e591+dm.scene_offset);let di=dm.info_offset;let _e595=clip_zero_depth;if (_e595==0u) {let _e600=sh_tile_base[el_ix_1];let _e603=sh_tile_stride[el_ix_1];let tile_ix_1=((_e600+(_e603*tile_y))+tile_x);let tile_2=tiles[tile_ix_1];switch drawtag {case 68u:{let _e612=info_bin_data[di];let linewidth_1=bitcast<f32>(_e612);let _e614=write_path(tile_2,linewidth_1);if _e614 {let rgba_color=scene[dd_1];write_color(CmdColor(rgba_color));}}case 276u:{let _e621=info_bin_data[di];let linewidth_2=bitcast<f32>(_e621);let _e623=write_path(tile_2,linewidth_2);if _e623 {let index_1=scene[dd_1];let info_offset_2=(di+1u);write_grad(CMD_LIN_GRAD,index_1,info_offset_2);}}case 668u:{let _e632=info_bin_data[di];let linewidth_3=bitcast<f32>(_e632);let _e634=write_path(tile_2,linewidth_3);if _e634 {let index_2=scene[dd_1];let info_offset_3=(di+1u);write_grad(CMD_RAD_GRAD,index_2,info_offset_3);}}case 584u:{let _e643=info_bin_data[di];let linewidth_4=bitcast<f32>(_e643);let _e645=write_path(tile_2,linewidth_4);if _e645 {write_image((di+1u));}}case 9u:{if ((tile_2.segments==0u) && (tile_2.backdrop==0)) {let _e655=clip_depth;clip_zero_depth=(_e655+1u);} else {write_begin_clip();let _e659=render_blend_depth;render_blend_depth=(_e659+1u);let _e661=max_blend_depth;let _e662=render_blend_depth;max_blend_depth=max(_e661,_e662);}let _e665=clip_depth;clip_depth=(_e665+1u);}case 33u:{let _e668=clip_depth;clip_depth=(_e668-1u);let _e671=write_path(tile_2,-1.0);let blend_1=scene[dd_1];let _e679=scene[(dd_1+1u)];let alpha=bitcast<f32>(_e679);write_end_clip(CmdEndClip(blend_1,alpha));let _e683=render_blend_depth;render_blend_depth=(_e683-1u);}default:{}}} else {switch drawtag {case 9u:{let _e686=clip_depth;clip_depth=(_e686+1u);}case 33u:{let _e688=clip_depth;let _e689=clip_zero_depth;if (_e688==_e689) {clip_zero_depth=0u;}let _e693=clip_depth;clip_depth=(_e693-1u);}default:{}}}}}let _e696=rd_ix;rd_ix=(_e696+N_TILE);let _e698=rd_ix;let _e699=ready_ix;let _e701=partition_ix;if ((_e698>=_e699) && (_e701>=n_partitions)) {break;}workgroupBarrier();}}let _e707=config.width_in_tiles;let _e712=config.height_in_tiles;if (((bin_tile_x+tile_x)<_e707) && ((bin_tile_y+tile_y)<_e712)) {let _e717=cmd_offset;ptcl[_e717]=CMD_END;let _e720=max_blend_depth;if (_e720>BLEND_STACK_SPLIT) {let _e723=max_blend_depth;let scratch_size=((_e723*TILE_WIDTH)*TILE_HEIGHT);let _e732=atomicAdd((&bump.blend),scratch_size);ptcl[blend_offset]=_e732;return;} else {return;}} else {return;}}\n',
        workgroup_size: new WorkgroupSize( 256, 1, 1 ),
        bindings: [ 'Uniform', 'BufReadOnly', 'BufReadOnly', 'BufReadOnly', 'BufReadOnly', 'BufReadOnly', 'BufReadOnly', 'Buffer', 'Buffer' ],
        workgroup_buffers: [
          { size_in_bytes: 8192, index: 0 },
          { size_in_bytes: 1024, index: 1 },
          { size_in_bytes: 1024, index: 2 },
          { size_in_bytes: 1024, index: 3 },
          { size_in_bytes: 1024, index: 4 },
          { size_in_bytes: 1024, index: 5 },
          { size_in_bytes: 1024, index: 6 },
          { size_in_bytes: 1024, index: 7 },
          { size_in_bytes: 1024, index: 8 }
        ]
      }, device ),
      draw_leaf: new VelloShader( 'draw_leaf', {
        wgsl: 'struct Config {width_in_tiles:u32,height_in_tiles:u32,target_width:u32,target_height:u32,base_color:u32,n_drawobj:u32,n_path:u32,n_clip:u32,bin_data_start:u32,pathtag_base:u32,pathdata_base:u32,drawtag_base:u32,drawdata_base:u32,transform_base:u32,linewidth_base:u32,binning_size:u32,tiles_size:u32,segments_size:u32,ptcl_size:u32,}struct Bic {a:u32,b:u32,}struct ClipInp {ix:u32,path_ix:i32,}struct ClipEl {parent_ix:u32,bbox:vec4<f32>,}struct DrawMonoid {path_ix:u32,clip_ix:u32,scene_offset:u32,info_offset:u32,}struct PathBbox {x0_:i32,y0_:i32,x1_:i32,y1_:i32,linewidth:f32,trans_ix:u32,}struct Transform {matrx:vec4<f32>,translate:vec2<f32>,}const TILE_WIDTH:u32=16u;const TILE_HEIGHT:u32=16u;const N_TILE_X:u32=16u;const N_TILE_Y:u32=16u;const N_TILE:u32=256u;const BLEND_STACK_SPLIT:u32=4u;const RAD_GRAD_KIND_CIRCULAR:u32=1u;const RAD_GRAD_KIND_STRIP:u32=2u;const RAD_GRAD_KIND_FOCAL_ON_CIRCLE:u32=3u;const RAD_GRAD_KIND_CONE:u32=4u;const RAD_GRAD_SWAPPED:u32=1u;const DRAWTAG_NOP:u32=0u;const DRAWTAG_FILL_COLOR:u32=68u;const DRAWTAG_FILL_LIN_GRADIENT:u32=276u;const DRAWTAG_FILL_RAD_GRADIENT:u32=668u;const DRAWTAG_FILL_IMAGE:u32=584u;const DRAWTAG_BEGIN_CLIP:u32=9u;const DRAWTAG_END_CLIP:u32=33u;const WG_SIZE:u32=256u;@group(0) @binding(0)\nvar<uniform>config:Config;@group(0) @binding(1)\nvar<storage>scene:array<u32>;@group(0) @binding(2)\nvar<storage>reduced:array<DrawMonoid>;@group(0) @binding(3)\nvar<storage>path_bbox:array<PathBbox>;@group(0) @binding(4)\nvar<storage,read_write>draw_monoid:array<DrawMonoid>;@group(0) @binding(5)\nvar<storage,read_write>info:array<u32>;@group(0) @binding(6)\nvar<storage,read_write>clip_inp:array<ClipInp>;var<workgroup>sh_scratch:array<DrawMonoid,WG_SIZE>;fn bic_combine(x:Bic,y:Bic)->Bic {let m_1=min(x.b,y.a);return Bic(((x.a+y.a)-m_1),((x.b+y.b)-m_1));}fn draw_monoid_identity()->DrawMonoid {return DrawMonoid(0u,0u,0u,0u);}fn combine_draw_monoid(a:DrawMonoid,b:DrawMonoid)->DrawMonoid {var c:DrawMonoid;c.path_ix=(a.path_ix+b.path_ix);c.clip_ix=(a.clip_ix+b.clip_ix);c.scene_offset=(a.scene_offset+b.scene_offset);c.info_offset=(a.info_offset+b.info_offset);let _e19=c;return _e19;}fn map_draw_tag(tag_word:u32)->DrawMonoid {var c_1:DrawMonoid;c_1.path_ix=u32((tag_word !=DRAWTAG_NOP));c_1.clip_ix=(tag_word & 1u);c_1.scene_offset=((tag_word>>2u) & 7u);c_1.info_offset=((tag_word>>6u) & 15u);let _e19=c_1;return _e19;}fn bbox_intersect(a_1:vec4<f32>,b_1:vec4<f32>)->vec4<f32>{return vec4<f32>(max(a_1.xy,b_1.xy),min(a_1.zw,b_1.zw));}fn transform_apply(transform_1:Transform,p:vec2<f32>)->vec2<f32>{return (((transform_1.matrx.xy*p.x)+(transform_1.matrx.zw*p.y))+transform_1.translate);}fn transform_inverse(transform_2:Transform)->Transform {let inv_det=(1.0 / ((transform_2.matrx.x*transform_2.matrx.w)-(transform_2.matrx.y*transform_2.matrx.z)));let inv_mat=(inv_det*vec4<f32>(transform_2.matrx.w,-(transform_2.matrx.y),-(transform_2.matrx.z),transform_2.matrx.x));let inv_tr=(mat2x2<f32>(inv_mat.xy,inv_mat.zw)*-(transform_2.translate));return Transform(inv_mat,inv_tr);}fn transform_mul(a_2:Transform,b_2:Transform)->Transform {return Transform(((a_2.matrx.xyxy*b_2.matrx.xxzz)+(a_2.matrx.zwzw*b_2.matrx.yyww)),(((a_2.matrx.xy*b_2.translate.x)+(a_2.matrx.zw*b_2.translate.y))+a_2.translate));}fn read_transform(transform_base:u32,ix:u32)->Transform {let base=(transform_base+(ix*6u));let _e7=scene[base];let c0_=bitcast<f32>(_e7);let _e13=scene[(base+1u)];let c1_=bitcast<f32>(_e13);let _e19=scene[(base+2u)];let c2_=bitcast<f32>(_e19);let _e25=scene[(base+3u)];let c3_=bitcast<f32>(_e25);let _e31=scene[(base+4u)];let c4_=bitcast<f32>(_e31);let _e37=scene[(base+5u)];let c5_=bitcast<f32>(_e37);let matrx=vec4<f32>(c0_,c1_,c2_,c3_);let translate=vec2<f32>(c4_,c5_);return Transform(matrx,translate);}fn from_poly2_(p0_2:vec2<f32>,p1_2:vec2<f32>)->Transform {return Transform(vec4<f32>((p1_2.y-p0_2.y),(p0_2.x-p1_2.x),(p1_2.x-p0_2.x),(p1_2.y-p0_2.y)),vec2<f32>(p0_2.x,p0_2.y));}fn two_point_to_unit_line(p0_3:vec2<f32>,p1_3:vec2<f32>)->Transform {let _e2=from_poly2_(p0_3,p1_3);let _e3=transform_inverse(_e2);let _e9=from_poly2_(vec2<f32>(0.0),vec2<f32>(1.0,0.0));let _e10=transform_mul(_e9,_e3);return _e10;}@compute @workgroup_size(256,1,1)\nfn main(@builtin(global_invocation_id) global_id:vec3<u32>,@builtin(local_invocation_id) local_id:vec3<u32>,@builtin(workgroup_id) wg_id:vec3<u32>) {var agg:DrawMonoid;var i:u32;var m:DrawMonoid;var i_1:u32;var transform:Transform;var linewidth:f32;var p0_:vec2<f32>;var p1_:vec2<f32>;var p0_1:vec2<f32>;var p1_1:vec2<f32>;var r0_:f32;var r1_:f32;var xform:Transform;var focal_x:f32;var radius:f32;var kind:u32;var flags:u32;var user_to_scaled:Transform;var path_ix:u32;let ix_1=global_id.x;let _e4=draw_monoid_identity();agg=_e4;if (local_id.x<wg_id.x) {let _e12=reduced[local_id.x];agg=_e12;}let _e16=agg;sh_scratch[local_id.x]=_e16;i=0u;loop {let _e19=i;if (_e19<firstTrailingBit(WG_SIZE)) {} else {break;}{workgroupBarrier();let _e25=i;if ((local_id.x+(1u<<_e25))<WG_SIZE) {let _e33=i;let other=sh_scratch[(local_id.x+(1u<<_e33))];let _e38=agg;let _e39=combine_draw_monoid(_e38,other);agg=_e39;}workgroupBarrier();let _e43=agg;sh_scratch[local_id.x]=_e43;}continuing {let _e45=i;i=(_e45+1u);}}workgroupBarrier();let _e50=sh_scratch[0];m=_e50;workgroupBarrier();let _e55=config.drawtag_base;let tag_word_1=scene[(_e55+ix_1)];let _e59=map_draw_tag(tag_word_1);agg=_e59;let _e63=agg;sh_scratch[local_id.x]=_e63;i_1=0u;loop {let _e66=i_1;if (_e66<firstTrailingBit(WG_SIZE)) {} else {break;}{workgroupBarrier();let _e72=i_1;if (local_id.x>=(1u<<_e72)) {let _e78=i_1;let other_1=sh_scratch[(local_id.x-(1u<<_e78))];let _e83=agg;let _e84=combine_draw_monoid(_e83,other_1);agg=_e84;}workgroupBarrier();let _e88=agg;sh_scratch[local_id.x]=_e88;}continuing {let _e90=i_1;i_1=(_e90+1u);}}workgroupBarrier();if (local_id.x>0u) {let _e95=m;let _e101=sh_scratch[(local_id.x-1u)];let _e102=combine_draw_monoid(_e95,_e101);m=_e102;}let _e105=m;draw_monoid[ix_1]=_e105;let _e108=config.drawdata_base;let _e110=m.scene_offset;let dd=(_e108+_e110);let di=m.info_offset;if (((((tag_word_1==DRAWTAG_FILL_COLOR) || (tag_word_1==DRAWTAG_FILL_LIN_GRADIENT)) || (tag_word_1==DRAWTAG_FILL_RAD_GRADIENT)) || (tag_word_1==DRAWTAG_FILL_IMAGE)) || (tag_word_1==DRAWTAG_BEGIN_CLIP)) {let _e130=m.path_ix;let bbox=path_bbox[_e130];let fill_mode=u32((bbox.linewidth>=0.0));transform=Transform(vec4<f32>(0.0,0.0,0.0,0.0),vec2<f32>(0.0,0.0));linewidth=bbox.linewidth;let _e141=linewidth;if ((((_e141>=0.0) || (tag_word_1==DRAWTAG_FILL_LIN_GRADIENT)) || (tag_word_1==DRAWTAG_FILL_RAD_GRADIENT)) || (tag_word_1==DRAWTAG_FILL_IMAGE)) {let _e155=config.transform_base;let _e157=read_transform(_e155,bbox.trans_ix);transform=_e157;}let _e158=linewidth;if (_e158>=0.0) {let matrx_1=transform.matrx;let _e172=linewidth;linewidth=(_e172*sqrt(abs(((matrx_1.x*matrx_1.w)-(matrx_1.y*matrx_1.z)))));}switch tag_word_1 {case 68u:{let _e176=linewidth;info[di]=bitcast<u32>(_e176);}case 276u:{let _e180=linewidth;info[di]=bitcast<u32>(_e180);let _e186=scene[(dd+1u)];let _e191=scene[(dd+2u)];p0_=bitcast<vec2<f32>>(vec2<u32>(_e186,_e191));let _e199=scene[(dd+3u)];let _e204=scene[(dd+4u)];p1_=bitcast<vec2<f32>>(vec2<u32>(_e199,_e204));let _e208=transform;let _e209=p0_;let _e210=transform_apply(_e208,_e209);p0_=_e210;let _e211=transform;let _e212=p1_;let _e213=transform_apply(_e211,_e212);p1_=_e213;let _e214=p1_;let _e215=p0_;let dxy=(_e214-_e215);let scale=(1.0 / dot(dxy,dxy));let line_xy=(dxy*scale);let _e221=p0_;let line_c=-(dot(_e221,line_xy));info[(di+1u)]=bitcast<u32>(line_xy.x);info[(di+2u)]=bitcast<u32>(line_xy.y);info[(di+3u)]=bitcast<u32>(line_c);}case 668u:{let GRADIENT_EPSILON=(1.0 / f32((1<<12u)));let _e249=linewidth;info[di]=bitcast<u32>(_e249);let _e255=scene[(dd+1u)];let _e260=scene[(dd+2u)];p0_1=bitcast<vec2<f32>>(vec2<u32>(_e255,_e260));let _e268=scene[(dd+3u)];let _e273=scene[(dd+4u)];p1_1=bitcast<vec2<f32>>(vec2<u32>(_e268,_e273));let _e281=scene[(dd+5u)];r0_=bitcast<f32>(_e281);let _e288=scene[(dd+6u)];r1_=bitcast<f32>(_e288);let _e291=transform;let _e292=transform_inverse(_e291);xform=Transform(vec4<f32>(0.0,0.0,0.0,0.0),vec2<f32>(0.0,0.0));focal_x=0.0;radius=0.0;kind=0u;flags=0u;let _e303=r0_;let _e304=r1_;if (abs((_e303-_e304))<=GRADIENT_EPSILON) {kind=RAD_GRAD_KIND_STRIP;let _e309=r0_;let _e310=p0_1;let _e311=p1_1;let scaled=(_e309 / distance(_e310,_e311));let _e314=p0_1;let _e315=p1_1;let _e316=two_point_to_unit_line(_e314,_e315);let _e317=transform_mul(_e316,_e292);xform=_e317;radius=(scaled*scaled);} else {kind=RAD_GRAD_KIND_CONE;let _e320=p0_1;let _e321=p1_1;if all((_e320==_e321)) {kind=RAD_GRAD_KIND_CIRCULAR;let _e325=p0_1;p0_1=(_e325+vec2<f32>(GRADIENT_EPSILON));}let _e328=r1_;if (_e328==0.0) {let _e332=flags;flags=(_e332 | RAD_GRAD_SWAPPED);let tmp_p=p0_1;let _e335=p1_1;p0_1=_e335;p1_1=tmp_p;let tmp_r=r0_;let _e337=r1_;r0_=_e337;r1_=tmp_r;}let _e338=r0_;let _e339=r0_;let _e340=r1_;focal_x=(_e338 / (_e339-_e340));let _e344=focal_x;let _e346=p0_1;let _e348=focal_x;let _e349=p1_1;let cf=(((1.0-_e344)*_e346)+(_e348*_e349));let _e352=r1_;let _e353=p1_1;radius=(_e352 / distance(cf,_e353));let _e356=p1_1;let _e357=two_point_to_unit_line(cf,_e356);let _e358=transform_mul(_e357,_e292);user_to_scaled=_e358;let _e360=radius;if (abs((_e360-1.0))<=GRADIENT_EPSILON) {kind=RAD_GRAD_KIND_FOCAL_ON_CIRCLE;let _e368=focal_x;let scale_1=(0.5*abs((1.0-_e368)));let _e378=transform_mul(Transform(vec4<f32>(scale_1,0.0,0.0,scale_1),vec2<f32>(0.0)),_e358);user_to_scaled=_e378;} else {let _e379=radius;let _e380=radius;let a_3=((_e379*_e380)-1.0);let _e385=focal_x;let scale_ratio=(abs((1.0-_e385)) / a_3);let _e389=radius;let scale_x=(_e389*scale_ratio);let scale_y=(sqrt(abs(a_3))*scale_ratio);let _e400=transform_mul(Transform(vec4<f32>(scale_x,0.0,0.0,scale_y),vec2<f32>(0.0)),_e358);user_to_scaled=_e400;}let _e401=user_to_scaled;xform=_e401;}let _e408=xform.matrx.x;info[(di+1u)]=bitcast<u32>(_e408);let _e416=xform.matrx.y;info[(di+2u)]=bitcast<u32>(_e416);let _e424=xform.matrx.z;info[(di+3u)]=bitcast<u32>(_e424);let _e432=xform.matrx.w;info[(di+4u)]=bitcast<u32>(_e432);let _e440=xform.translate.x;info[(di+5u)]=bitcast<u32>(_e440);let _e448=xform.translate.y;info[(di+6u)]=bitcast<u32>(_e448);let _e454=focal_x;info[(di+7u)]=bitcast<u32>(_e454);let _e460=radius;info[(di+8u)]=bitcast<u32>(_e460);let _e466=flags;let _e469=kind;info[(di+9u)]=bitcast<u32>(((_e466<<3u) | _e469));}case 584u:{let _e474=linewidth;info[di]=bitcast<u32>(_e474);let _e476=transform;let _e477=transform_inverse(_e476);info[(di+1u)]=bitcast<u32>(_e477.matrx.x);info[(di+2u)]=bitcast<u32>(_e477.matrx.y);info[(di+3u)]=bitcast<u32>(_e477.matrx.z);info[(di+4u)]=bitcast<u32>(_e477.matrx.w);info[(di+5u)]=bitcast<u32>(_e477.translate.x);info[(di+6u)]=bitcast<u32>(_e477.translate.y);let _e526=scene[dd];info[(di+7u)]=_e526;let _e535=scene[(dd+1u)];info[(di+8u)]=_e535;}default:{}}}if ((tag_word_1==DRAWTAG_BEGIN_CLIP) || (tag_word_1==DRAWTAG_END_CLIP)) {path_ix=~(ix_1);if (tag_word_1==DRAWTAG_BEGIN_CLIP) {let _e546=m.path_ix;path_ix=_e546;}let _e549=m.clip_ix;let _e551=path_ix;clip_inp[_e549]=ClipInp(ix_1,i32(_e551));return;} else {return;}}\n',
        workgroup_size: new WorkgroupSize( 256, 1, 1 ),
        bindings: [ 'Uniform', 'BufReadOnly', 'BufReadOnly', 'BufReadOnly', 'Buffer', 'Buffer', 'Buffer' ],
        workgroup_buffers: [
          { size_in_bytes: 4096, index: 0 }
        ]
      }, device ),
      draw_reduce: new VelloShader( 'draw_reduce', {
        wgsl: 'struct Config {width_in_tiles:u32,height_in_tiles:u32,target_width:u32,target_height:u32,base_color:u32,n_drawobj:u32,n_path:u32,n_clip:u32,bin_data_start:u32,pathtag_base:u32,pathdata_base:u32,drawtag_base:u32,drawdata_base:u32,transform_base:u32,linewidth_base:u32,binning_size:u32,tiles_size:u32,segments_size:u32,ptcl_size:u32,}struct DrawMonoid {path_ix:u32,clip_ix:u32,scene_offset:u32,info_offset:u32,}const TILE_WIDTH:u32=16u;const TILE_HEIGHT:u32=16u;const N_TILE_X:u32=16u;const N_TILE_Y:u32=16u;const N_TILE:u32=256u;const BLEND_STACK_SPLIT:u32=4u;const RAD_GRAD_KIND_CIRCULAR:u32=1u;const RAD_GRAD_KIND_STRIP:u32=2u;const RAD_GRAD_KIND_FOCAL_ON_CIRCLE:u32=3u;const RAD_GRAD_KIND_CONE:u32=4u;const RAD_GRAD_SWAPPED:u32=1u;const DRAWTAG_NOP:u32=0u;const DRAWTAG_FILL_COLOR:u32=68u;const DRAWTAG_FILL_LIN_GRADIENT:u32=276u;const DRAWTAG_FILL_RAD_GRADIENT:u32=668u;const DRAWTAG_FILL_IMAGE:u32=584u;const DRAWTAG_BEGIN_CLIP:u32=9u;const DRAWTAG_END_CLIP:u32=33u;const WG_SIZE:u32=256u;@group(0) @binding(0)\nvar<uniform>config:Config;@group(0) @binding(1)\nvar<storage>scene:array<u32>;@group(0) @binding(2)\nvar<storage,read_write>reduced:array<DrawMonoid>;var<workgroup>sh_scratch:array<DrawMonoid,WG_SIZE>;fn draw_monoid_identity()->DrawMonoid {return DrawMonoid(0u,0u,0u,0u);}fn combine_draw_monoid(a:DrawMonoid,b:DrawMonoid)->DrawMonoid {var c:DrawMonoid;c.path_ix=(a.path_ix+b.path_ix);c.clip_ix=(a.clip_ix+b.clip_ix);c.scene_offset=(a.scene_offset+b.scene_offset);c.info_offset=(a.info_offset+b.info_offset);let _e19=c;return _e19;}fn map_draw_tag(tag_word:u32)->DrawMonoid {var c_1:DrawMonoid;c_1.path_ix=u32((tag_word !=DRAWTAG_NOP));c_1.clip_ix=(tag_word & 1u);c_1.scene_offset=((tag_word>>2u) & 7u);c_1.info_offset=((tag_word>>6u) & 15u);let _e19=c_1;return _e19;}@compute @workgroup_size(256,1,1)\nfn main(@builtin(global_invocation_id) global_id:vec3<u32>,@builtin(local_invocation_id) local_id:vec3<u32>) {var agg:DrawMonoid;var i:u32;let ix=global_id.x;let _e6=config.drawtag_base;let tag_word_1=scene[(_e6+ix)];let _e10=map_draw_tag(tag_word_1);agg=_e10;let _e15=agg;sh_scratch[local_id.x]=_e15;i=0u;loop {let _e18=i;if (_e18<firstTrailingBit(WG_SIZE)) {} else {break;}{workgroupBarrier();let _e24=i;if ((local_id.x+(1u<<_e24))<WG_SIZE) {let _e32=i;let other=sh_scratch[(local_id.x+(1u<<_e32))];let _e37=agg;let _e38=combine_draw_monoid(_e37,other);agg=_e38;}workgroupBarrier();let _e42=agg;sh_scratch[local_id.x]=_e42;}continuing {let _e44=i;i=(_e44+1u);}}if (local_id.x==0u) {let _e54=agg;reduced[(ix>>firstTrailingBit(WG_SIZE))]=_e54;return;} else {return;}}\n',
        workgroup_size: new WorkgroupSize( 256, 1, 1 ),
        bindings: [ 'Uniform', 'BufReadOnly', 'Buffer' ],
        workgroup_buffers: [
          { size_in_bytes: 4096, index: 0 }
        ]
      }, device ),
      fine_rgba8unorm: new VelloShader( 'fine_rgba8unorm', {
        wgsl: getFineShaderWGSL( 'rgba8unorm' ),
        workgroup_size: new WorkgroupSize( 4, 16, 1 ),
        bindings: [ 'Uniform', 'BufReadOnly', 'BufReadOnly', 'Image', 'BufReadOnly', 'ImageRead', 'BufReadOnly', 'ImageRead' ],
        workgroup_buffers: []
      }, device, 'rgba8unorm' ),
      fine_bgra8unorm: new VelloShader( 'fine_bgra8unorm', {
        wgsl: getFineShaderWGSL( 'bgra8unorm' ),
        workgroup_size: new WorkgroupSize( 4, 16, 1 ),
        bindings: [ 'Uniform', 'BufReadOnly', 'BufReadOnly', 'Image', 'BufReadOnly', 'ImageRead', 'BufReadOnly', 'ImageRead' ],
        workgroup_buffers: []
      }, device, 'bgra8unorm' ),
      path_coarse: new VelloShader( 'path_coarse', {
        wgsl: 'struct Config {width_in_tiles:u32,height_in_tiles:u32,target_width:u32,target_height:u32,base_color:u32,n_drawobj:u32,n_path:u32,n_clip:u32,bin_data_start:u32,pathtag_base:u32,pathdata_base:u32,drawtag_base:u32,drawdata_base:u32,transform_base:u32,linewidth_base:u32,binning_size:u32,tiles_size:u32,segments_size:u32,ptcl_size:u32,}struct TagMonoid {trans_ix:u32,pathseg_ix:u32,pathseg_offset:u32,linewidth_ix:u32,path_ix:u32,}struct AtomicTile {backdrop:atomic<i32>,segments:atomic<u32>,}struct Segment {origin:vec2<f32>,delta:vec2<f32>,y_edge:f32,next:u32,}struct SubdivResult {val:f32,a0_:f32,a2_:f32,}const TILE_WIDTH:u32=16u;const TILE_HEIGHT:u32=16u;const N_TILE_X:u32=16u;const N_TILE_Y:u32=16u;const N_TILE:u32=256u;const BLEND_STACK_SPLIT:u32=4u;const RAD_GRAD_KIND_CIRCULAR:u32=1u;const RAD_GRAD_KIND_STRIP:u32=2u;const RAD_GRAD_KIND_FOCAL_ON_CIRCLE:u32=3u;const RAD_GRAD_KIND_CONE:u32=4u;const RAD_GRAD_SWAPPED:u32=1u;const PATH_TAG_SEG_TYPE:u32=3u;const PATH_TAG_LINETO:u32=1u;const PATH_TAG_QUADTO:u32=2u;const PATH_TAG_CUBICTO:u32=3u;const PATH_TAG_F32_:u32=8u;const PATH_TAG_TRANSFORM:u32=32u;const PATH_TAG_PATH:u32=16u;const PATH_TAG_LINEWIDTH:u32=64u;const D:f32=0.6700000166893005;const B:f32=0.38999998569488525;const MAX_QUADS:u32=16u;@group(0) @binding(0)\nvar<uniform>config:Config;@group(0) @binding(1)\nvar<storage>scene:array<u32>;@group(0) @binding(2)\nvar<storage>tag_monoids:array<TagMonoid>;@group(0) @binding(3)\nvar<storage,read_write>tiles:array<AtomicTile>;@group(0) @binding(4)\nvar<storage,read_write>segments:array<Segment>;var<private>pathdata_base:u32;fn tag_monoid_identity()->TagMonoid {return TagMonoid(0u,0u,0u,0u,0u);}fn combine_tag_monoid(a:TagMonoid,b:TagMonoid)->TagMonoid {var c:TagMonoid;c.trans_ix=(a.trans_ix+b.trans_ix);c.pathseg_ix=(a.pathseg_ix+b.pathseg_ix);c.pathseg_offset=(a.pathseg_offset+b.pathseg_offset);c.linewidth_ix=(a.linewidth_ix+b.linewidth_ix);c.path_ix=(a.path_ix+b.path_ix);let _e23=c;return _e23;}fn reduce_tag(tag_word:u32)->TagMonoid {var c_1:TagMonoid;var a_1:u32;let point_count=(tag_word & 50529027u);c_1.pathseg_ix=countOneBits(((point_count*7u) & 67372036u));c_1.trans_ix=countOneBits((tag_word & (PATH_TAG_TRANSFORM*16843009u)));let n_points=(point_count+((tag_word>>2u) & 16843009u));a_1=(n_points+(n_points & (((tag_word>>3u) & 16843009u)*15u)));let _e30=a_1;let _e33=a_1;a_1=(_e33+(_e30>>8u));let _e35=a_1;let _e38=a_1;a_1=(_e38+(_e35>>16u));let _e41=a_1;c_1.pathseg_offset=(_e41 & 255u);c_1.path_ix=countOneBits((tag_word & (PATH_TAG_PATH*16843009u)));c_1.linewidth_ix=countOneBits((tag_word & (PATH_TAG_LINEWIDTH*16843009u)));let _e56=c_1;return _e56;}fn read_f32_point(ix:u32)->vec2<f32>{let _e3=pathdata_base;let _e6=scene[(_e3+ix)];let x_3=bitcast<f32>(_e6);let _e10=pathdata_base;let _e15=scene[((_e10+ix)+1u)];let y_1=bitcast<f32>(_e15);return vec2<f32>(x_3,y_1);}fn read_i16_point(ix_1:u32)->vec2<f32>{let _e3=pathdata_base;let raw=scene[(_e3+ix_1)];let x_4=f32((i32((raw<<16u))>>16u));let y_2=f32((i32(raw)>>16u));return vec2<f32>(x_4,y_2);}fn approx_parabola_integral(x_1:f32)->f32 {return (x_1*inverseSqrt(sqrt(((1.0-D)+((((D*D)*D)*D)+((0.25*x_1)*x_1))))));}fn approx_parabola_inv_integral(x_2:f32)->f32 {return (x_2*sqrt(((1.0-B)+((B*B)+((0.5*x_2)*x_2)))));}fn estimate_subdiv(p0_1:vec2<f32>,p1_1:vec2<f32>,p2_1:vec2<f32>,sqrt_tol:f32)->SubdivResult {var val_1:f32;let d01_=(p1_1-p0_1);let d12_=(p2_1-p1_1);let dd=(d01_-d12_);let cross=(((p2_1.x-p0_1.x)*dd.y)-((p2_1.y-p0_1.y)*dd.x));let cross_inv=(1.0 / cross);let x0_1=(dot(d01_,dd)*cross_inv);let x2_=(dot(d12_,dd)*cross_inv);let scale=abs((cross / (length(dd)*(x2_-x0_1))));let _e29=approx_parabola_integral(x0_1);let _e30=approx_parabola_integral(x2_);val_1=0.0;if (scale<1000000000.0) {let da=abs((_e30-_e29));let sqrt_scale=sqrt(scale);if (sign(x0_1)==sign(x2_)) {val_1=sqrt_scale;} else {let xmin=(sqrt_tol / sqrt_scale);let _e42=approx_parabola_integral(xmin);val_1=(sqrt_tol / _e42);}let _e44=val_1;val_1=(_e44*da);}let _e46=val_1;return SubdivResult(_e46,_e29,_e30);}fn eval_quad(p0_2:vec2<f32>,p1_2:vec2<f32>,p2_2:vec2<f32>,t:f32)->vec2<f32>{let mt=(1.0-t);return ((p0_2*(mt*mt))+(((p1_2*(mt*2.0))+(p2_2*t))*t));}fn eval_cubic(p0_3:vec2<f32>,p1_3:vec2<f32>,p2_3:vec2<f32>,p3_1:vec2<f32>,t_1:f32)->vec2<f32>{let mt_1=(1.0-t_1);return ((p0_3*((mt_1*mt_1)*mt_1))+(((p1_3*((mt_1*mt_1)*3.0))+(((p2_3*(mt_1*3.0))+(p3_1*t_1))*t_1))*t_1));}fn alloc_segment()->u32 {let _e5=atomicAdd((&tiles[4096].segments),1u);return (_e5+1u);}@compute @workgroup_size(256,1,1)\nfn main(@builtin(global_invocation_id) global_id:vec3<u32>,@builtin(local_invocation_id) local_id:vec3<u32>) {var tm:TagMonoid;var tag_byte:u32;var p0_:vec2<f32>;var p1_:vec2<f32>;var p2_:vec2<f32>;var p3_:vec2<f32>;var n_quads:u32;var keep_params:array<SubdivResult,MAX_QUADS>;var val:f32;var qp0_:vec2<f32>;var i:u32;var qp1_:vec2<f32>;var lp0_:vec2<f32>;var n_out:u32;var val_sum:f32;var i_1:u32;var qp1_1:vec2<f32>;var val_target:f32;var lp1_:vec2<f32>;var x0_:i32;var x1_:i32;var y0_:i32;var y1_:i32;var xc:f32;var xray:i32;var last_xray:i32;var y:i32;var next_xray:i32;var xx0_:i32;var xx1_:i32;var tile_seg:Segment;var x:i32;var y_edge:f32;let ix_2=global_id.x;let _e6=config.pathtag_base;let tag_word_1=scene[(_e6+(ix_2>>2u))];let _e15=config.pathdata_base;pathdata_base=_e15;let shift=((ix_2 & 3u)*8u);let _e25=reduce_tag((tag_word_1 & ((1u<<shift)-1u)));tm=_e25;let _e31=tag_monoids[(ix_2>>2u)];let _e32=tm;let _e33=combine_tag_monoid(_e31,_e32);tm=_e33;tag_byte=((tag_word_1>>shift) & 255u);let _e38=tag_byte;let seg_type=(_e38 & PATH_TAG_SEG_TYPE);if (seg_type !=0u) {let _e47=tag_byte;if ((_e47 & PATH_TAG_F32_) !=0u) {let _e53=tm.pathseg_offset;let _e54=read_f32_point(_e53);p0_=_e54;let _e56=tm.pathseg_offset;let _e59=read_f32_point((_e56+2u));p1_=_e59;if (seg_type>=PATH_TAG_QUADTO) {let _e63=tm.pathseg_offset;let _e66=read_f32_point((_e63+4u));p2_=_e66;if (seg_type==PATH_TAG_CUBICTO) {let _e70=tm.pathseg_offset;let _e73=read_f32_point((_e70+6u));p3_=_e73;}}} else {let _e75=tm.pathseg_offset;let _e76=read_i16_point(_e75);p0_=_e76;let _e78=tm.pathseg_offset;let _e81=read_i16_point((_e78+1u));p1_=_e81;if (seg_type>=PATH_TAG_QUADTO) {let _e85=tm.pathseg_offset;let _e88=read_i16_point((_e85+2u));p2_=_e88;if (seg_type==PATH_TAG_CUBICTO) {let _e92=tm.pathseg_offset;let _e95=read_i16_point((_e92+3u));p3_=_e95;}}}if (seg_type==PATH_TAG_LINETO) {let _e98=p1_;p3_=_e98;let _e99=p3_;let _e100=p0_;p2_=mix(_e99,_e100,(1.0 / 3.0));let _e105=p0_;let _e106=p3_;p1_=mix(_e105,_e106,(1.0 / 3.0));} else {if (seg_type==PATH_TAG_QUADTO) {let _e113=p2_;p3_=_e113;let _e114=p1_;let _e115=p2_;p2_=mix(_e114,_e115,(1.0 / 3.0));let _e120=p1_;let _e121=p0_;p1_=mix(_e120,_e121,(1.0 / 3.0));}}let _e127=p2_;let _e128=p1_;let _e131=p0_;let _e133=p3_;let err_v=(((3.0*(_e127-_e128))+_e131)-_e133);let err=dot(err_v,err_v);let Q_ACCURACY=(0.25*0.10000000149011612);let REM_ACCURACY=(0.25-Q_ACCURACY);let MAX_HYPOT2_=((432.0*Q_ACCURACY)*Q_ACCURACY);n_quads=max(u32(ceil(pow((err*(1.0 / MAX_HYPOT2_)),(1.0 / 6.0)))),1u);let _e155=n_quads;n_quads=min(_e155,MAX_QUADS);val=0.0;let _e161=p0_;qp0_=_e161;let _e164=n_quads;let step=(1.0 / f32(_e164));i=0u;loop {let _e169=i;let _e170=n_quads;if (_e169<_e170) {} else {break;}{let _e172=i;let t_2=(f32((_e172+1u))*step);let _e177=p0_;let _e178=p1_;let _e179=p2_;let _e180=p3_;let _e181=eval_cubic(_e177,_e178,_e179,_e180,t_2);let _e182=p0_;let _e183=p1_;let _e184=p2_;let _e185=p3_;let _e189=eval_cubic(_e182,_e183,_e184,_e185,(t_2-(0.5*step)));qp1_=_e189;let _e192=qp1_;let _e195=qp0_;qp1_=((2.0*_e192)-(0.5*(_e195+_e181)));let _e199=qp0_;let _e200=qp1_;let _e202=estimate_subdiv(_e199,_e200,_e181,sqrt(REM_ACCURACY));let _e203=i;keep_params[_e203]=_e202;let _e206=val;val=(_e206+_e202.val);qp0_=_e181;}continuing {let _e209=i;i=(_e209+1u);}}let _e211=val;let n=max(u32(ceil((_e211*(0.5 / sqrt(REM_ACCURACY))))),1u);let _e220=p0_;lp0_=_e220;let _e222=p0_;qp0_=_e222;let _e223=val;let v_step=(_e223 / f32(n));n_out=1u;val_sum=0.0;i_1=0u;loop {let _e232=i_1;let _e233=n_quads;if (_e232<_e233) {} else {break;}{let _e235=i_1;let t_3=(f32((_e235+1u))*step);let _e240=p0_;let _e241=p1_;let _e242=p2_;let _e243=p3_;let _e244=eval_cubic(_e240,_e241,_e242,_e243,t_3);let _e245=p0_;let _e246=p1_;let _e247=p2_;let _e248=p3_;let _e252=eval_cubic(_e245,_e246,_e247,_e248,(t_3-(0.5*step)));qp1_1=_e252;let _e255=qp1_1;let _e258=qp0_;qp1_1=((2.0*_e255)-(0.5*(_e258+_e244)));let _e262=i_1;let params=keep_params[_e262];let _e266=approx_parabola_inv_integral(params.a0_);let _e268=approx_parabola_inv_integral(params.a2_);let uscale=(1.0 / (_e268-_e266));let _e272=n_out;val_target=(f32(_e272)*v_step);loop {let _e276=n_out;let _e278=val_target;let _e279=val_sum;if ((_e276==n) || (_e278<(_e279+params.val))) {} else {break;}{let _e285=n_out;if (_e285==n) {let _e287=p3_;lp1_=_e287;} else {let _e288=val_target;let _e289=val_sum;let u=((_e288-_e289) / params.val);let a_2=mix(params.a0_,params.a2_,u);let _e296=approx_parabola_inv_integral(a_2);let t_4=((_e296-_e266)*uscale);let _e299=qp0_;let _e300=qp1_1;let _e301=eval_quad(_e299,_e300,_e244,t_4);lp1_=_e301;}let _e302=lp0_;let _e303=lp1_;let xymin=min(_e302,_e303);let _e305=lp0_;let _e306=lp1_;let xymax=max(_e305,_e306);let _e308=lp1_;let _e309=lp0_;let dp=(_e308-_e309);let recip_dx=(1.0 / dp.x);let b_1=select((dp.x / dp.y),1000000000.0,(abs(dp.y)<9.999999717180685e-10));let c_2=(0.5*abs(b_1));let SX=(1.0 / f32(TILE_WIDTH));let SY=(1.0 / f32(TILE_HEIGHT));let _e335=lp0_.x;let _e337=lp0_.y;let a_3=((_e335-((_e337-(0.5*f32(TILE_HEIGHT)))*b_1))*SX);x0_=i32(floor((xymin.x*SX)));x1_=i32((floor((xymax.x*SX))+1.0));y0_=i32(floor((xymin.y*SY)));y1_=i32((floor((xymax.y*SY))+1.0));let _e370=x0_;let _e374=config.width_in_tiles;x0_=clamp(_e370,0,i32(_e374));let _e377=x1_;let _e381=config.width_in_tiles;x1_=clamp(_e377,0,i32(_e381));let _e384=y0_;let _e388=config.height_in_tiles;y0_=clamp(_e384,0,i32(_e388));let _e391=y1_;let _e395=config.height_in_tiles;y1_=clamp(_e391,0,i32(_e395));let _e398=y0_;xc=(a_3+(b_1*f32(_e398)));let _e404=lp0_.x;xray=i32(floor((_e404*SX)));let _e410=lp1_.x;last_xray=i32(floor((_e410*SX)));if (dp.y<0.0) {let tmp=xray;let _e419=last_xray;xray=_e419;last_xray=tmp;}let _e420=y0_;y=_e420;loop {let _e422=y;let _e423=y1_;if (_e422<_e423) {} else {break;}{let _e425=y;let tile_y0_=(f32(_e425)*f32(TILE_HEIGHT));let _e430=xray;let xbackdrop=max((_e430+1),0);let _e439=config.width_in_tiles;if ((xymin.y<tile_y0_) && (xbackdrop<i32(_e439))) {let backdrop=select(-1,1,(dp.y<0.0));let _e449=y;let _e452=config.width_in_tiles;let tile_ix=((_e449*i32(_e452))+xbackdrop);let _e459=atomicAdd((&tiles[tile_ix].backdrop),backdrop);}let _e460=last_xray;next_xray=_e460;let _e462=y;let _e465=y1_;if ((_e462+1)<_e465) {let _e467=y;let tile_y1_=(f32((_e467+1))*f32(TILE_HEIGHT));let _e475=lp0_.x;let _e477=lp0_.y;let x_edge=(_e475+((tile_y1_-_e477)*b_1));next_xray=i32(floor((x_edge*SX)));}let _e484=xray;let _e485=next_xray;let min_xray=min(_e484,_e485);let _e487=xray;let _e488=next_xray;let max_xray=max(_e487,_e488);let _e490=xc;xx0_=min(i32(floor((_e490-c_2))),min_xray);let _e496=xc;xx1_=max(i32(ceil((_e496+c_2))),(max_xray+1));let _e504=xx0_;let _e505=x0_;let _e506=x1_;xx0_=clamp(_e504,_e505,_e506);let _e508=xx1_;let _e509=x0_;let _e510=x1_;xx1_=clamp(_e508,_e509,_e510);let _e513=xx0_;x=_e513;loop {let _e515=x;let _e516=xx1_;if (_e515<_e516) {} else {break;}{let _e518=x;let tile_x0_=(f32(_e518)*f32(TILE_WIDTH));let _e523=y;let _e526=config.width_in_tiles;let _e529=x;let tile_ix_1=((_e523*i32(_e526))+_e529);let _e531=alloc_segment();let _e535=atomicExchange((&tiles[tile_ix_1].segments),_e531);let _e537=lp0_;tile_seg.origin=_e537;tile_seg.delta=dp;let _e540=lp0_.y;let _e542=lp1_.y;let _e544=lp0_.x;y_edge=mix(_e540,_e542,((tile_x0_-_e544)*recip_dx));if (xymin.x<tile_x0_) {let _e551=y_edge;let p=vec2<f32>(tile_x0_,_e551);if (dp.x<0.0) {let _e557=lp0_;tile_seg.delta=(p-_e557);} else {tile_seg.origin=p;let _e561=lp1_;tile_seg.delta=(_e561-p);}let _e565=tile_seg.delta.x;if (_e565==0.0) {tile_seg.delta.x=(sign(dp.x)*9.999999717180685e-10);}}let _e574=x;let _e576=x;if ((_e574<=min_xray) || (max_xray<_e576)) {y_edge=1000000000.0;}let _e581=y_edge;tile_seg.y_edge=_e581;tile_seg.next=_e535;let _e585=tile_seg;segments[_e531]=_e585;}continuing {let _e587=x;x=(_e587+1);}}let _e589=xc;xc=(_e589+b_1);let _e591=next_xray;xray=_e591;}continuing {let _e593=y;y=(_e593+1);}}let _e596=n_out;n_out=(_e596+1u);let _e598=val_target;val_target=(_e598+v_step);let _e600=lp1_;lp0_=_e600;}}let _e602=val_sum;val_sum=(_e602+params.val);qp0_=_e244;}continuing {let _e605=i_1;i_1=(_e605+1u);}}return;} else {return;}}\n',
        workgroup_size: new WorkgroupSize( 256, 1, 1 ),
        bindings: [ 'Uniform', 'BufReadOnly', 'BufReadOnly', 'Buffer', 'Buffer' ],
        workgroup_buffers: []
      }, device ),
      path_coarse_full: new VelloShader( 'path_coarse_full', {
        wgsl: 'struct Config {width_in_tiles:u32,height_in_tiles:u32,target_width:u32,target_height:u32,base_color:u32,n_drawobj:u32,n_path:u32,n_clip:u32,bin_data_start:u32,pathtag_base:u32,pathdata_base:u32,drawtag_base:u32,drawdata_base:u32,transform_base:u32,linewidth_base:u32,binning_size:u32,tiles_size:u32,segments_size:u32,ptcl_size:u32,}struct TagMonoid {trans_ix:u32,pathseg_ix:u32,pathseg_offset:u32,linewidth_ix:u32,path_ix:u32,}struct Path {bbox:vec4<u32>,tiles:u32,}struct Tile {backdrop:i32,segments:u32,}struct Segment {origin:vec2<f32>,delta:vec2<f32>,y_edge:f32,next:u32,}struct Cubic {p0_:vec2<f32>,p1_:vec2<f32>,p2_:vec2<f32>,p3_:vec2<f32>,stroke:vec2<f32>,path_ix:u32,flags:u32,}struct BumpAllocators {failed:atomic<u32>,binning:atomic<u32>,ptcl:atomic<u32>,tile:atomic<u32>,segments:atomic<u32>,blend:atomic<u32>,}struct AtomicTile {backdrop:atomic<i32>,segments:atomic<u32>,}struct SubdivResult {val:f32,a0_:f32,a2_:f32,}const TILE_WIDTH:u32=16u;const TILE_HEIGHT:u32=16u;const N_TILE_X:u32=16u;const N_TILE_Y:u32=16u;const N_TILE:u32=256u;const BLEND_STACK_SPLIT:u32=4u;const RAD_GRAD_KIND_CIRCULAR:u32=1u;const RAD_GRAD_KIND_STRIP:u32=2u;const RAD_GRAD_KIND_FOCAL_ON_CIRCLE:u32=3u;const RAD_GRAD_KIND_CONE:u32=4u;const RAD_GRAD_SWAPPED:u32=1u;const PATH_TAG_SEG_TYPE:u32=3u;const PATH_TAG_LINETO:u32=1u;const PATH_TAG_QUADTO:u32=2u;const PATH_TAG_CUBICTO:u32=3u;const PATH_TAG_F32_:u32=8u;const PATH_TAG_TRANSFORM:u32=32u;const PATH_TAG_PATH:u32=16u;const PATH_TAG_LINEWIDTH:u32=64u;const CUBIC_IS_STROKE:u32=1u;const STAGE_BINNING:u32=1u;const STAGE_TILE_ALLOC:u32=2u;const STAGE_PATH_COARSE:u32=4u;const STAGE_COARSE:u32=8u;const D:f32=0.6700000166893005;const B:f32=0.38999998569488525;const MAX_QUADS:u32=16u;@group(0) @binding(0)\nvar<uniform>config:Config;@group(0) @binding(1)\nvar<storage>scene:array<u32>;@group(0) @binding(2)\nvar<storage>tag_monoids:array<TagMonoid>;@group(0) @binding(3)\nvar<storage>cubics:array<Cubic>;@group(0) @binding(4)\nvar<storage>paths:array<Path>;@group(0) @binding(5)\nvar<storage,read_write>bump:BumpAllocators;@group(0) @binding(6)\nvar<storage,read_write>tiles:array<AtomicTile>;@group(0) @binding(7)\nvar<storage,read_write>segments:array<Segment>;fn tag_monoid_identity()->TagMonoid {return TagMonoid(0u,0u,0u,0u,0u);}fn combine_tag_monoid(a:TagMonoid,b:TagMonoid)->TagMonoid {var c:TagMonoid;c.trans_ix=(a.trans_ix+b.trans_ix);c.pathseg_ix=(a.pathseg_ix+b.pathseg_ix);c.pathseg_offset=(a.pathseg_offset+b.pathseg_offset);c.linewidth_ix=(a.linewidth_ix+b.linewidth_ix);c.path_ix=(a.path_ix+b.path_ix);let _e23=c;return _e23;}fn reduce_tag(tag_word:u32)->TagMonoid {var c_1:TagMonoid;var a_1:u32;let point_count=(tag_word & 50529027u);c_1.pathseg_ix=countOneBits(((point_count*7u) & 67372036u));c_1.trans_ix=countOneBits((tag_word & (PATH_TAG_TRANSFORM*16843009u)));let n_points=(point_count+((tag_word>>2u) & 16843009u));a_1=(n_points+(n_points & (((tag_word>>3u) & 16843009u)*15u)));let _e30=a_1;let _e33=a_1;a_1=(_e33+(_e30>>8u));let _e35=a_1;let _e38=a_1;a_1=(_e38+(_e35>>16u));let _e41=a_1;c_1.pathseg_offset=(_e41 & 255u);c_1.path_ix=countOneBits((tag_word & (PATH_TAG_PATH*16843009u)));c_1.linewidth_ix=countOneBits((tag_word & (PATH_TAG_LINEWIDTH*16843009u)));let _e56=c_1;return _e56;}fn approx_parabola_integral(x_1:f32)->f32 {return (x_1*inverseSqrt(sqrt(((1.0-D)+((((D*D)*D)*D)+((0.25*x_1)*x_1))))));}fn approx_parabola_inv_integral(x_2:f32)->f32 {return (x_2*sqrt(((1.0-B)+((B*B)+((0.5*x_2)*x_2)))));}fn estimate_subdiv(p0_:vec2<f32>,p1_:vec2<f32>,p2_:vec2<f32>,sqrt_tol:f32)->SubdivResult {var val_1:f32;let d01_=(p1_-p0_);let d12_=(p2_-p1_);let dd=(d01_-d12_);let cross=(((p2_.x-p0_.x)*dd.y)-((p2_.y-p0_.y)*dd.x));let cross_inv=select((1.0 / cross),1000000000.0,(abs(cross)<9.999999717180685e-10));let x0_1=(dot(d01_,dd)*cross_inv);let x2_=(dot(d12_,dd)*cross_inv);let scale=abs((cross / (length(dd)*(x2_-x0_1))));let _e34=approx_parabola_integral(x0_1);let _e35=approx_parabola_integral(x2_);val_1=0.0;if (scale<1000000000.0) {let da=abs((_e35-_e34));let sqrt_scale=sqrt(scale);if (sign(x0_1)==sign(x2_)) {val_1=sqrt_scale;} else {let xmin=(sqrt_tol / sqrt_scale);let _e47=approx_parabola_integral(xmin);val_1=(sqrt_tol / _e47);}let _e49=val_1;val_1=(_e49*da);}let _e51=val_1;return SubdivResult(_e51,_e34,_e35);}fn eval_quad(p0_1:vec2<f32>,p1_1:vec2<f32>,p2_1:vec2<f32>,t:f32)->vec2<f32>{let mt=(1.0-t);return ((p0_1*(mt*mt))+(((p1_1*(mt*2.0))+(p2_1*t))*t));}fn eval_cubic(p0_2:vec2<f32>,p1_2:vec2<f32>,p2_2:vec2<f32>,p3_:vec2<f32>,t_1:f32)->vec2<f32>{let mt_1=(1.0-t_1);return ((p0_2*((mt_1*mt_1)*mt_1))+(((p1_2*((mt_1*mt_1)*3.0))+(((p2_2*(mt_1*3.0))+(p3_*t_1))*t_1))*t_1));}fn alloc_segment()->u32 {var offset:u32;let _e3=atomicAdd((&bump.segments),1u);offset=(_e3+1u);let _e7=offset;let _e12=config.segments_size;if ((_e7+1u)>_e12) {offset=0u;let _e18=atomicOr((&bump.failed),STAGE_PATH_COARSE);}let _e19=offset;return _e19;}@compute @workgroup_size(256,1,1)\nfn main(@builtin(global_invocation_id) global_id:vec3<u32>) {var tag_byte:u32;var n_quads:u32;var keep_params:array<SubdivResult,MAX_QUADS>;var val:f32;var qp0_:vec2<f32>;var i:u32;var qp1_:vec2<f32>;var lp0_:vec2<f32>;var n_out:u32;var val_sum:f32;var i_1:u32;var qp1_1:vec2<f32>;var val_target:f32;var lp1_:vec2<f32>;var x0_:i32;var x1_:i32;var y0_:i32;var y1_:i32;var xc:f32;var base:i32;var xray:i32;var last_xray:i32;var y:i32;var next_xray:i32;var xx0_:i32;var xx1_:i32;var tile_seg:Segment;var x:i32;var y_edge:f32;let _e3=atomicLoad((&bump.failed));if ((_e3 & (STAGE_BINNING | STAGE_TILE_ALLOC)) !=0u) {return;}let ix=global_id.x;let _e14=config.pathtag_base;let tag_word_1=scene[(_e14+(ix>>2u))];let shift=((ix & 3u)*8u);tag_byte=((tag_word_1>>shift) & 255u);let _e28=tag_byte;if ((_e28 & PATH_TAG_SEG_TYPE) !=0u) {let cubic=cubics[global_id.x];let path=paths[cubic.path_ix];let is_stroke=((cubic.flags & CUBIC_IS_STROKE) !=0u);let bbox=vec4<i32>(path.bbox);let p0_3=cubic.p0_;let p1_3=cubic.p1_;let p2_3=cubic.p2_;let p3_1=cubic.p3_;let err_v=(((3.0*(p2_3-p1_3))+p0_3)-p3_1);let err=dot(err_v,err_v);let Q_ACCURACY=(0.25*0.10000000149011612);let REM_ACCURACY=(0.25-Q_ACCURACY);let MAX_HYPOT2_=((432.0*Q_ACCURACY)*Q_ACCURACY);n_quads=max(u32(ceil(pow((err*(1.0 / MAX_HYPOT2_)),(1.0 / 6.0)))),1u);let _e77=n_quads;n_quads=min(_e77,MAX_QUADS);val=0.0;qp0_=p0_3;let _e85=n_quads;let step=(1.0 / f32(_e85));i=0u;loop {let _e90=i;let _e91=n_quads;if (_e90<_e91) {} else {break;}{let _e93=i;let t_2=(f32((_e93+1u))*step);let _e98=eval_cubic(p0_3,p1_3,p2_3,p3_1,t_2);let _e102=eval_cubic(p0_3,p1_3,p2_3,p3_1,(t_2-(0.5*step)));qp1_=_e102;let _e105=qp1_;let _e108=qp0_;qp1_=((2.0*_e105)-(0.5*(_e108+_e98)));let _e112=qp0_;let _e113=qp1_;let _e115=estimate_subdiv(_e112,_e113,_e98,sqrt(REM_ACCURACY));let _e116=i;keep_params[_e116]=_e115;let _e119=val;val=(_e119+_e115.val);qp0_=_e98;}continuing {let _e122=i;i=(_e122+1u);}}let _e124=val;let n=max(u32(ceil((_e124*(0.5 / sqrt(REM_ACCURACY))))),1u);lp0_=p0_3;qp0_=p0_3;let _e134=val;let v_step=(_e134 / f32(n));n_out=1u;val_sum=0.0;i_1=0u;loop {let _e143=i_1;let _e144=n_quads;if (_e143<_e144) {} else {break;}{let _e146=i_1;let t_3=(f32((_e146+1u))*step);let _e151=eval_cubic(p0_3,p1_3,p2_3,p3_1,t_3);let _e155=eval_cubic(p0_3,p1_3,p2_3,p3_1,(t_3-(0.5*step)));qp1_1=_e155;let _e158=qp1_1;let _e161=qp0_;qp1_1=((2.0*_e158)-(0.5*(_e161+_e151)));let _e165=i_1;let params=keep_params[_e165];let _e169=approx_parabola_inv_integral(params.a0_);let _e171=approx_parabola_inv_integral(params.a2_);let uscale=(1.0 / (_e171-_e169));let _e175=n_out;val_target=(f32(_e175)*v_step);loop {let _e179=n_out;let _e181=val_target;let _e182=val_sum;if ((_e179==n) || (_e181<(_e182+params.val))) {} else {break;}{let _e188=n_out;if (_e188==n) {lp1_=p3_1;} else {let _e190=val_target;let _e191=val_sum;let u=((_e190-_e191) / params.val);let a_2=mix(params.a0_,params.a2_,u);let _e198=approx_parabola_inv_integral(a_2);let t_4=((_e198-_e169)*uscale);let _e201=qp0_;let _e202=qp1_1;let _e203=eval_quad(_e201,_e202,_e151,t_4);lp1_=_e203;}let _e204=lp0_;let _e205=lp1_;let xymin=(min(_e204,_e205)-cubic.stroke);let _e209=lp0_;let _e210=lp1_;let xymax=(max(_e209,_e210)+cubic.stroke);let _e214=lp1_;let _e215=lp0_;let dp=(_e214-_e215);let recip_dx=(1.0 / dp.x);let b_1=select((dp.x / dp.y),1000000000.0,(abs(dp.y)<9.999999717180685e-10));let SX=(1.0 / f32(TILE_WIDTH));let SY=(1.0 / f32(TILE_HEIGHT));let c_2=((cubic.stroke.x+(abs(b_1)*((0.5*f32(TILE_HEIGHT))+cubic.stroke.y)))*SX);let _e251=lp0_.x;let _e253=lp0_.y;let a_3=((_e251-((_e253-(0.5*f32(TILE_HEIGHT)))*b_1))*SX);x0_=i32(floor((xymin.x*SX)));x1_=i32((floor((xymax.x*SX))+1.0));y0_=i32(floor((xymin.y*SY)));y1_=i32((floor((xymax.y*SY))+1.0));let _e286=x0_;x0_=clamp(_e286,bbox.x,bbox.z);let _e290=x1_;x1_=clamp(_e290,bbox.x,bbox.z);let _e294=y0_;y0_=clamp(_e294,bbox.y,bbox.w);let _e298=y1_;y1_=clamp(_e298,bbox.y,bbox.w);let _e302=y0_;xc=(a_3+(b_1*f32(_e302)));let stride=(bbox.z-bbox.x);let _e312=y0_;base=((i32(path.tiles)+((_e312-bbox.y)*stride))-bbox.x);let _e321=lp0_.x;xray=i32(floor((_e321*SX)));let _e327=lp1_.x;last_xray=i32(floor((_e327*SX)));if (dp.y<0.0) {let tmp=xray;let _e336=last_xray;xray=_e336;last_xray=tmp;}let _e337=y0_;y=_e337;loop {let _e339=y;let _e340=y1_;if (_e339<_e340) {} else {break;}{let _e342=y;let tile_y0_=(f32(_e342)*f32(TILE_HEIGHT));let _e347=xray;let xbackdrop=max((_e347+1),bbox.x);if ((!(is_stroke) && (xymin.y<tile_y0_)) && (xbackdrop<bbox.z)) {let backdrop=select(-1,1,(dp.y<0.0));let _e365=base;let tile_ix=(_e365+xbackdrop);let _e370=atomicAdd((&tiles[tile_ix].backdrop),backdrop);}let _e371=last_xray;next_xray=_e371;let _e373=y;let _e376=y1_;if ((_e373+1)<_e376) {let _e378=y;let tile_y1_=(f32((_e378+1))*f32(TILE_HEIGHT));let _e386=lp0_.x;let _e388=lp0_.y;let x_edge=(_e386+((tile_y1_-_e388)*b_1));next_xray=i32(floor((x_edge*SX)));}let _e395=xray;let _e396=next_xray;let min_xray=min(_e395,_e396);let _e398=xray;let _e399=next_xray;let max_xray=max(_e398,_e399);let _e401=xc;xx0_=min(i32(floor((_e401-c_2))),min_xray);let _e407=xc;xx1_=max(i32(ceil((_e407+c_2))),(max_xray+1));let _e415=xx0_;let _e416=x0_;let _e417=x1_;xx0_=clamp(_e415,_e416,_e417);let _e419=xx1_;let _e420=x0_;let _e421=x1_;xx1_=clamp(_e419,_e420,_e421);let _e424=xx0_;x=_e424;loop {let _e426=x;let _e427=xx1_;if (_e426<_e427) {} else {break;}{let _e429=x;let tile_x0_=(f32(_e429)*f32(TILE_WIDTH));let _e434=base;let _e435=x;let tile_ix_1=(_e434+_e435);let _e437=alloc_segment();let _e441=atomicExchange((&tiles[tile_ix_1].segments),_e437);let _e443=lp0_;tile_seg.origin=_e443;tile_seg.delta=dp;y_edge=0.0;if !(is_stroke) {let _e449=lp0_.y;let _e451=lp1_.y;let _e453=lp0_.x;y_edge=mix(_e449,_e451,((tile_x0_-_e453)*recip_dx));if (xymin.x<tile_x0_) {let _e459=y_edge;let p=vec2<f32>(tile_x0_,_e459);if (dp.x<0.0) {let _e465=lp0_;tile_seg.delta=(p-_e465);} else {tile_seg.origin=p;let _e469=lp1_;tile_seg.delta=(_e469-p);}let _e473=tile_seg.delta.x;if (_e473==0.0) {tile_seg.delta.x=(sign(dp.x)*9.999999717180685e-10);}}let _e482=x;let _e484=x;if ((_e482<=min_xray) || (max_xray<_e484)) {y_edge=1000000000.0;}}let _e489=y_edge;tile_seg.y_edge=_e489;tile_seg.next=_e441;let _e493=tile_seg;segments[_e437]=_e493;}continuing {let _e495=x;x=(_e495+1);}}let _e497=xc;xc=(_e497+b_1);let _e499=base;base=(_e499+stride);let _e501=next_xray;xray=_e501;}continuing {let _e503=y;y=(_e503+1);}}let _e506=n_out;n_out=(_e506+1u);let _e508=val_target;val_target=(_e508+v_step);let _e510=lp1_;lp0_=_e510;}}let _e512=val_sum;val_sum=(_e512+params.val);qp0_=_e151;}continuing {let _e515=i_1;i_1=(_e515+1u);}}return;} else {return;}}\n',
        workgroup_size: new WorkgroupSize( 256, 1, 1 ),
        bindings: [ 'Uniform', 'BufReadOnly', 'BufReadOnly', 'BufReadOnly', 'BufReadOnly', 'Buffer', 'Buffer', 'Buffer' ],
        workgroup_buffers: []
      }, device ),
      pathseg: new VelloShader( 'pathseg', {
        wgsl: 'struct Config {width_in_tiles:u32,height_in_tiles:u32,target_width:u32,target_height:u32,base_color:u32,n_drawobj:u32,n_path:u32,n_clip:u32,bin_data_start:u32,pathtag_base:u32,pathdata_base:u32,drawtag_base:u32,drawdata_base:u32,transform_base:u32,linewidth_base:u32,binning_size:u32,tiles_size:u32,segments_size:u32,ptcl_size:u32,}struct TagMonoid {trans_ix:u32,pathseg_ix:u32,pathseg_offset:u32,linewidth_ix:u32,path_ix:u32,}struct Cubic {p0_:vec2<f32>,p1_:vec2<f32>,p2_:vec2<f32>,p3_:vec2<f32>,stroke:vec2<f32>,path_ix:u32,flags:u32,}struct Transform {matrx:vec4<f32>,translate:vec2<f32>,}struct AtomicPathBbox {x0_:atomic<i32>,y0_:atomic<i32>,x1_:atomic<i32>,y1_:atomic<i32>,linewidth:f32,trans_ix:u32,}const TILE_WIDTH:u32=16u;const TILE_HEIGHT:u32=16u;const N_TILE_X:u32=16u;const N_TILE_Y:u32=16u;const N_TILE:u32=256u;const BLEND_STACK_SPLIT:u32=4u;const RAD_GRAD_KIND_CIRCULAR:u32=1u;const RAD_GRAD_KIND_STRIP:u32=2u;const RAD_GRAD_KIND_FOCAL_ON_CIRCLE:u32=3u;const RAD_GRAD_KIND_CONE:u32=4u;const RAD_GRAD_SWAPPED:u32=1u;const PATH_TAG_SEG_TYPE:u32=3u;const PATH_TAG_LINETO:u32=1u;const PATH_TAG_QUADTO:u32=2u;const PATH_TAG_CUBICTO:u32=3u;const PATH_TAG_F32_:u32=8u;const PATH_TAG_TRANSFORM:u32=32u;const PATH_TAG_PATH:u32=16u;const PATH_TAG_LINEWIDTH:u32=64u;const CUBIC_IS_STROKE:u32=1u;@group(0) @binding(0)\nvar<uniform>config:Config;@group(0) @binding(1)\nvar<storage>scene:array<u32>;@group(0) @binding(2)\nvar<storage>tag_monoids:array<TagMonoid>;@group(0) @binding(3)\nvar<storage,read_write>path_bboxes:array<AtomicPathBbox>;@group(0) @binding(4)\nvar<storage,read_write>cubics:array<Cubic>;var<private>pathdata_base:u32;fn tag_monoid_identity()->TagMonoid {return TagMonoid(0u,0u,0u,0u,0u);}fn combine_tag_monoid(a:TagMonoid,b:TagMonoid)->TagMonoid {var c:TagMonoid;c.trans_ix=(a.trans_ix+b.trans_ix);c.pathseg_ix=(a.pathseg_ix+b.pathseg_ix);c.pathseg_offset=(a.pathseg_offset+b.pathseg_offset);c.linewidth_ix=(a.linewidth_ix+b.linewidth_ix);c.path_ix=(a.path_ix+b.path_ix);let _e23=c;return _e23;}fn reduce_tag(tag_word:u32)->TagMonoid {var c_1:TagMonoid;var a_1:u32;let point_count=(tag_word & 50529027u);c_1.pathseg_ix=countOneBits(((point_count*7u) & 67372036u));c_1.trans_ix=countOneBits((tag_word & (PATH_TAG_TRANSFORM*16843009u)));let n_points=(point_count+((tag_word>>2u) & 16843009u));a_1=(n_points+(n_points & (((tag_word>>3u) & 16843009u)*15u)));let _e30=a_1;let _e33=a_1;a_1=(_e33+(_e30>>8u));let _e35=a_1;let _e38=a_1;a_1=(_e38+(_e35>>16u));let _e41=a_1;c_1.pathseg_offset=(_e41 & 255u);c_1.path_ix=countOneBits((tag_word & (PATH_TAG_PATH*16843009u)));c_1.linewidth_ix=countOneBits((tag_word & (PATH_TAG_LINEWIDTH*16843009u)));let _e56=c_1;return _e56;}fn transform_apply(transform:Transform,p:vec2<f32>)->vec2<f32>{return (((transform.matrx.xy*p.x)+(transform.matrx.zw*p.y))+transform.translate);}fn transform_inverse(transform_1:Transform)->Transform {let inv_det=(1.0 / ((transform_1.matrx.x*transform_1.matrx.w)-(transform_1.matrx.y*transform_1.matrx.z)));let inv_mat=(inv_det*vec4<f32>(transform_1.matrx.w,-(transform_1.matrx.y),-(transform_1.matrx.z),transform_1.matrx.x));let inv_tr=(mat2x2<f32>(inv_mat.xy,inv_mat.zw)*-(transform_1.translate));return Transform(inv_mat,inv_tr);}fn transform_mul(a_2:Transform,b_1:Transform)->Transform {return Transform(((a_2.matrx.xyxy*b_1.matrx.xxzz)+(a_2.matrx.zwzw*b_1.matrx.yyww)),(((a_2.matrx.xy*b_1.translate.x)+(a_2.matrx.zw*b_1.translate.y))+a_2.translate));}fn read_f32_point(ix:u32)->vec2<f32>{let _e3=pathdata_base;let _e6=scene[(_e3+ix)];let x_2=bitcast<f32>(_e6);let _e10=pathdata_base;let _e15=scene[((_e10+ix)+1u)];let y=bitcast<f32>(_e15);return vec2<f32>(x_2,y);}fn read_i16_point(ix_1:u32)->vec2<f32>{let _e3=pathdata_base;let raw=scene[(_e3+ix_1)];let x_3=f32((i32((raw<<16u))>>16u));let y_1=f32((i32(raw)>>16u));return vec2<f32>(x_3,y_1);}fn read_transform(transform_base:u32,ix_2:u32)->Transform {let base=(transform_base+(ix_2*6u));let _e7=scene[base];let c0_=bitcast<f32>(_e7);let _e13=scene[(base+1u)];let c1_=bitcast<f32>(_e13);let _e19=scene[(base+2u)];let c2_=bitcast<f32>(_e19);let _e25=scene[(base+3u)];let c3_=bitcast<f32>(_e25);let _e31=scene[(base+4u)];let c4_=bitcast<f32>(_e31);let _e37=scene[(base+5u)];let c5_=bitcast<f32>(_e37);let matrx=vec4<f32>(c0_,c1_,c2_,c3_);let translate=vec2<f32>(c4_,c5_);return Transform(matrx,translate);}fn round_down(x:f32)->i32 {return i32(floor(x));}fn round_up(x_1:f32)->i32 {return i32(ceil(x_1));}@compute @workgroup_size(256,1,1)\nfn main(@builtin(global_invocation_id) global_id:vec3<u32>,@builtin(local_invocation_id) local_id:vec3<u32>) {var tm:TagMonoid;var tag_byte:u32;var p0_:vec2<f32>;var p1_:vec2<f32>;var p2_:vec2<f32>;var p3_:vec2<f32>;var bbox:vec4<f32>;var stroke:vec2<f32>;let ix_3=global_id.x;let _e6=config.pathtag_base;let tag_word_1=scene[(_e6+(ix_3>>2u))];let _e15=config.pathdata_base;pathdata_base=_e15;let shift=((ix_3 & 3u)*8u);let _e25=reduce_tag((tag_word_1 & ((1u<<shift)-1u)));tm=_e25;let _e31=tag_monoids[(ix_3>>2u)];let _e32=tm;let _e33=combine_tag_monoid(_e31,_e32);tm=_e33;tag_byte=((tag_word_1>>shift) & 255u);let _e40=tm.path_ix;let out=(&path_bboxes[_e40]);let _e45=config.linewidth_base;let _e47=tm.linewidth_ix;let _e50=scene[(_e45+_e47)];let linewidth=bitcast<f32>(_e50);let _e52=tag_byte;if ((_e52 & PATH_TAG_PATH) !=0u) {(*out).linewidth=linewidth;let _e60=tm.trans_ix;(*out).trans_ix=_e60;}let _e61=tag_byte;let seg_type=(_e61 & PATH_TAG_SEG_TYPE);if (seg_type !=0u) {let _e70=tag_byte;if ((_e70 & PATH_TAG_F32_) !=0u) {let _e76=tm.pathseg_offset;let _e77=read_f32_point(_e76);p0_=_e77;let _e79=tm.pathseg_offset;let _e82=read_f32_point((_e79+2u));p1_=_e82;if (seg_type>=PATH_TAG_QUADTO) {let _e86=tm.pathseg_offset;let _e89=read_f32_point((_e86+4u));p2_=_e89;if (seg_type==PATH_TAG_CUBICTO) {let _e93=tm.pathseg_offset;let _e96=read_f32_point((_e93+6u));p3_=_e96;}}} else {let _e98=tm.pathseg_offset;let _e99=read_i16_point(_e98);p0_=_e99;let _e101=tm.pathseg_offset;let _e104=read_i16_point((_e101+1u));p1_=_e104;if (seg_type>=PATH_TAG_QUADTO) {let _e108=tm.pathseg_offset;let _e111=read_i16_point((_e108+2u));p2_=_e111;if (seg_type==PATH_TAG_CUBICTO) {let _e115=tm.pathseg_offset;let _e118=read_i16_point((_e115+3u));p3_=_e118;}}}let _e121=config.transform_base;let _e123=tm.trans_ix;let _e124=read_transform(_e121,_e123);let _e125=p0_;let _e126=transform_apply(_e124,_e125);p0_=_e126;let _e127=p1_;let _e128=transform_apply(_e124,_e127);p1_=_e128;let _e129=p0_;let _e130=p1_;let _e132=p0_;let _e133=p1_;bbox=vec4<f32>(min(_e129,_e130),max(_e132,_e133));if (seg_type==PATH_TAG_LINETO) {let _e139=p1_;p3_=_e139;let _e140=p3_;let _e141=p0_;p2_=mix(_e140,_e141,(1.0 / 3.0));let _e146=p0_;let _e147=p3_;p1_=mix(_e146,_e147,(1.0 / 3.0));} else {if (seg_type>=PATH_TAG_QUADTO) {let _e154=p2_;let _e155=transform_apply(_e124,_e154);p2_=_e155;let _e156=bbox;let _e158=p2_;let _e160=bbox;let _e162=p2_;bbox=vec4<f32>(min(_e156.xy,_e158),max(_e160.zw,_e162));if (seg_type==PATH_TAG_CUBICTO) {let _e167=p3_;let _e168=transform_apply(_e124,_e167);p3_=_e168;let _e169=bbox;let _e171=p3_;let _e173=bbox;let _e175=p3_;bbox=vec4<f32>(min(_e169.xy,_e171),max(_e173.zw,_e175));} else {let _e178=p2_;p3_=_e178;let _e179=p1_;let _e180=p2_;p2_=mix(_e179,_e180,(1.0 / 3.0));let _e185=p1_;let _e186=p0_;p1_=mix(_e185,_e186,(1.0 / 3.0));}}}stroke=vec2<f32>(0.0,0.0);if (linewidth>=0.0) {stroke=((0.5*linewidth)*vec2<f32>(length(_e124.matrx.xz),length(_e124.matrx.yw)));let _e207=stroke;let _e209=stroke;let _e211=bbox;bbox=(_e211+vec4<f32>(-(_e207),_e209));}let flags=u32((linewidth>=0.0));let _e219=p0_;let _e220=p1_;let _e221=p2_;let _e222=p3_;let _e223=stroke;let _e225=tm.path_ix;cubics[global_id.x]=Cubic(_e219,_e220,_e221,_e222,_e223,_e225,flags);let _e228=bbox.z;let _e230=bbox.x;let _e233=bbox.w;let _e235=bbox.y;if ((_e228>_e230) || (_e233>_e235)) {let _e240=bbox.x;let _e241=round_down(_e240);let _e242=atomicMin((&(*out).x0_),_e241);let _e245=bbox.y;let _e246=round_down(_e245);let _e247=atomicMin((&(*out).y0_),_e246);let _e250=bbox.z;let _e251=round_up(_e250);let _e252=atomicMax((&(*out).x1_),_e251);let _e255=bbox.w;let _e256=round_up(_e255);let _e257=atomicMax((&(*out).y1_),_e256);return;} else {return;}} else {return;}}\n',
        workgroup_size: new WorkgroupSize( 256, 1, 1 ),
        bindings: [ 'Uniform', 'BufReadOnly', 'BufReadOnly', 'Buffer', 'Buffer' ],
        workgroup_buffers: []
      }, device ),
      pathtag_reduce: new VelloShader( 'pathtag_reduce', {
        wgsl: 'struct Config {width_in_tiles:u32,height_in_tiles:u32,target_width:u32,target_height:u32,base_color:u32,n_drawobj:u32,n_path:u32,n_clip:u32,bin_data_start:u32,pathtag_base:u32,pathdata_base:u32,drawtag_base:u32,drawdata_base:u32,transform_base:u32,linewidth_base:u32,binning_size:u32,tiles_size:u32,segments_size:u32,ptcl_size:u32,}struct TagMonoid {trans_ix:u32,pathseg_ix:u32,pathseg_offset:u32,linewidth_ix:u32,path_ix:u32,}const TILE_WIDTH:u32=16u;const TILE_HEIGHT:u32=16u;const N_TILE_X:u32=16u;const N_TILE_Y:u32=16u;const N_TILE:u32=256u;const BLEND_STACK_SPLIT:u32=4u;const RAD_GRAD_KIND_CIRCULAR:u32=1u;const RAD_GRAD_KIND_STRIP:u32=2u;const RAD_GRAD_KIND_FOCAL_ON_CIRCLE:u32=3u;const RAD_GRAD_KIND_CONE:u32=4u;const RAD_GRAD_SWAPPED:u32=1u;const PATH_TAG_SEG_TYPE:u32=3u;const PATH_TAG_LINETO:u32=1u;const PATH_TAG_QUADTO:u32=2u;const PATH_TAG_CUBICTO:u32=3u;const PATH_TAG_F32_:u32=8u;const PATH_TAG_TRANSFORM:u32=32u;const PATH_TAG_PATH:u32=16u;const PATH_TAG_LINEWIDTH:u32=64u;const LG_WG_SIZE:u32=8u;const WG_SIZE:u32=256u;@group(0) @binding(0)\nvar<uniform>config:Config;@group(0) @binding(1)\nvar<storage>scene:array<u32>;@group(0) @binding(2)\nvar<storage,read_write>reduced:array<TagMonoid>;var<workgroup>sh_scratch:array<TagMonoid,WG_SIZE>;fn tag_monoid_identity()->TagMonoid {return TagMonoid(0u,0u,0u,0u,0u);}fn combine_tag_monoid(a:TagMonoid,b:TagMonoid)->TagMonoid {var c:TagMonoid;c.trans_ix=(a.trans_ix+b.trans_ix);c.pathseg_ix=(a.pathseg_ix+b.pathseg_ix);c.pathseg_offset=(a.pathseg_offset+b.pathseg_offset);c.linewidth_ix=(a.linewidth_ix+b.linewidth_ix);c.path_ix=(a.path_ix+b.path_ix);let _e23=c;return _e23;}fn reduce_tag(tag_word:u32)->TagMonoid {var c_1:TagMonoid;var a_1:u32;let point_count=(tag_word & 50529027u);c_1.pathseg_ix=countOneBits(((point_count*7u) & 67372036u));c_1.trans_ix=countOneBits((tag_word & (PATH_TAG_TRANSFORM*16843009u)));let n_points=(point_count+((tag_word>>2u) & 16843009u));a_1=(n_points+(n_points & (((tag_word>>3u) & 16843009u)*15u)));let _e30=a_1;let _e33=a_1;a_1=(_e33+(_e30>>8u));let _e35=a_1;let _e38=a_1;a_1=(_e38+(_e35>>16u));let _e41=a_1;c_1.pathseg_offset=(_e41 & 255u);c_1.path_ix=countOneBits((tag_word & (PATH_TAG_PATH*16843009u)));c_1.linewidth_ix=countOneBits((tag_word & (PATH_TAG_LINEWIDTH*16843009u)));let _e56=c_1;return _e56;}@compute @workgroup_size(256,1,1)\nfn main(@builtin(global_invocation_id) global_id:vec3<u32>,@builtin(local_invocation_id) local_id:vec3<u32>) {var agg:TagMonoid;var i:u32;let ix=global_id.x;let _e6=config.pathtag_base;let tag_word_1=scene[(_e6+ix)];let _e10=reduce_tag(tag_word_1);agg=_e10;let _e15=agg;sh_scratch[local_id.x]=_e15;i=0u;loop {let _e18=i;if (_e18<firstTrailingBit(WG_SIZE)) {} else {break;}{workgroupBarrier();let _e24=i;if ((local_id.x+(1u<<_e24))<WG_SIZE) {let _e32=i;let other=sh_scratch[(local_id.x+(1u<<_e32))];let _e37=agg;let _e38=combine_tag_monoid(_e37,other);agg=_e38;}workgroupBarrier();let _e42=agg;sh_scratch[local_id.x]=_e42;}continuing {let _e44=i;i=(_e44+1u);}}if (local_id.x==0u) {let _e53=agg;reduced[(ix>>LG_WG_SIZE)]=_e53;return;} else {return;}}\n',
        workgroup_size: new WorkgroupSize( 256, 1, 1 ),
        bindings: [ 'Uniform', 'BufReadOnly', 'Buffer' ],
        workgroup_buffers: [
          { size_in_bytes: 5120, index: 0 }
        ]
      }, device ),
      pathtag_reduce2: new VelloShader( 'pathtag_reduce2', {
        wgsl: 'struct Config {width_in_tiles:u32,height_in_tiles:u32,target_width:u32,target_height:u32,base_color:u32,n_drawobj:u32,n_path:u32,n_clip:u32,bin_data_start:u32,pathtag_base:u32,pathdata_base:u32,drawtag_base:u32,drawdata_base:u32,transform_base:u32,linewidth_base:u32,binning_size:u32,tiles_size:u32,segments_size:u32,ptcl_size:u32,}struct TagMonoid {trans_ix:u32,pathseg_ix:u32,pathseg_offset:u32,linewidth_ix:u32,path_ix:u32,}const TILE_WIDTH:u32=16u;const TILE_HEIGHT:u32=16u;const N_TILE_X:u32=16u;const N_TILE_Y:u32=16u;const N_TILE:u32=256u;const BLEND_STACK_SPLIT:u32=4u;const RAD_GRAD_KIND_CIRCULAR:u32=1u;const RAD_GRAD_KIND_STRIP:u32=2u;const RAD_GRAD_KIND_FOCAL_ON_CIRCLE:u32=3u;const RAD_GRAD_KIND_CONE:u32=4u;const RAD_GRAD_SWAPPED:u32=1u;const PATH_TAG_SEG_TYPE:u32=3u;const PATH_TAG_LINETO:u32=1u;const PATH_TAG_QUADTO:u32=2u;const PATH_TAG_CUBICTO:u32=3u;const PATH_TAG_F32_:u32=8u;const PATH_TAG_TRANSFORM:u32=32u;const PATH_TAG_PATH:u32=16u;const PATH_TAG_LINEWIDTH:u32=64u;const LG_WG_SIZE:u32=8u;const WG_SIZE:u32=256u;@group(0) @binding(0)\nvar<storage>reduced_in:array<TagMonoid>;@group(0) @binding(1)\nvar<storage,read_write>reduced:array<TagMonoid>;var<workgroup>sh_scratch:array<TagMonoid,WG_SIZE>;fn tag_monoid_identity()->TagMonoid {return TagMonoid(0u,0u,0u,0u,0u);}fn combine_tag_monoid(a:TagMonoid,b:TagMonoid)->TagMonoid {var c:TagMonoid;c.trans_ix=(a.trans_ix+b.trans_ix);c.pathseg_ix=(a.pathseg_ix+b.pathseg_ix);c.pathseg_offset=(a.pathseg_offset+b.pathseg_offset);c.linewidth_ix=(a.linewidth_ix+b.linewidth_ix);c.path_ix=(a.path_ix+b.path_ix);let _e23=c;return _e23;}fn reduce_tag(tag_word:u32)->TagMonoid {var c_1:TagMonoid;var a_1:u32;let point_count=(tag_word & 50529027u);c_1.pathseg_ix=countOneBits(((point_count*7u) & 67372036u));c_1.trans_ix=countOneBits((tag_word & (PATH_TAG_TRANSFORM*16843009u)));let n_points=(point_count+((tag_word>>2u) & 16843009u));a_1=(n_points+(n_points & (((tag_word>>3u) & 16843009u)*15u)));let _e30=a_1;let _e33=a_1;a_1=(_e33+(_e30>>8u));let _e35=a_1;let _e38=a_1;a_1=(_e38+(_e35>>16u));let _e41=a_1;c_1.pathseg_offset=(_e41 & 255u);c_1.path_ix=countOneBits((tag_word & (PATH_TAG_PATH*16843009u)));c_1.linewidth_ix=countOneBits((tag_word & (PATH_TAG_LINEWIDTH*16843009u)));let _e56=c_1;return _e56;}@compute @workgroup_size(256,1,1)\nfn main(@builtin(global_invocation_id) global_id:vec3<u32>,@builtin(local_invocation_id) local_id:vec3<u32>) {var agg:TagMonoid;var i:u32;let ix=global_id.x;let _e5=reduced_in[ix];agg=_e5;let _e10=agg;sh_scratch[local_id.x]=_e10;i=0u;loop {let _e13=i;if (_e13<firstTrailingBit(WG_SIZE)) {} else {break;}{workgroupBarrier();let _e19=i;if ((local_id.x+(1u<<_e19))<WG_SIZE) {let _e27=i;let other=sh_scratch[(local_id.x+(1u<<_e27))];let _e32=agg;let _e33=combine_tag_monoid(_e32,other);agg=_e33;}workgroupBarrier();let _e37=agg;sh_scratch[local_id.x]=_e37;}continuing {let _e39=i;i=(_e39+1u);}}if (local_id.x==0u) {let _e48=agg;reduced[(ix>>LG_WG_SIZE)]=_e48;return;} else {return;}}\n',
        workgroup_size: new WorkgroupSize( 256, 1, 1 ),
        bindings: [ 'BufReadOnly', 'Buffer' ],
        workgroup_buffers: [
          { size_in_bytes: 5120, index: 0 }
        ]
      }, device ),
      pathtag_scan1: new VelloShader( 'pathtag_scan1', {
        wgsl: 'struct Config {width_in_tiles:u32,height_in_tiles:u32,target_width:u32,target_height:u32,base_color:u32,n_drawobj:u32,n_path:u32,n_clip:u32,bin_data_start:u32,pathtag_base:u32,pathdata_base:u32,drawtag_base:u32,drawdata_base:u32,transform_base:u32,linewidth_base:u32,binning_size:u32,tiles_size:u32,segments_size:u32,ptcl_size:u32,}struct TagMonoid {trans_ix:u32,pathseg_ix:u32,pathseg_offset:u32,linewidth_ix:u32,path_ix:u32,}const TILE_WIDTH:u32=16u;const TILE_HEIGHT:u32=16u;const N_TILE_X:u32=16u;const N_TILE_Y:u32=16u;const N_TILE:u32=256u;const BLEND_STACK_SPLIT:u32=4u;const RAD_GRAD_KIND_CIRCULAR:u32=1u;const RAD_GRAD_KIND_STRIP:u32=2u;const RAD_GRAD_KIND_FOCAL_ON_CIRCLE:u32=3u;const RAD_GRAD_KIND_CONE:u32=4u;const RAD_GRAD_SWAPPED:u32=1u;const PATH_TAG_SEG_TYPE:u32=3u;const PATH_TAG_LINETO:u32=1u;const PATH_TAG_QUADTO:u32=2u;const PATH_TAG_CUBICTO:u32=3u;const PATH_TAG_F32_:u32=8u;const PATH_TAG_TRANSFORM:u32=32u;const PATH_TAG_PATH:u32=16u;const PATH_TAG_LINEWIDTH:u32=64u;const LG_WG_SIZE:u32=8u;const WG_SIZE:u32=256u;@group(0) @binding(0)\nvar<storage>reduced:array<TagMonoid>;@group(0) @binding(1)\nvar<storage>reduced2_:array<TagMonoid>;@group(0) @binding(2)\nvar<storage,read_write>tag_monoids:array<TagMonoid>;var<workgroup>sh_parent:array<TagMonoid,WG_SIZE>;var<workgroup>sh_monoid:array<TagMonoid,WG_SIZE>;fn tag_monoid_identity()->TagMonoid {return TagMonoid(0u,0u,0u,0u,0u);}fn combine_tag_monoid(a:TagMonoid,b:TagMonoid)->TagMonoid {var c:TagMonoid;c.trans_ix=(a.trans_ix+b.trans_ix);c.pathseg_ix=(a.pathseg_ix+b.pathseg_ix);c.pathseg_offset=(a.pathseg_offset+b.pathseg_offset);c.linewidth_ix=(a.linewidth_ix+b.linewidth_ix);c.path_ix=(a.path_ix+b.path_ix);let _e23=c;return _e23;}fn reduce_tag(tag_word:u32)->TagMonoid {var c_1:TagMonoid;var a_1:u32;let point_count=(tag_word & 50529027u);c_1.pathseg_ix=countOneBits(((point_count*7u) & 67372036u));c_1.trans_ix=countOneBits((tag_word & (PATH_TAG_TRANSFORM*16843009u)));let n_points=(point_count+((tag_word>>2u) & 16843009u));a_1=(n_points+(n_points & (((tag_word>>3u) & 16843009u)*15u)));let _e30=a_1;let _e33=a_1;a_1=(_e33+(_e30>>8u));let _e35=a_1;let _e38=a_1;a_1=(_e38+(_e35>>16u));let _e41=a_1;c_1.pathseg_offset=(_e41 & 255u);c_1.path_ix=countOneBits((tag_word & (PATH_TAG_PATH*16843009u)));c_1.linewidth_ix=countOneBits((tag_word & (PATH_TAG_LINEWIDTH*16843009u)));let _e56=c_1;return _e56;}@compute @workgroup_size(256,1,1)\nfn main(@builtin(global_invocation_id) global_id:vec3<u32>,@builtin(local_invocation_id) local_id:vec3<u32>,@builtin(workgroup_id) wg_id:vec3<u32>) {var agg:TagMonoid;var i:u32;var i_1:u32;var tm:TagMonoid;let _e3=tag_monoid_identity();agg=_e3;if (local_id.x<wg_id.x) {let _e11=reduced2_[local_id.x];agg=_e11;}let _e15=agg;sh_parent[local_id.x]=_e15;i=0u;loop {let _e18=i;if (_e18<LG_WG_SIZE) {} else {break;}{workgroupBarrier();let _e23=i;if ((local_id.x+(1u<<_e23))<WG_SIZE) {let _e31=i;let other=sh_parent[(local_id.x+(1u<<_e31))];let _e36=agg;let _e37=combine_tag_monoid(_e36,other);agg=_e37;}workgroupBarrier();let _e41=agg;sh_parent[local_id.x]=_e41;}continuing {let _e43=i;i=(_e43+1u);}}let ix=global_id.x;let _e48=reduced[ix];agg=_e48;let _e52=agg;sh_monoid[local_id.x]=_e52;i_1=0u;loop {let _e55=i_1;if (_e55<LG_WG_SIZE) {} else {break;}{workgroupBarrier();let _e60=i_1;if (local_id.x>=(1u<<_e60)) {let _e66=i_1;let other_1=sh_monoid[(local_id.x-(1u<<_e66))];let _e71=agg;let _e72=combine_tag_monoid(other_1,_e71);agg=_e72;}workgroupBarrier();let _e76=agg;sh_monoid[local_id.x]=_e76;}continuing {let _e78=i_1;i_1=(_e78+1u);}}workgroupBarrier();let _e83=sh_parent[0];tm=_e83;if (local_id.x>0u) {let _e88=tm;let _e94=sh_monoid[(local_id.x-1u)];let _e95=combine_tag_monoid(_e88,_e94);tm=_e95;}let _e98=tm;tag_monoids[ix]=_e98;return;}\n',
        workgroup_size: new WorkgroupSize( 256, 1, 1 ),
        bindings: [ 'BufReadOnly', 'BufReadOnly', 'Buffer' ],
        workgroup_buffers: [
          { size_in_bytes: 5120, index: 0 },
          { size_in_bytes: 5120, index: 1 }
        ]
      }, device ),
      pathtag_scan_large: new VelloShader( 'pathtag_scan_large', {
        wgsl: 'struct Config {width_in_tiles:u32,height_in_tiles:u32,target_width:u32,target_height:u32,base_color:u32,n_drawobj:u32,n_path:u32,n_clip:u32,bin_data_start:u32,pathtag_base:u32,pathdata_base:u32,drawtag_base:u32,drawdata_base:u32,transform_base:u32,linewidth_base:u32,binning_size:u32,tiles_size:u32,segments_size:u32,ptcl_size:u32,}struct TagMonoid {trans_ix:u32,pathseg_ix:u32,pathseg_offset:u32,linewidth_ix:u32,path_ix:u32,}const TILE_WIDTH:u32=16u;const TILE_HEIGHT:u32=16u;const N_TILE_X:u32=16u;const N_TILE_Y:u32=16u;const N_TILE:u32=256u;const BLEND_STACK_SPLIT:u32=4u;const RAD_GRAD_KIND_CIRCULAR:u32=1u;const RAD_GRAD_KIND_STRIP:u32=2u;const RAD_GRAD_KIND_FOCAL_ON_CIRCLE:u32=3u;const RAD_GRAD_KIND_CONE:u32=4u;const RAD_GRAD_SWAPPED:u32=1u;const PATH_TAG_SEG_TYPE:u32=3u;const PATH_TAG_LINETO:u32=1u;const PATH_TAG_QUADTO:u32=2u;const PATH_TAG_CUBICTO:u32=3u;const PATH_TAG_F32_:u32=8u;const PATH_TAG_TRANSFORM:u32=32u;const PATH_TAG_PATH:u32=16u;const PATH_TAG_LINEWIDTH:u32=64u;const LG_WG_SIZE:u32=8u;const WG_SIZE:u32=256u;@group(0) @binding(0)\nvar<uniform>config:Config;@group(0) @binding(1)\nvar<storage>scene:array<u32>;@group(0) @binding(2)\nvar<storage>reduced:array<TagMonoid>;@group(0) @binding(3)\nvar<storage,read_write>tag_monoids:array<TagMonoid>;var<workgroup>sh_monoid:array<TagMonoid,WG_SIZE>;fn tag_monoid_identity()->TagMonoid {return TagMonoid(0u,0u,0u,0u,0u);}fn combine_tag_monoid(a:TagMonoid,b:TagMonoid)->TagMonoid {var c:TagMonoid;c.trans_ix=(a.trans_ix+b.trans_ix);c.pathseg_ix=(a.pathseg_ix+b.pathseg_ix);c.pathseg_offset=(a.pathseg_offset+b.pathseg_offset);c.linewidth_ix=(a.linewidth_ix+b.linewidth_ix);c.path_ix=(a.path_ix+b.path_ix);let _e23=c;return _e23;}fn reduce_tag(tag_word:u32)->TagMonoid {var c_1:TagMonoid;var a_1:u32;let point_count=(tag_word & 50529027u);c_1.pathseg_ix=countOneBits(((point_count*7u) & 67372036u));c_1.trans_ix=countOneBits((tag_word & (PATH_TAG_TRANSFORM*16843009u)));let n_points=(point_count+((tag_word>>2u) & 16843009u));a_1=(n_points+(n_points & (((tag_word>>3u) & 16843009u)*15u)));let _e30=a_1;let _e33=a_1;a_1=(_e33+(_e30>>8u));let _e35=a_1;let _e38=a_1;a_1=(_e38+(_e35>>16u));let _e41=a_1;c_1.pathseg_offset=(_e41 & 255u);c_1.path_ix=countOneBits((tag_word & (PATH_TAG_PATH*16843009u)));c_1.linewidth_ix=countOneBits((tag_word & (PATH_TAG_LINEWIDTH*16843009u)));let _e56=c_1;return _e56;}@compute @workgroup_size(256,1,1)\nfn main(@builtin(global_invocation_id) global_id:vec3<u32>,@builtin(local_invocation_id) local_id:vec3<u32>,@builtin(workgroup_id) wg_id:vec3<u32>) {var agg_part:TagMonoid;var i:u32;var tm:TagMonoid;let ix=global_id.x;let _e7=config.pathtag_base;let tag_word_1=scene[(_e7+ix)];let _e11=reduce_tag(tag_word_1);agg_part=_e11;let _e16=agg_part;sh_monoid[local_id.x]=_e16;i=0u;loop {let _e19=i;if (_e19<LG_WG_SIZE) {} else {break;}{workgroupBarrier();let _e24=i;if (local_id.x>=(1u<<_e24)) {let _e30=i;let other=sh_monoid[(local_id.x-(1u<<_e30))];let _e35=agg_part;let _e36=combine_tag_monoid(other,_e35);agg_part=_e36;}workgroupBarrier();let _e40=agg_part;sh_monoid[local_id.x]=_e40;}continuing {let _e42=i;i=(_e42+1u);}}workgroupBarrier();let _e47=reduced[wg_id.x];tm=_e47;if (local_id.x>0u) {let _e52=tm;let _e58=sh_monoid[(local_id.x-1u)];let _e59=combine_tag_monoid(_e52,_e58);tm=_e59;}let _e62=tm;tag_monoids[ix]=_e62;return;}\n',
        workgroup_size: new WorkgroupSize( 256, 1, 1 ),
        bindings: [ 'Uniform', 'BufReadOnly', 'BufReadOnly', 'Buffer' ],
        workgroup_buffers: [
          { size_in_bytes: 5120, index: 0 }
        ]
      }, device ),
      pathtag_scan_small: new VelloShader( 'pathtag_scan_small', {
        wgsl: 'struct Config {width_in_tiles:u32,height_in_tiles:u32,target_width:u32,target_height:u32,base_color:u32,n_drawobj:u32,n_path:u32,n_clip:u32,bin_data_start:u32,pathtag_base:u32,pathdata_base:u32,drawtag_base:u32,drawdata_base:u32,transform_base:u32,linewidth_base:u32,binning_size:u32,tiles_size:u32,segments_size:u32,ptcl_size:u32,}struct TagMonoid {trans_ix:u32,pathseg_ix:u32,pathseg_offset:u32,linewidth_ix:u32,path_ix:u32,}const TILE_WIDTH:u32=16u;const TILE_HEIGHT:u32=16u;const N_TILE_X:u32=16u;const N_TILE_Y:u32=16u;const N_TILE:u32=256u;const BLEND_STACK_SPLIT:u32=4u;const RAD_GRAD_KIND_CIRCULAR:u32=1u;const RAD_GRAD_KIND_STRIP:u32=2u;const RAD_GRAD_KIND_FOCAL_ON_CIRCLE:u32=3u;const RAD_GRAD_KIND_CONE:u32=4u;const RAD_GRAD_SWAPPED:u32=1u;const PATH_TAG_SEG_TYPE:u32=3u;const PATH_TAG_LINETO:u32=1u;const PATH_TAG_QUADTO:u32=2u;const PATH_TAG_CUBICTO:u32=3u;const PATH_TAG_F32_:u32=8u;const PATH_TAG_TRANSFORM:u32=32u;const PATH_TAG_PATH:u32=16u;const PATH_TAG_LINEWIDTH:u32=64u;const LG_WG_SIZE:u32=8u;const WG_SIZE:u32=256u;@group(0) @binding(0)\nvar<uniform>config:Config;@group(0) @binding(1)\nvar<storage>scene:array<u32>;@group(0) @binding(2)\nvar<storage>reduced:array<TagMonoid>;@group(0) @binding(3)\nvar<storage,read_write>tag_monoids:array<TagMonoid>;var<workgroup>sh_parent:array<TagMonoid,WG_SIZE>;var<workgroup>sh_monoid:array<TagMonoid,WG_SIZE>;fn tag_monoid_identity()->TagMonoid {return TagMonoid(0u,0u,0u,0u,0u);}fn combine_tag_monoid(a:TagMonoid,b:TagMonoid)->TagMonoid {var c:TagMonoid;c.trans_ix=(a.trans_ix+b.trans_ix);c.pathseg_ix=(a.pathseg_ix+b.pathseg_ix);c.pathseg_offset=(a.pathseg_offset+b.pathseg_offset);c.linewidth_ix=(a.linewidth_ix+b.linewidth_ix);c.path_ix=(a.path_ix+b.path_ix);let _e23=c;return _e23;}fn reduce_tag(tag_word:u32)->TagMonoid {var c_1:TagMonoid;var a_1:u32;let point_count=(tag_word & 50529027u);c_1.pathseg_ix=countOneBits(((point_count*7u) & 67372036u));c_1.trans_ix=countOneBits((tag_word & (PATH_TAG_TRANSFORM*16843009u)));let n_points=(point_count+((tag_word>>2u) & 16843009u));a_1=(n_points+(n_points & (((tag_word>>3u) & 16843009u)*15u)));let _e30=a_1;let _e33=a_1;a_1=(_e33+(_e30>>8u));let _e35=a_1;let _e38=a_1;a_1=(_e38+(_e35>>16u));let _e41=a_1;c_1.pathseg_offset=(_e41 & 255u);c_1.path_ix=countOneBits((tag_word & (PATH_TAG_PATH*16843009u)));c_1.linewidth_ix=countOneBits((tag_word & (PATH_TAG_LINEWIDTH*16843009u)));let _e56=c_1;return _e56;}@compute @workgroup_size(256,1,1)\nfn main(@builtin(global_invocation_id) global_id:vec3<u32>,@builtin(local_invocation_id) local_id:vec3<u32>,@builtin(workgroup_id) wg_id:vec3<u32>) {var agg:TagMonoid;var i:u32;var agg_part:TagMonoid;var i_1:u32;var tm:TagMonoid;let _e3=tag_monoid_identity();agg=_e3;if (local_id.x<wg_id.x) {let _e11=reduced[local_id.x];agg=_e11;}let _e15=agg;sh_parent[local_id.x]=_e15;i=0u;loop {let _e18=i;if (_e18<LG_WG_SIZE) {} else {break;}{workgroupBarrier();let _e23=i;if ((local_id.x+(1u<<_e23))<WG_SIZE) {let _e31=i;let other=sh_parent[(local_id.x+(1u<<_e31))];let _e36=agg;let _e37=combine_tag_monoid(_e36,other);agg=_e37;}workgroupBarrier();let _e41=agg;sh_parent[local_id.x]=_e41;}continuing {let _e43=i;i=(_e43+1u);}}let ix=global_id.x;let _e49=config.pathtag_base;let tag_word_1=scene[(_e49+ix)];let _e53=reduce_tag(tag_word_1);agg_part=_e53;let _e58=agg_part;sh_monoid[local_id.x]=_e58;i_1=0u;loop {let _e61=i_1;if (_e61<LG_WG_SIZE) {} else {break;}{workgroupBarrier();let _e66=i_1;if (local_id.x>=(1u<<_e66)) {let _e72=i_1;let other_1=sh_monoid[(local_id.x-(1u<<_e72))];let _e77=agg_part;let _e78=combine_tag_monoid(other_1,_e77);agg_part=_e78;}workgroupBarrier();let _e82=agg_part;sh_monoid[local_id.x]=_e82;}continuing {let _e84=i_1;i_1=(_e84+1u);}}workgroupBarrier();let _e89=sh_parent[0];tm=_e89;if (local_id.x>0u) {let _e94=tm;let _e100=sh_monoid[(local_id.x-1u)];let _e101=combine_tag_monoid(_e94,_e100);tm=_e101;}let _e104=tm;tag_monoids[ix]=_e104;return;}\n',
        workgroup_size: new WorkgroupSize( 256, 1, 1 ),
        bindings: [ 'Uniform', 'BufReadOnly', 'BufReadOnly', 'Buffer' ],
        workgroup_buffers: [
          { size_in_bytes: 5120, index: 0 },
          { size_in_bytes: 5120, index: 1 }
        ]
      }, device ),
      tile_alloc: new VelloShader( 'tile_alloc', {
        wgsl: 'struct Config {width_in_tiles:u32,height_in_tiles:u32,target_width:u32,target_height:u32,base_color:u32,n_drawobj:u32,n_path:u32,n_clip:u32,bin_data_start:u32,pathtag_base:u32,pathdata_base:u32,drawtag_base:u32,drawdata_base:u32,transform_base:u32,linewidth_base:u32,binning_size:u32,tiles_size:u32,segments_size:u32,ptcl_size:u32,}struct BumpAllocators {failed:atomic<u32>,binning:atomic<u32>,ptcl:atomic<u32>,tile:atomic<u32>,segments:atomic<u32>,blend:atomic<u32>,}struct DrawMonoid {path_ix:u32,clip_ix:u32,scene_offset:u32,info_offset:u32,}struct Path {bbox:vec4<u32>,tiles:u32,}struct Tile {backdrop:i32,segments:u32,}const TILE_WIDTH:u32=16u;const TILE_HEIGHT:u32=16u;const N_TILE_X:u32=16u;const N_TILE_Y:u32=16u;const N_TILE:u32=256u;const BLEND_STACK_SPLIT:u32=4u;const RAD_GRAD_KIND_CIRCULAR:u32=1u;const RAD_GRAD_KIND_STRIP:u32=2u;const RAD_GRAD_KIND_FOCAL_ON_CIRCLE:u32=3u;const RAD_GRAD_KIND_CONE:u32=4u;const RAD_GRAD_SWAPPED:u32=1u;const STAGE_BINNING:u32=1u;const STAGE_TILE_ALLOC:u32=2u;const STAGE_PATH_COARSE:u32=4u;const STAGE_COARSE:u32=8u;const DRAWTAG_NOP:u32=0u;const DRAWTAG_FILL_COLOR:u32=68u;const DRAWTAG_FILL_LIN_GRADIENT:u32=276u;const DRAWTAG_FILL_RAD_GRADIENT:u32=668u;const DRAWTAG_FILL_IMAGE:u32=584u;const DRAWTAG_BEGIN_CLIP:u32=9u;const DRAWTAG_END_CLIP:u32=33u;const WG_SIZE:u32=256u;@group(0) @binding(0)\nvar<uniform>config:Config;@group(0) @binding(1)\nvar<storage>scene:array<u32>;@group(0) @binding(2)\nvar<storage>draw_bboxes:array<vec4<f32>>;@group(0) @binding(3)\nvar<storage,read_write>bump:BumpAllocators;@group(0) @binding(4)\nvar<storage,read_write>paths:array<Path>;@group(0) @binding(5)\nvar<storage,read_write>tiles:array<Tile>;var<workgroup>sh_tile_count:array<u32,WG_SIZE>;var<workgroup>sh_tile_offset:u32;fn draw_monoid_identity()->DrawMonoid {return DrawMonoid(0u,0u,0u,0u);}fn combine_draw_monoid(a:DrawMonoid,b:DrawMonoid)->DrawMonoid {var c:DrawMonoid;c.path_ix=(a.path_ix+b.path_ix);c.clip_ix=(a.clip_ix+b.clip_ix);c.scene_offset=(a.scene_offset+b.scene_offset);c.info_offset=(a.info_offset+b.info_offset);let _e19=c;return _e19;}fn map_draw_tag(tag_word:u32)->DrawMonoid {var c_1:DrawMonoid;c_1.path_ix=u32((tag_word !=DRAWTAG_NOP));c_1.clip_ix=(tag_word & 1u);c_1.scene_offset=((tag_word>>2u) & 7u);c_1.info_offset=((tag_word>>6u) & 15u);let _e19=c_1;return _e19;}@compute @workgroup_size(256,1,1)\nfn main(@builtin(global_invocation_id) global_id:vec3<u32>,@builtin(local_invocation_id) local_id:vec3<u32>) {var drawtag:u32;var x0_:i32;var y0_:i32;var x1_:i32;var y1_:i32;var total_tile_count:u32;var i:u32;var offset:u32;var i_1:u32;let failed=atomicLoad((&bump.failed));if ((failed & STAGE_BINNING) !=0u) {return;}let SX=(1.0 / f32(TILE_WIDTH));let SY=(1.0 / f32(TILE_HEIGHT));let drawobj_ix=global_id.x;drawtag=DRAWTAG_NOP;let _e22=config.n_drawobj;if (drawobj_ix<_e22) {let _e27=config.drawtag_base;let _e30=scene[(_e27+drawobj_ix)];drawtag=_e30;}x0_=0;y0_=0;x1_=0;y1_=0;let _e39=drawtag;let _e42=drawtag;if ((_e39 !=DRAWTAG_NOP) && (_e42 !=DRAWTAG_END_CLIP)) {let bbox=draw_bboxes[drawobj_ix];x0_=i32(floor((bbox.x*SX)));y0_=i32(floor((bbox.y*SY)));x1_=i32(ceil((bbox.z*SX)));y1_=i32(ceil((bbox.w*SY)));}let _e65=x0_;let _e69=config.width_in_tiles;let ux0_=u32(clamp(_e65,0,i32(_e69)));let _e73=y0_;let _e77=config.height_in_tiles;let uy0_=u32(clamp(_e73,0,i32(_e77)));let _e81=x1_;let _e85=config.width_in_tiles;let ux1_=u32(clamp(_e81,0,i32(_e85)));let _e89=y1_;let _e93=config.height_in_tiles;let uy1_=u32(clamp(_e89,0,i32(_e93)));let tile_count=((ux1_-ux0_)*(uy1_-uy0_));total_tile_count=tile_count;sh_tile_count[local_id.x]=tile_count;i=0u;loop {let _e106=i;if (_e106<firstTrailingBit(WG_SIZE)) {} else {break;}{workgroupBarrier();let _e112=i;if (local_id.x>=(1u<<_e112)) {let _e118=i;let _e122=sh_tile_count[(local_id.x-(1u<<_e118))];let _e123=total_tile_count;total_tile_count=(_e123+_e122);}workgroupBarrier();let _e128=total_tile_count;sh_tile_count[local_id.x]=_e128;}continuing {let _e130=i;i=(_e130+1u);}}if (local_id.x==(WG_SIZE-1u)) {let count=sh_tile_count[(WG_SIZE-1u)];let _e145=atomicAdd((&bump.tile),count);offset=_e145;let _e147=offset;let _e151=config.tiles_size;if ((_e147+count)>_e151) {offset=0u;let _e157=atomicOr((&bump.failed),STAGE_TILE_ALLOC);}let _e161=offset;paths[drawobj_ix].tiles=_e161;}storageBarrier();let tile_offset=paths[(drawobj_ix | (WG_SIZE-1u))].tiles;storageBarrier();let _e172=config.n_drawobj;if (drawobj_ix<_e172) {let _e180=sh_tile_count[(local_id.x-1u)];let tile_subix=select(0u,_e180,(local_id.x>0u));let bbox_1=vec4<u32>(ux0_,uy0_,ux1_,uy1_);let path=Path(bbox_1,(tile_offset+tile_subix));paths[drawobj_ix]=path;}let total_count=sh_tile_count[(WG_SIZE-1u)];i_1=local_id.x;loop {let _e198=i_1;if (_e198<total_count) {} else {break;}{let _e201=i_1;tiles[(tile_offset+_e201)]=Tile(0,0u);}continuing {let _e208=i_1;i_1=(_e208+WG_SIZE);}}return;}\n',
        workgroup_size: new WorkgroupSize( 256, 1, 1 ),
        bindings: [ 'Uniform', 'BufReadOnly', 'BufReadOnly', 'Buffer', 'Buffer', 'Buffer' ],
        workgroup_buffers: [
          { size_in_bytes: 1024, index: 0 }
        ]
      }, device )
    };
  }
}

scenery.register( 'VelloShader', VelloShader );
