<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Documentation - Scenery</title>

  <link rel="stylesheet" href="../../sherpa/lib/bootstrap-2.2.2.css">
  <link rel="stylesheet" href="../../sherpa/lib/bootstrap-responsive-2.2.2.css">
  <link rel="stylesheet" href="../../sherpa/lib/syntaxhighlighter-3.0.83/shCore.css">
  <link rel="stylesheet" href="../../sherpa/lib/syntaxhighlighter-3.0.83/shThemeDefault.css">
  <link rel="stylesheet" href="../assets/scenery.css">

  <!-- Before loading other things (that might error), create hooks to report errors/loads for continuous testing -->
  <script src="../../aqua/js/pageload-connector.js"></script>

  <!-- jQuery and LoDash are dependencies -->
  <script src="../../sherpa/lib/jquery-2.1.0.min.js"></script>
  <script src="../../sherpa/lib/lodash-4.17.4.min.js"></script>

  <!-- For the styling -->
  <script src="../../sherpa/lib/bootstrap-2.2.2.js"></script>

  <script src="../../sherpa/lib/syntaxhighlighter-3.0.83/shCore.js"></script>
  <script src="../../sherpa/lib/syntaxhighlighter-3.0.83/shBrushJScript.js"></script>
  <script src="../../sherpa/lib/syntaxhighlighter-3.0.83/shBrushXml.js"></script>

  <!-- MathJax config -->
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});

  </script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  <!-- Our code, in either the concatenated 'with comments' version or the minified version -->
  <script src="../build/scenery.min.js"></script>

  <script type="text/javascript">
    scenery.Util.polyfillRequestAnimationFrame();

    function docExample( id, draw ) {
      var $container = $( '#' + id );
      var scene = new scenery.Node();
      var display = new scenery.Display( scene, {
        width: $container.width(),
        height: $container.height()
      } );
      $container[ 0 ].appendChild( display.domElement );
      draw( scene, display );
      display.updateDisplay();
      var $code = $( '<pre class="brush: js"></pre>' );
      $code.text( draw.toString().match( /\/\*START\*\/((.|\n)*)\/\*END\*\// )[ 1 ] );
      $container.after( $code );
    }
  </script>

  <style type="text/css">

    .exampleScene {
      margin: 15px auto;
      border: 1px solid black;
      position: relative;
      left: 0;
      top: 0;
    }

    #sidebar {
      background-color: #eee;
      position: fixed;
      z-index: 10;
      top: 41px;
      left: 0;
      bottom: 0;
      width: 200px;
      overflow-y: auto;
      overflow-x: hidden;
      -webkit-overflow-scrolling: touch;
      padding: 15px 0 30px 30px;
      border-right: 1px solid #bbb;
      box-shadow: 0 0 20px #ccc;
      -webkit-box-shadow: 0 0 20px #ccc;
      -moz-box-shadow: 0 0 20px #ccc;
    }

    #apiList {
      background-color: #eee;
      position: relative;
      border: 1px solid #bbb;
      border-left: none;
      padding: 10px;
    }

    .ph2 {
      font-weight: bold;
      font-size: 18px;
    }

    .navlink {
      font-weight: bold;
    }

    .sublink {
      padding-left: 1em;
    }

    .args {
      font-weight: normal;
      font-size: 80%;
    }
  </style>

</head>

<body>
<div class="navbar navbar-inverse navbar-static-top">
  <div class="navbar-inner">
    <a class="brand" href="../">Scenery</a>
    <ul class="nav">
      <li><a href="../">Home</a></li>
      <li class="active"><a href="../doc">Documentation</a></li>
      <li><a href="../examples">Examples</a></li>
      <li><a href="../tests">Tests</a></li>
    </ul>
    <ul class="nav pull-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Related <b class="caret"></b></a>
        <ul class="dropdown-menu">
          <li><a href="../../scenery">Scenery</a></li>
          <li><a href="../../kite">Kite</a></li>
          <li><a href="../../dot">Dot</a></li>
        </ul>
      </li>
    </ul>
  </div>
</div>

<div class="row-fluid">
  <div class="span3"></div>
  <div class="span6">
    <div class="page-header" style="text-align: center;">
      <h1>Scenery Documentation</h1>
    </div>

    <!-- TODO: coordinate frame notes<br> -->
    <!-- TODO: event handling API documentation<br> -->
    <!-- TODO: use <a href="http://softwaremaniacs.org/soft/highlight/en/">highlight.js</a> for highlighting -->

  </div>
  <div class="span3"></div>
</div>

<div class="row-fluid">
  <div class="span3" id="apiList">
    <div class="ph2"><a href="#api">Scenery API</a></div>

    <a class="navlink" href="#node">Node</a><br>
    <a class="sublink" href="#node-options">(options)</a><br>
    <a class="sublink" href="#node-events">(events)</a><br>
    <a class="sublink" href="#node-children">children</a><br>
    <a class="sublink" href="#node-parents">parents</a><br>
    <a class="sublink" href="#node-addChild">addChild</a><br>
    <a class="sublink" href="#node-insertChild">insertChild</a><br>
    <a class="sublink" href="#node-removeChild">removeChild</a><br>
    <a class="sublink" href="#node-removeChildAt">removeChildAt</a><br>
    <a class="sublink" href="#node-removeAllChildren">removeAllChildren</a><br>
    <a class="sublink" href="#node-detach">detach</a><br>
    <a class="sublink" href="#node-cursor">cursor</a><br>
    <a class="sublink" href="#node-mouseArea">mouseArea</a><br>
    <a class="sublink" href="#node-touchArea">touchArea</a><br>
    <a class="sublink" href="#node-clipArea">clipArea</a><br>
    <a class="sublink" href="#node-visible">visible</a><br>
    <a class="sublink" href="#node-pickable">pickable</a><br>
    <a class="sublink" href="#node-opacity">opacity</a><br>
    <a class="sublink" href="#node-matrix">matrix</a><br>
    <a class="sublink" href="#node-translation">translation</a><br>
    <a class="sublink" href="#node-translate">translate</a><br>
    <a class="sublink" href="#node-x">x</a><br>
    <a class="sublink" href="#node-y">y</a><br>
    <a class="sublink" href="#node-rotation">rotation</a><br>
    <a class="sublink" href="#node-rotate">rotate</a><br>
    <a class="sublink" href="#node-rotateAround">rotateAround</a><br>
    <a class="sublink" href="#node-scale">scale</a><br>
    <a class="sublink" href="#node-bounds">bounds</a><br>
    <a class="sublink" href="#node-selfBounds">selfBounds</a><br>
    <a class="sublink" href="#node-childBounds">childBounds</a><br>
    <a class="sublink" href="#node-visibleBounds">visibleBounds</a><br>
    <a class="sublink" href="#node-left">left</a><br>
    <a class="sublink" href="#node-right">right</a><br>
    <a class="sublink" href="#node-top">top</a><br>
    <a class="sublink" href="#node-bottom">bottom</a><br>
    <a class="sublink" href="#node-center">center</a><br>
    <a class="sublink" href="#node-centerX">centerX</a><br>
    <a class="sublink" href="#node-centerY">centerY</a><br>
    <a class="sublink" href="#node-renderer">renderer</a><br>
    <a class="sublink" href="#node-layerSplit">layerSplit</a><br>

    <a class="navlink" href="#display">Display</a><br>
    <a class="sublink" href="#display-options">(options)</a><br>
    <a class="sublink" href="#display-domElement">domElement</a><br>
    <a class="sublink" href="#display-updateDisplay">updateDisplay</a><br>
    <a class="sublink" href="#display-rootNode">rootNode</a><br>
    <a class="sublink" href="#display-size">size</a><br>
    <a class="sublink" href="#display-width">width</a><br>
    <a class="sublink" href="#display-height">height</a><br>
    <a class="sublink" href="#display-backgroundColor">backgroundColor</a><br>

    <a class="navlink" href="#paintable">Paintable</a><br>
    <a class="sublink" href="#paintable-fill">fill</a><br>
    <a class="sublink" href="#paintable-fillPickable">fillPickable</a><br>
    <a class="sublink" href="#paintable-stroke">stroke</a><br>
    <a class="sublink" href="#paintable-strokePickable">strokePickable</a><br>
    <a class="sublink" href="#paintable-lineWidth">lineWidth</a><br>
    <a class="sublink" href="#paintable-lineCap">lineCap</a><br>
    <a class="sublink" href="#paintable-lineJoin">lineJoin</a><br>
    <a class="sublink" href="#paintable-lineDash">lineDash</a><br>
    <a class="sublink" href="#paintable-lineDashOffset">lineDashOffset</a><br>
    <a class="sublink" href="#paintable-strokePickable">strokePickable</a><br>
    <a class="sublink" href="#paintable-cachedPaints">cachedPaints</a><br>

    <a class="navlink" href="#path">Path</a><br>
    <a class="sublink" href="#path-shape">shape</a><br>

    <a class="navlink" href="#image">Image</a><br>
    <a class="sublink" href="#image-image">image</a><br>

    <a class="navlink" href="#text">Text</a><br>
    <a class="sublink" href="#text-options">(options)</a><br>
    <a class="sublink" href="#text-text">text</a><br>
    <a class="sublink" href="#text-font">font</a><br>
    <a class="sublink" href="#text-fontWeight">fontWeight</a><br>
    <a class="sublink" href="#text-fontFamily">fontFamily</a><br>
    <a class="sublink" href="#text-fontStretch">fontStretch</a><br>
    <a class="sublink" href="#text-fontStyle">fontStyle</a><br>
    <a class="sublink" href="#text-fontSize">fontSize</a><br>
    <a class="sublink" href="#text-lineHeight">lineHeight</a><br>
    <a class="sublink" href="#text-direction">direction</a><br>
    <a class="sublink" href="#text-boundsMethod">boundsMethod</a><br>

    <a class="navlink" href="#htmlText">HTMLText</a><br>

    <a class="navlink" href="#dom">DOM</a><br>
    <a class="sublink" href="#dom-element">element</a><br>
    <a class="sublink" href="#dom-interactive">interactive</a><br>

    <a class="navlink" href="#linearGradient">LinearGradient</a><br>
    <a class="sublink" href="#linearGradient-addColorStop">addColorStop</a><br>
    <a class="sublink" href="#linearGradient-setTransformMatrix">setTransformMatrix</a><br>

    <a class="navlink" href="#radialGradient">RadialGradient</a><br>
    <a class="sublink" href="#radialGradient-addColorStop">addColorStop</a><br>
    <a class="sublink" href="#radialGradient-setTransformMatrix">setTransformMatrix</a><br>

    <a class="navlink" href="#pattern">Pattern</a><br>
    <a class="sublink" href="#pattern-setTransformMatrix">setTransformMatrix</a><br>

    <a class="navlink" href="#vbox">VBox</a><br>

    <a class="navlink" href="#rectangle">Rectangle</a><br>
    <a class="sublink" href="#rectangle-rectX">rectX</a><br>
    <a class="sublink" href="#rectangle-rectY">rectY</a><br>
    <a class="sublink" href="#rectangle-rectWidth">rectWidth</a><br>
    <a class="sublink" href="#rectangle-rectHeight">rectHeight</a><br>
    <a class="sublink" href="#rectangle-cornerRadius">cornerRadius</a><br>
    <a class="sublink" href="#rectangle-cornerXRadius">cornerXRadius</a><br>
    <a class="sublink" href="#rectangle-cornerYRadius">cornerYRadius</a><br>

    <a class="navlink" href="#circle">Circle</a><br>
    <a class="sublink" href="#circle-radius">radius</a><br>

    <a class="navlink" href="#line">Line</a><br>
    <a class="sublink" href="#line-x1">x1</a><br>
    <a class="sublink" href="#line-y1">x1</a><br>
    <a class="sublink" href="#line-x2">x2</a><br>
    <a class="sublink" href="#line-y2">y2</a><br>
    <a class="sublink" href="#line-p1">p1</a><br>
    <a class="sublink" href="#line-p2">p2</a><br>

    <a class="navlink" href="#font">Font</a><br>
    <a class="sublink" href="#font-font">font</a><br>
    <a class="sublink" href="#font-family">family</a><br>
    <a class="sublink" href="#font-weight">weight</a><br>
    <a class="sublink" href="#font-stretch">stretch</a><br>
    <a class="sublink" href="#font-style">style</a><br>
    <a class="sublink" href="#font-size">size</a><br>
    <a class="sublink" href="#font-lineHeight">lineHeight</a><br>

    <a class="navlink" href="#color">Color</a><br>
    <a class="sublink" href="#color-red">red</a><br>
    <a class="sublink" href="#color-green">green</a><br>
    <a class="sublink" href="#color-blue">blue</a><br>
    <a class="sublink" href="#color-alpha">alpha</a><br>
    <a class="sublink" href="#color-toCSS">toCSS</a><br>

    <a class="navlink" href="#event">Event</a><br>

    <a class="navlink" href="#pointer">Pointer</a><br>

    <a class="navlink" href="#mouse">Mouse</a><br>

    <a class="navlink" href="#touch">Touch</a><br>

    <a class="navlink" href="#pen">Pen</a><br>

    <a class="navlink" href="#trail">Trail</a><br>

  </div>
  <div class="span6">
    <h2 id="tutorials">Tutorials</h2>

    <p>If you are just starting out, see the <a href="a-tour-of-scenery.html">Tour of Scenery</a></p>

    <h2 id="get-the-code">Get the code</h2>

    <p>
      Scenery depends on a few other libraries, and needs to have them checked out as siblings. It is recommended to
      place all of these inside a containing directory. Make sure you have <a href="https://help.github.com/articles/set-up-git">git</a> installed,
      then run:
    </p>

      <pre>
git clone https://github.com/phetsims/sherpa.git
git clone https://github.com/phetsims/chipper.git
git clone https://github.com/phetsims/assert.git
git clone https://github.com/phetsims/axon.git
git clone https://github.com/phetsims/tandem.git
git clone https://github.com/phetsims/phet-core.git
git clone https://github.com/phetsims/dot.git
git clone https://github.com/phetsims/kite.git
git clone https://github.com/phetsims/scenery.git</pre>

    <h2 id="building">Building</h2>

    <p>
      For some examples and tests, and to build a custom version, you'll need to install <a href="http://nodejs.org/">node.js</a>, and <a
        href="https://github.com/gruntjs/grunt-cli">grunt-cli</a>. Then,
    </p>

      <pre>
cd chipper
npm install
cd ../scenery
npm install
grunt</pre>

    <p>
      You will now have the built files under build/, and all of the documentation/examples should work locally.
    </p>

    <h2 id="dependencies">Dependencies</h2>

    <strong>External</strong> dependencies (please provide these in your page before loading Scenery):
    <ul>
      <li><a href="http://jquery.com/">jQuery</a> for parts of DOM manipulation.</li>
      <li><a href="http://lodash.com/">Lo-Dash</a> for utility functions, as a replacement for <a href="http://underscorejs.org/">Underscore.js</a>.
      </li>
      <li>[optional] <a href="https://code.google.com/p/canvg/">Canvg</a>, for supporting SVG &#8594; Canvas operations, like rendering to Canvas</li>
    </ul>

    <strong>Internal</strong> dependencies:
    <ul>
      <li><a href="https://github.com/phetsims/assert">assert</a> for assertion handling.
      </li>
      <li><a href="https://github.com/phetsims/phet-core">phet-core</a> for other utility functions.</li>
      <li><a href="../../dot">Dot</a> for math.</li>
      <li><a href="../../kite">Kite</a> for shapes.</li>
    </ul>

    <h2 id="debugging">Debugging</h2>

      <pre class="brush: js">
window.assertions.enableAssert();
window.assertions.enableAssertSlow();
      </pre>
    <p>
      or to disable assertions:
    </p>
      <pre class="brush: js">
window.assertions.disableAssert();
window.assertions.disableAssertSlow();
      </pre>

    <h2 id="in-depth-information">In-Depth Information</h2>

    <p>
      See the <a href="user-input">User Input documentation</a> for handling user-generated events.
    </p>

    <p>
      Take a look at <a href="accessibility.html">Accessibility in Scenery</a>
    </p>

    <p>
      For information on Scenery's internal code, see the <a href="implementation-notes">Implementation Notes</a>.
    </p>

    <h2 id="api">Scenery API</h2>

    <h3 id="node" class="section">Node</h3>

    <p>
      A default node can be created with <code>new scenery.Node()</code>, but usually a parameter object is
      given, for example <code>new scenery.Node( { x: 20, y: 100 } )</code>. Below are all of the available
      parameter object options:
    </p>

    <h4 id="node-options">Node Options</h4>
    A Node (and Node subtypes) have the following parameter object options available, executed in in the order listed.

    <ul>
      <li><a href="#node-children">children</a>: A list of children to add (in order)</li>
      <li><a href="#node-cursor">cursor</a>: Will display the specified CSS cursor when the mouse is over this Node or one of its descendents. The
        Scene needs to have input listeners attached with an initialize method first.
      </li>
      <li><a href="#node-visible">visible</a>: If false, this node (and its children) will not be displayed (or get input events)</li>
      <li><a href="#node-pickable">pickable</a>: If false, this node (and its children) will not get input events</li>
      <li><a href="#node-opacity">opacity</a>: From 0 (transparent) to 1 (opaque)</li>
      <li><a href="#node-matrix">matrix</a>: Sets the transform matrix of the node to the specified <a href="../../dot/doc#matrix3">dot.Matrix3</a>
        value
      </li>
      <li><a href="#node-translation">translation</a>: Sets the translation of the node to either the specified <a href="../../dot/doc#vector2">dot.Vector2</a>
        value, or the x,y values from an object (e.g. translation: { x: 1, y: 2 } )
      </li>
      <li><a href="#node-x">x</a>: Sets the x-translation of the node</li>
      <li><a href="#node-y">y</a>: Sets the y-translation of the node</li>
      <li><a href="#node-rotation">rotation</a>: Sets the rotation of the node in radians</li>
      <li><a href="#node-scale">scale</a>: Sets the scale of the node. Supports either a number (same x-y scale), or a <a
          href="../../dot/doc#vector2">dot.Vector2</a> / object with ob.x and ob.y to set the scale for each axis independently
      </li>
      <li><a href="#node-left">left</a>: Sets the x-translation so that the left (min X) of the bounding box (in the parent coordinate frame) is at
        the specified value
      </li>
      <li><a href="#node-right">right</a>: Sets the x-translation so that the right (max X) of the bounding box (in the parent coordinate frame) is at
        the specified value
      </li>
      <li><a href="#node-top">top</a>: Sets the y-translation so that the top (min Y) of the bounding box (in the parent coordinate frame) is at the
        specified value
      </li>
      <li><a href="#node-bottom">bottom</a>: Sets the y-translation so that the bottom (min Y) of the bounding box (in the parent coordinate frame) is
        at the specified value
      </li>
      <li><a href="#node-center">center</a>: Sets the translation so that the center of the bounding box (in the parent coordinate frame) is at the
        specified <a href="../../dot/doc#vector2">dot.Vector2</a> value
      </li>
      <li><a href="#node-centerX">centerX</a>: Sets the x-translation so that the horizontal center of the bounding box (in the parent coordinate
        frame) is at the specified value
      </li>
      <li><a href="#node-centerY">centerY</a>: Sets the y-translation so that the vertical center of the bounding box (in the parent coordinate frame)
        is at the specified value
      </li>
      <li><a href="#node-renderer">renderer</a>: Forces Scenery to use the specific renderer (canvas/svg) to display this node (and if possible,
        children). Accepts both strings (e.g. 'canvas', 'svg', etc.) or actual Renderer objects (e.g. Renderer.Canvas, Renderer.SVG, etc.)
      </li>
      <li><a href="#node-layerSplit">layerSplit</a>: Forces a split between layers before and after this node (and its children) have been rendered.
        Useful for performance with Canvas-based renderers.
      </li>
      <li><a href="#node-mouseArea">mouseArea</a>: Shape (in local coordinate frame) that overrides the 'hit area' for mouse input.</li>
      <li><a href="#node-touchArea">touchArea</a>: Shape (in local coordinate frame) that overrides the 'hit area' for touch input.</li>
      <li><a href="#node-clipArea">clipArea</a>: Shape (in local coordinate frame) that causes any graphics outside of the shape to be invisible (for
        the node and any children).
      </li>
    </ul>

    <h4 id="node-events">Node Events</h4>
    A Node (and Node subtypes) extend <a href="https://github.com/phetsims/axon">Axon</a>'s Events type, which exposes
    the following types of events (fired when they either occur or change):

    <ul>
      <li>childInserted: <code>function( childNode, index )</code> Called when a child is <a href="node-addChild">added</a>
        or <a href="node-insertChild">inserted</a>, and includes the new index into the <a href="node-children">children</a>.</li>
      <li>childRemoved: <code>function( childNode, index )</code> Called when a child is <a href="node-removeChild">removed</a>
        and includes the old index into the <a href="node-children">children</a>.</li>
      <li>bounds: <code>function()</code> Called when the bounds in the parent coordinate frame changes.
        See <a href="node-bounds">bounds</a>.</li>
      <li>localBounds: <code>function()</code> Called when the bounds in the local coordinate frame changes.
        See <a href="node-localBounds">localBounds</a>.</li>
      <li>childBounds: <code>function()</code> Called when the bounds of all children in the local coordinate
        frame changes. See <a href="node-childBounds">childBounds</a>.</li>
      <li>selfBounds: <code>function()</code> Called when the self bounds change.
        See <a href="node-selfBounds">selfBounds</a>.</li>
      <li>transform: <code>function()</code> Called when the transform changes.</li>
      <li>visibility: <code>function()</code> Called when the <a href="node-visible">visibility</a> changes.</li>
      <li>opacity: <code>function()</code> Called when the <a href="node-opacity">opacity</a> changes.</li>
      <li>clip: <code>function()</code> Called when the <a href="node-clipArea">clipArea</a> changes.</li>
      <!-- <li>rendererBitmask: <code>function()</code></li> -->
      <!-- <li>rendererSummary: <code>function()</code></li> -->
      <!-- <li>hint: <code>function( [hintName] )</code></li> -->
      <!-- <li>localBoundsOverride: <code>function( isOverridden )</code></li> -->
    </ul>

    <h4 id="node-children">node.children</h4>

    <p>
      <code>node.children</code> is a getter/setter linked to <code>node.getChildren()</code> and <code>node.setChildren( children )</code>.
      This will return a copy of node's array of children, in rendering
      order (later children render above previous children). Making changes to the returned array will not change node's children.
    </p>

    <p>
      This can also be used when creating a Node:
    </p>

    <div id="example-children" class="exampleScene" style="width: 128px; height: 64px; margin: 0 auto;"></div>
    <script type="text/javascript">
      docExample( 'example-children', function( scene ) {
        /*START*/
        scene.addChild( new scenery.Node( {
          // an array of children can be specified, so no
          // reference to the container node is needed
          children: [
            // gray rectangle on the left
            new scenery.Path( kite.Shape.rectangle( 0, 0, 64, 64 ), {
              fill: '#aaa'
            } ),

            // later nodes in the array will show up on top
            // of previous nodes
            new scenery.Text( 'Children', {
              font: '20px sans-serif',
              centerX: 64,
              centerY: 32
            } )
          ]
        } ) );
        /*END*/
      } );
    </script>

    <h4 id="node-parents">node.parents</h4>

    <p>
      <code>node.parents</code> or <code>node.getParents()</code> will return an array of parent nodes, but <strong>order is not significant</strong>.
    </p>

    <h4 id="node-addChild">node.addChild( <span class="args">childNode</span> )</h4>

    <p>
      Appends childNode to node's list of children. childNode will be displayed above node and node's other children.
    </p>

    <h4 id="node-insertChild">node.insertChild( <span class="args">index, childNode</span> )</h4>

    <p>
      Inserts childNode into node's children at the specified index. <code>node.insertChild( 0, childNode )</code> will make childNode the first
      child, and
      <code>node.insertChild( node.children.length, childNode )</code> is the same as <code>node.addChild( childNode )</code>.
    </p>

    <h4 id="node-removeChild">node.removeChild( <span class="args">childNode</span> )</h4>

    <p>
      Removes childNode from node's children.
    </p>

    <h4 id="node-removeChildAt">node.removeChildAt( <span class="args">index</span> )</h4>

    <p>
      Removes the child node <code>node.children[ index ]</code> from node's children.
    </p>

    <h4 id="node-removeAllChildren">node.removeAllChildren()</h4>

    <p>
      Removes all of the Node's children.
    </p>

    <h4 id="node-detach">node.detach()</h4>

    <p>
      Removes this node from all of its parents.
    </p>

    <h4 id="node-cursor">node.cursor</h4>

    <p>
      <code>node.cursor</code> is a getter/setter linked to <code>node.getCursor()</code> and <code>node.setCursor( cursor )</code>.
      By default it is null (default cursor), but this can be set to
      the string for any <a href="https://developer.mozilla.org/en-US/docs/CSS/cursor">CSS cursor value</a>, and some extra Scenery-specified ones
      below. There is
      <a href="../examples/cursors.html">a cursor example page</a> that demos a number of available cursors.
    </p>

    <p>
      The cursor is updated whenever <a href="#display-updateDisplay">display.updateDisplay</a> is called, and event initialization like <a
        href="#display-initializeEvents">display.initializeEvents</a> should be added so Scenery can track the mouse input.
    </p>

    <p>
      There are some Scenery-specific cursor values that can be set:
    </p>
    <ul>
      <li>
        scenery-grab-pointer: attempts to use browser-prefixed 'grab' values (newer), but falls back to the 'pointer' if not available
      </li>
      <li>
        scenery-grabbing-pointer: attempts to use browser-prefixed 'grabbing' values (newer), but falls back to the 'pointer' if not available
      </li>
    </ul>
    <div id="example-cursor" class="exampleScene" style="width: 128px; height: 64px; margin: 0 auto;"></div>
    <script type="text/javascript">
      docExample( 'example-cursor', function( scene, display ) {
        /*START*/
        scene.addChild( new scenery.Path( kite.Shape.regularPolygon( 6, 25 ), {
          x: 64, y: 32,
          fill: '#88f',
          cursor: 'pointer', // classic hand
          pickable: true // since it wouldn't be hit-tested otherwise
        } ) );
        /*END*/
// event initialization needed for cursor to work
        display.initializeEvents();

// and update on every frame
        display.updateOnRequestAnimationFrame();
      } );
    </script>

    <h4 id="node-mouseArea">node.mouseArea</h4>

    <p>
      Sets an alternative hit region when receiving mouse events. Useful for when there
      are gaps between children which should still respond to the event.
    </p>

    <p>
      Accepts both arbitrary shapes (<a href="../../kite/doc#shape">Shape</a>) and bounding boxes (<a href="../../dot/doc#bounds2">Bounds2</a>).
    </p>

    <p>
      The mouse area supersedes the hit regions for mouse events of the node itself and its descendants.
      Setting mouseArea on a Node will cause it to either return no hit (for it or its children when outside of the mouseArea) or this Node as an
      event target.
    </p>

    <h4 id="node-touchArea">node.touchArea</h4>

    <p>
      Sets an alternative hit region when receiving touch events. Useful for expanding
      where the user can touch controls.
    </p>

    <p>
      Accepts both arbitrary shapes (<a href="../../kite/doc#shape">Shape</a>) and bounding boxes (<a href="../../dot/doc#bounds2">Bounds2</a>).
    </p>

    <p>
      The touch area supersedes the hit regions for touch events of the node itself and its descendants.
      Setting touchArea on a Node will cause it to either return no hit (for it or its children when outside of the touchArea) or this Node as an
      event target.
    </p>

    <h4 id="node-clipArea">node.clipArea</h4>

    <p>
      <code>node.clipArea</code> is a getter/setter linked to <code>node.getClipArea()</code> and <code>node.setClipArea( shape )</code>.
      Default is <code>null</code> (no clipping), but when the clipArea is set to a <a href="../../kite/doc#shape">Shape</a>, anything outside
      of the clip area Shape (in the node's local coordinate frame) is not displayed. This clipping affects both the node's own display, and the
      display of any
      of its children.
    </p>

    <p>
      clipArea currently does not affect DOM layers, and the general case can't be added in (CSS clip only allows rectangles currently).
    </p>

    <p>
      clipArea is not currently compatible with CSS-transformed SVG rendering if the clipArea is on an ancestor of the CSS-transformed Node.
    </p>

    <p>
      clipArea affects the bounds of the Node, and pointers are not considered "over" a node if they are outside of its clipArea.
    </p>

    <div id="example-clipArea" class="exampleScene" style="width: 64px; height: 64px; margin: 0 auto;"></div>
    <script type="text/javascript">
      docExample( 'example-clipArea', function( scene ) {
        scene.renderer = 'svg';
        /*START*/
        scene.addChild( new scenery.Circle( 28, {
          fill: 'black',
          stroke: 'red',
          lineWidth: 5,
          x: 38, y: 38,
          clipArea: kite.Shape.roundRect( -32, -32, 50, 50, 10, 10 )
        } ) );
        /*END*/
      } );
    </script>

    <h4 id="node-visible">node.visible</h4>

    <p>
      <code>node.visible</code> is a getter/setter linked to <code>node.isVisible()</code> and <code>node.setVisible( boolean )</code>.
      Nodes are by default visible, but when invisible they will not
      be displayed and will not be pickable (no input events will be targeted to them).
    </p>

    <h4 id="node-pickable">node.pickable</h4>

    <p>
      <code>node.pickable</code> is a getter/setter linked to <code>node.isPickable()</code> and <code>node.setPickable( boolean | null )</code>.
      Pickable can take three values:
    </p>
    <ul>
      <li>
        null: (default) pass-through behavior. Hit-testing will prune this subtree if there are no ancestors/descendants with either pickable: true
        set
        or with any input listeners
      </li>
      <li>
        false: Hit-testing is pruned, nothing under a pickable: false will respond to events or be picked
      </li>
      <li>
        true: Hit-testing will not be pruned in this subtree, except for pickable: false cases.
      </li>
    </ul>
    <p>
      Hit testing is accomplished mainly with <a href="#node-trailUnderPointer">node.trailUnderPointer</a> and <a href="#node-trailUnderPoint">node.trailUnderPoint</a>,
      following the above rules. Nodes that are not pickable (pruned) will not have input events targeted to them.
    </p>

    <p>
      Thus in order for a Node (really, a Trail) to be able to receive input events:
    </p>
    <ol>
      <li>If the node or one of its ancestors has pickable: false OR is invisible, the node <strong>will not</strong> receive events or hit testing
      </li>
      <li>If the node or one of its ancestors or descendants is pickable: true OR has an input listener attached, it <strong>will</strong> receive
        events or hit testing
      </li>
      <li>Otherwise, it <strong>will not</strong> receive events or hit testing</li>
    </ol>
    <p>
      This is useful for semi-transparent overlays or other visual elements that should be displayed but should not prevent objects below from being
      manipulated by user input, and the default 'null' value is used to increase performance by ignoring areas that don't need user input.
    </p>

    <h4 id="node-opacity">node.opacity</h4>

    <p>
      <code>node.opacity</code> is a getter/setter linked to <code>node.getOpacity()</code> and <code>node.setOpacity( opacity )</code>.
      Opacity should be in the inclusive range of 0 to 1, where 0 is fully transparent, and 1 is fully opaque. <code>opacity</code> controls not only
      the opacity (alpha) of the node itself, but also all of its children.
    </p>

    <div id="example-opacity" class="exampleScene" style="width: 64px; height: 64px; margin: 0 auto;"></div>
    <script type="text/javascript">
      docExample( 'example-opacity', function( scene ) {
        /*START*/
        scene.addChild( new scenery.Rectangle( 0, 12, 64, 20, { fill: '#000' } ) );
        var circle = kite.Shape.circle( 0, 0, 30 );
        scene.addChild( new scenery.Node( {
          opacity: 0.5,
          children: [
            new scenery.Path( circle, { x: 12, y: 22, fill: '#f00' } ),
            new scenery.Path( circle, { x: 52, y: 22, fill: '#00f' } )
          ]
        } ) );
        /*END*/
      } );
    </script>

    <h4 id="node-matrix">node.matrix</h4>

    <p>
      <code>node.matrix</code> (<code>node.getMatrix()</code>, <code>node.setMatrix( matrix )</code>) gets or sets the transformation matrix
      associated with the
      node, of type <a href="../../dot/doc#matrix3">dot.Matrix3</a>.
    </p>

    <h4 id="node-translation">node.translation</h4>

    <p>
      Getting the translation: <code>node.translation</code> or <code>node.getTranslation()</code>. It always returns a <a
        href="../../dot/doc#vector2">dot.Vector2</a> instance representing
      the translation part of the node's transform. See <a href="../../dot/doc#matrix3-getTranslation">dot.Matrix3.getTranslation</a> for more
      information.
    </p>

    <p>
      Setting the translation: <code>node.translation = translation</code>, <code>node.setTranslation( translation )</code> or <code>node.setTranslation(
      x, y )</code>.
      In both instances, <code>translation</code> can be either a <a href="../../dot/doc#vector2">dot.Vector2</a> or an object literal like <code>{ x:
      5, y: 10 }</code>.
    </p>

    <h4 id="node-translate">node.translate( <span class="args">x, y</span> )</h4>

    <p>
      Translates the node relatively by <code>x</code> and <code>y</code>. In addition to <code>node.translate( x, y )</code>, <code>node.translate(
      translation )</code>
      can be used, where <code>transform</code> is either a <a href="../../dot/doc#vector2">dot.Vector2</a> or an object like <code>{ x: 5, y: 10
      }</code>
    </p>

    <h4 id="node-x">node.x</h4>

    <p>
      <code>node.x</code> gets or sets the node's x-translation with <code>node.getX()</code> and <code>node.setX( x )</code>. Accessing
      <code>node.x</code> is equivalent
      to <code>node.translation.x</code>, and setting <code>node.x</code> is equivalent to <code>node.setTranslation( x, node.y )</code>.
    </p>

    <h4 id="node-y">node.y</h4>

    <p>
      <code>node.y</code> gets or sets the node's y-translation with <code>node.getY()</code> and <code>node.setY( y )</code>. Accessing
      <code>node.y</code> is equivalent
      to <code>node.translation.y</code>, and setting <code>node.y</code> is equivalent to <code>node.setTranslation( node.x, y )</code>.
    </p>

    <h4 id="node-rotation">node.rotation</h4>

    <p>
      <code>node.rotation</code> gets or sets the node's rotation with <code>node.getRotation()</code> and <code>node.setRotation( radians )</code>.
      All rotations are
      handled in radians ($\pi$ is a 180-degree rotation). If you wish to rotate a node by a specific rotation
      (instead of setting its rotation), use <a href="#node-rotate">node.rotate</a>
    </p>

    <h4 id="node-rotate">node.rotate( <span class="args">radians, [prepend]</span> )</h4>

    <p>
      Rotates the node's transform. By default the rotation is appended to the node's transform, but the optional <code>prepend</code> boolean flag
      can be added for the rotation
      to be prepended to the node's transform.
    </p>

    <h4 id="node-rotateAround">node.rotateAround( <span class="args">point, angle</span> )</h4>

    <p>
      Rotates the node by <code>angle</code> in radians around the <a href="../../dot/doc#vector2">dot.Vector2</a> <code>point</code>.
      <code>point</code> should be in the node's parent coordinate frame.
    </p>

    <h4 id="node-scale">node.scale( <span class="args">x, y, [prepend]</span> )</h4>

    <p>
      Scales the node in each axis. By default the scale is appended to the node's transform, but the optional <code>prepend</code> boolean flag can
      be added for the
      scale to be prepended to the node's transform.
    </p>

    <p>
      <code>node.scale( s )</code> will scale by <code>s</code> in both dimensions, and is equivalent to <code>node.scale( s, s )</code>
    </p>

    <h4 id="node-bounds">node.bounds</h4>

    <p>
      Returns the <a href="../../dot/doc#bounds2">bounding box</a> of this node (and its children) in the parent coordinate frame. Also available with
      <code>node.getBounds()</code>. It includes all children, regardless
      of whether they are visible or not.
      <!-- TODO: add an example -->
    </p>

    <h4 id="node-selfBounds">node.selfBounds</h4>

    <p>
      Returns the <a href="../../dot/doc#bounds2">bounding box</a> of this node (without its children) in the local coordinate frame. Also available
      with <code>node.getSelfBounds()</code>.
      <!-- TODO: add an example -->
    </p>

    <h4 id="node-childBounds">node.childBounds</h4>

    <p>
      Returns the <a href="../../dot/doc#bounds2">bounding box</a> of this node's children (without include the node's selfBounds) in the local
      coordinate frame. Also available with <code>node.getChildBounds()</code>.
      <!-- TODO: add an example -->
    </p>

    <h4 id="node-visibleBounds">node.visibleBounds</h4>

    <p>
      Returns the <a href="../../dot/doc#bounds2">bounding box</a> of this node (and its children) in the parent coordinate frame. Also available with
      <code>node.getVisibleBounds()</code>. Unlike <a href="#node-bounds">bounds</a>, this includes only descendants which are visible. It is not
      tracked, so each call will
      need to traverse the subtree to get the bounds.
      <!-- TODO: add an example -->
    </p>

    <h4 id="node-left">node.left</h4>

    <p>
      <code>node.left</code> gets or sets the left bound (minimum x value) of this node's <a href="#node-bounds">bounds</a> in the parent coordinate
      frame, with
      <code>node.getLeft()</code> and <code>node.setLeft( x )</code>. Setting this left bound effectively translates the node horizontally.
    </p>

    <h4 id="node-right">node.right</h4>

    <p>
      <code>node.right</code> gets or sets the right bound (maximum x value) of this node's <a href="#node-bounds">bounds</a> in the parent coordinate
      frame, with
      <code>node.getRight()</code> and <code>node.setRight( x )</code>. Setting this right bound effectively translates the node horizontally.
    </p>

    <h4 id="node-top">node.top</h4>

    <p>
      <code>node.top</code> gets or sets the top bound (minimum y value) of this node's <a href="#node-bounds">bounds</a> in the parent coordinate
      frame, with
      <code>node.getTop()</code> and <code>node.setTop( y )</code>. Setting this top bound effectively translates the node vertically.
    </p>

    <h4 id="node-bottom">node.bottom</h4>

    <p>
      <code>node.bottom</code> gets or sets the bottom bound (maximum y value) of this node's <a href="#node-bounds">bounds</a> in the parent
      coordinate frame, with
      <code>node.getBottom()</code> and <code>node.setBottom( y )</code>. Setting this bottom bound effectively translates the node vertically.
    </p>

    <h4 id="node-center">node.center</h4>

    <p>
      <code>node.center</code> gets or sets the center of this node's <a href="#node-bounds">bounds</a> in the parent coordinate frame, with
      <code>node.getCenter()</code> and <code>node.setCenter( center )</code>, which both handle the center as a
      <a href="../../dot/doc#vector2">dot.Vector2</a> instance. Setting center effectively translates the node.
    </p>

    <h4 id="node-centerX">node.centerX</h4>

    <p>
      <code>node.centerX</code> gets or sets the horizontal center of this node's <a href="#node-bounds">bounds</a> in the parent coordinate frame,
      with
      <code>node.getCenterX()</code> and <code>node.setCenterX( x )</code>. Setting centerX effectively translates the node horizontally.
    </p>

    <h4 id="node-centerY">node.centerY</h4>

    <p>
      <code>node.centerY</code> gets or sets the vertical center of this node's <a href="#node-bounds">bounds</a> in the parent coordinate frame, with
      <code>node.getCenterY()</code> and <code>node.setCenterY( y )</code>. Setting centerY effectively translates the node vertically.
    </p>

    <h4 id="node-renderer">node.renderer</h4>

    <p>
      <code>node.renderer</code> gets or sets the preferred rendering backend for the node (and children) using <code>node.getRenderer()</code> or
      <code>node.setRenderer( renderer )</code>.
    </p>

    <p>
      It will always return a <a href="#renderer">Renderer</a> object back, but setting the renderer can be done either with an <a href="#renderer">Renderer</a>
      reference or
      a string (either <code>'canvas'</code>, <code>'svg'</code>, <code>'dom'</code> or <code>'webgl'</code>). Manually specifying a renderer may
      preclude future
      performance/quality tradeoffs from being automatically made.
    </p>

    <p>
      Setting a renderer will have this node and its children use that renderer if they support it. This may be impossible (for instance, <a
        href="#path">Paths</a> do not support the <code>'dom'</code> renderer, and <a href="#dom">DOM nodes</a> do not support the
      <code>'canvas'</code> renderer).
    </p>

    <p>
      This renderer (if non-null) will override any renderers set on ancestor nodes. Effectively, a node's renderer will be decided by whatever the
      closest ancestor
      renderer that is compatible, or the scene default.
    </p>

    <h4 id="node-layerSplit">node.layerSplit</h4>

    <p>
      Setter backed by <code>node.setLayerSplit( boolean )</code> that, when to true will cause anything rendered before or after to be in a
      separate layer from this node and its children.
    </p>

    <h3 id="display" class="section">Display</h3>

    <p>
      The Display is responsible for visually displaying a specific root Node and all of its descendants. It is
      created with <code>new scenery.Display( node, [options] )</code>, where <code>node</code> is the
      <a href="#node">Node</a> to display, and the options available are documented below. Unlike earlier versions,
      the Display is NOT a sub-type of Node, and the root node may be referred to as the 'scene'.
    </p>

    <h4 id="display-options">Display Options</h4>
    A Display has the following options for the parameter object:

    <ul>
      <li><a href="#display-allowSceneOverflow">allowSceneOverflow</a> (default false): usually anything displayed outside of this $main (DOM/CSS3
        transformed SVG) is hidden with CSS overflow
      </li>
      <li><a href="#display-allowCSSHacks">allowCSSHacks</a> (default true): applies styling that prevents mobile browser graphical issues</li>
      <li><a href="#display-allowWebGL">allowWebGL</a> (default true): sets whether WebGL can be used.</li>
      <li><a href="#display-width">width</a> (default currentWidth): override the main container's width</li>
      <li><a href="#display-height">height</a> (default currentHeight): override the main container's height</li>
    </ul>

    <h4 id="display-domElement">display.domElement</h4>

    <p>
      The Display's block-level DOM element that will show all rendered content, to be added to the DOM.
    </p>

    <h4 id="display-updateDisplay">display.updateDisplay()</h4>

    <p>
      This redraws and/or repositions whatever rendering backends are being used to display the scene.
      It should be called whenever the scene's display should reflect new changes, generally on each
      <a href="https://developer.mozilla.org/en-US/docs/DOM/window.requestAnimationFrame">requestAnimationFrame</a>.
    </p>

    <h4 id="display-rootNode">display.rootNode</h4>

    <p>
      <code>display.rootNode</code> or <code>display.getRootNode()</code> will contain the displayed node that was
      passed in the constructor.
    </p>

    <h4 id="display-size">display.size</h4>

    <p>
      <code>display.size</code> is a getter/setter for <code>display.getSize()</code> and <code>display.setSize( size )</code> which can retrieve or
      set the size of the display's DOM element (of type
      <a href="../../dot/doc#dimension2">Dimension2</a>). The size will not change until after the next <a
        href="#display-updateDisplay">updateDisplay</a> call.
    </p>

    <h4 id="display-width">display.width</h4>

    <p>
      <code>display.width</code> is a getter/setter for <code>display.getWidth()</code> and <code>display.setWidth( width )</code> which can retrieve
      or set the width of the display's DOM element. The width will not change until after the next <a href="#display-updateDisplay">updateDisplay</a>
      call.
    </p>

    <h4 id="display-height">display.height</h4>

    <p>
      <code>display.height</code> is a getter/setter for <code>display.getHeight()</code> and <code>display.setHeight( height )</code> which can
      retrieve or set the height of the display's DOM element. The height will not change until after the next <a href="#display-updateDisplay">updateDisplay</a>
      call.
    </p>

    <h4 id="display-backgroundColor">display.backgroundColor</h4>

    <p>
      <code>display.backgroundColor</code> is a getter/setter for <code>display.getBackgroundColor()</code> and <code>display.setBackgroundColor(
      backgroundColor )</code> which can retrieve or set the background color (String or <a href="#color">Color</a>) of the display's DOM element
      (defaults to transparent). The background color will not change until after the next <a href="#display-updateDisplay">updateDisplay</a> call.
    </p>


    <h3 id="paintable" class="section">Paintable</h3>

    <p>
      A trait for <a href="#node">Node</a> subtypes that can be filled and/or stroked with a color/gradient/pattern.
    </p>

    <h4 id="paintable-fill">fill</h4>

    <p>
      <a href="#paintable">Paintable</a> nodes provide a single <code>node.fill</code> getter and setter
      that uses <code>node.getFill()</code> and <code>node.setFill( fill )</code>. <code>node.hasFill()</code>
      is also available as a quick check, and a null fill is interpreted as not having a fill.
    </p>

    <p>
      <code>fill</code> can currently be either a string (interpreted as a <a href="http://www.w3.org/TR/css3-color/">CSS color</a>), a
      <a href="#color">Color</a> object, or an instance of a
      <a href="#linearGradient">LinearGradient</a>, <a href="#radialGradient">RadialGradient</a> or
      <a href="#pattern">Pattern</a>.
    </p>

    <p>
      If a <a href="#color">Color</a> object is used for a fill, any changes to the Color object will update this node.
    </p>

    <h4 id="paintable-fillPickable">fillPickable</h4>

    <p>
      <code>node.fillPickable</code> is a getter/setter linked to <code>node.isFillPickable()</code> and <code>node.setFillPickable( boolean )</code>.
      <a href="#path">Paths</a> or other <a href="#paintable">Paintable</a> objects will be considered to be under a <a href="#pointer">Pointer</a> when
      it is over the region where the fill is painted. This defaults to true.
    </p>

    <p>
      NOTE: <a href="#text">Text</a> nodes currently do not respect this setting, since there is no easy/fast way of determining whether a point is
      inside
      or outside of a Text node's painted region.
    </p>

    <h4 id="paintable-stroke">stroke</h4>

    <p>
      <code>node.stroke</code> is a getter and setter
      that uses <code>node.getStroke()</code> and <code>node.setStroke( stroke )</code>. <code>node.hasStroke()</code>
      is also available as a quick check, and a null stroke is interpreted as not having a stroke.
    </p>

    <p>
      <code>stroke</code> can currently be either a string (interpreted as a <a href="http://www.w3.org/TR/css3-color/">CSS color</a>),
      a <a href="#color">Color</a> object, or an instance of a
      <a href="#linearGradient">LinearGradient</a>, <a href="#radialGradient">RadialGradient</a> or
      <a href="#pattern">Pattern</a>.
    </p>

    <p>
      If a <a href="#color">Color</a> object is used for a stroke, any changes to the Color object will update this
      node.
    </p>

    <h4 id="paintable-strokePickable">strokePickable</h4>

    <p>
      <code>node.strokePickable</code> is a getter/setter linked to <code>node.isStrokePickable()</code> and
      <code>node.setStrokePickable( boolean )</code>. <a href="#path">Paths</a> or other
      <a href="#paintable">Paintable</a> objects will be considered to be under a <a href="#pointer">Pointer</a>
      when it is over the region where the stroke is painted. This defaults to false, as it is generally more
      computationally expensive, and Scenery did not support this initially.
    </p>

    <p>
      NOTE: <a href="#text">Text</a> nodes currently do not respect this setting, since there is no easy/fast way of
      determining whether a point is inside or outside of a Text node's painted region.
    </p>

    <h4 id="paintable-lineWidth">lineWidth</h4>

    <p>
      <code>node.lineWidth</code> (<code>node.getLineWidth()</code>, <code>node.setLineWidth( lineWidth )</code>)
      controls the thickness of the stroke.
    </p>

    <h4 id="paintable-lineCap">lineCap</h4>

    <p>
      <code>node.lineCap</code> (<code>node.getLineCap()</code>, <code>node.setLineCap( lineCap )</code>)
      controls the shape of end-caps, and uses the <a
        href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-linecap">Canvas lineCap
      definitions</a> of <code>'butt'</code> (default),
      <code>'round'</code> and <code>'square'</code>.
    </p>

    <div id="example-lineCap" class="exampleScene" style="width: 256px; height: 64px; margin: 0 auto;"></div>
    <script type="text/javascript">
      docExample( 'example-lineCap', function( scene ) {
        scene.addChild( new scenery.Text( 'butt', {
          fontSize: 14,
          centerX: 256 / 6,
          y: 20
        } ) );
        scene.addChild( new scenery.Text( 'square', {
          fontSize: 14,
          centerX: 256 * 3 / 6,
          y: 20
        } ) );
        scene.addChild( new scenery.Text( 'round', {
          fontSize: 14,
          centerX: 256 * 5 / 6,
          y: 20
        } ) );
        /*START*/
        var shape = kite.Shape.lineSegment( 0, 50, 0, 70 );
        scene.addChild( new scenery.Path( shape, {
          x: 256 / 6,
          stroke: '#000',
          lineWidth: 30,
          lineCap: 'butt'
        } ) );
        scene.addChild( new scenery.Path( shape, {
          x: 256 * 3 / 6,
          stroke: '#000',
          lineWidth: 30,
          lineCap: 'square'
        } ) );
        scene.addChild( new scenery.Path( shape, {
          x: 256 * 5 / 6,
          stroke: '#000',
          lineWidth: 30,
          lineCap: 'round'
        } ) );
        /*END*/
// add a red highlight
        scene.addChild( new scenery.Path( shape, {
          x: 256 / 6,
          stroke: '#f00'
        } ) );
        scene.addChild( new scenery.Path( shape, {
          x: 256 * 3 / 6,
          stroke: '#f00'
        } ) );
        scene.addChild( new scenery.Path( shape, {
          x: 256 * 5 / 6,
          stroke: '#f00'
        } ) );
      } );
    </script>

    <h4 id="paintable-lineJoin">lineJoin</h4>

    <p>
      <code>node.lineJoin</code> (<code>node.getLineJoin()</code>, <code>node.setLineJoin( lineJoin )</code>)
      controls the shape of segment joins, and uses the <a
        href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-linejoin">Canvas lineJoin
      definitions</a> of <code>'miter'</code> (default),
      <code>'round'</code> and <code>'bevel'</code>.
    </p>

    <div id="example-lineJoin" class="exampleScene" style="width: 256px; height: 64px; margin: 0 auto;"></div>
    <script type="text/javascript">
      docExample( 'example-lineJoin', function( scene ) {
        scene.addChild( new scenery.Text( 'miter', {
          fontSize: 14,
          centerX: 256 / 6,
          y: 20
        } ) );
        scene.addChild( new scenery.Text( 'bevel', {
          fontSize: 14,
          centerX: 256 * 3 / 6,
          y: 20
        } ) );
        scene.addChild( new scenery.Text( 'round', {
          fontSize: 14,
          centerX: 256 * 5 / 6,
          y: 20
        } ) );
        /*START*/
        var shape = new kite.Shape().moveTo( -30, 80 ).lineTo( 0, 50 ).lineTo( 30, 80 );
        scene.addChild( new scenery.Path( shape, {
          x: 256 / 6,
          stroke: '#000',
          lineWidth: 25,
          lineJoin: 'miter'
        } ) );
        scene.addChild( new scenery.Path( shape, {
          x: 256 * 3 / 6,
          stroke: '#000',
          lineWidth: 25,
          lineJoin: 'bevel'
        } ) );
        scene.addChild( new scenery.Path( shape, {
          x: 256 * 5 / 6,
          stroke: '#000',
          lineWidth: 25,
          lineJoin: 'round'
        } ) );
        /*END*/
// add a red highlight
        scene.addChild( new scenery.Path( shape, {
          x: 256 / 6,
          stroke: '#f00'
        } ) );
        scene.addChild( new scenery.Path( shape, {
          x: 256 * 3 / 6,
          stroke: '#f00'
        } ) );
        scene.addChild( new scenery.Path( shape, {
          x: 256 * 5 / 6,
          stroke: '#f00'
        } ) );
      } );
    </script>

    <h4 id="paintable-lineDash">lineDash</h4>

    <p>
      <code>node.lineDash</code> (<code>node.getLineDash()</code>, <code>node.setLineDash( lineDash )</code>)
      controls any dashing of the stroke (or null for no dashing), and uses the <a
        href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-setlinedash">Canvas setLineDash</a>
      handling
      as an even-length array of dash lengths.
    </p>

    <div id="example-lineDash" class="exampleScene" style="width: 64px; height: 64px; margin: 0 auto;"></div>
    <script type="text/javascript">
      docExample( 'example-lineDash', function( scene ) {
        /*START*/
        scene.addChild( new scenery.Path( kite.Shape.regularPolygon( 6, 25 ), {
          x: 32, y: 32,
          stroke: '#000',
          lineWidth: 3,
          lineDash: [ 10, 5 ]
        } ) );
        /*END*/
      } );
    </script>

    <h4 id="paintable-lineDashOffset">lineDashOffset</h4>

    <p>
      <code>node.lineDashOffset</code> (<code>node.getLineDashOffset()</code>, <code>node.setLineDashOffset( lineDashOffset )</code>)
      controls the how far the dash pattern in <a href="#paintable-lineDash">lineDash</a> is offset from the start,
      same as the <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-linedashoffset">Canvas
      lineDashOffset</a>.
    </p>

    <div id="example-lineDashOffset" class="exampleScene" style="width: 128px; height: 64px; margin: 0 auto;"></div>
    <script type="text/javascript">
      docExample( 'example-lineDashOffset', function( scene ) {
        scene.addChild( new scenery.Path( new kite.Shape().moveTo( 0, 16.5 )
            .lineTo( 128, 16.5 )
            .moveTo( 0, 32.5 )
            .lineTo( 128, 32.5 )
            .moveTo( 0, 48.5 )
            .lineTo( 128, 48.5 ), {
          stroke: '#f00'
        } ) );
        /*START*/
        var shape = kite.Shape.lineSegment( 0, 0, 128, 0 );
        var args = {
          stroke: '#000',
          lineWidth: 8,
          lineDash: [ 20, 5 ]
        };
        scene.addChild( new scenery.Path( shape, _.extend( {
          y: 16.5,
          lineDashOffset: 0
        }, args ) ) );
        scene.addChild( new scenery.Path( shape, _.extend( {
          y: 32.5,
          lineDashOffset: 5
        }, args ) ) );
        scene.addChild( new scenery.Path( shape, _.extend( {
          y: 48.5,
          lineDashOffset: 10
        }, args ) ) );
        /*END*/
      } );
    </script>

    <h4 id="paintable-cachedPaints">cachedPaints</h4>

    <p>
      <code>node.cachedPaints</code> (<code>node.getCachedPaints()</code>, <code>node.setCachedPaints( paints )</code>)
      controls an array of paints (<a href="#linearGradient">LinearGradient</a>s,
      <a href="#radialGradient">RadialGradient</a>s, and <a href="#pattern">Pattern</a>s) that will be kept in-memory
      when the node is being displayed. This allows for much faster performance switching to/from these paints. For
      instance, in SVG the gradients will be kept in the &lt;defs&gt; section even while not being used, so they don't
      have to be recreated when switched to (where we have seen major performance drops in the past).
    </p>

    <p>
      Additionally, <code>node.addCachedPaint( paint )</code> and <code>node.removeCachedPaint( paint )</code> exist to
      be able to manipulate the cached paints without redoing all of them.
    </p>

    <h3 id="path" class="section">Path</h3>

    <p>
      Path is a <a href="#node">Node</a> subtype that includes the <a href="#paintable">Paintable</a> trait.
      The main displayed behavior is controlled by its single
      additional option <a href="#path-shape">shape</a> along with the <a href="#paintable-fill">fill</a>
      and <a href="#paintable-stroke">stroke</a> options.
    </p>

    <p>
      A path is constructed with <code>new scenery.Path( options )</code>, where <code>options</code>
      is the standard <a href="#node">Node</a> parameter object, where the <a href="#path-shape">shape</a>
      should be specified.
    </p>

    <h4 id="path-shape">shape</h4>

    <p>
      <code>node.shape</code> (<code>node.getShape()</code>, <code>node.setShape( shape )</code>)
      controls the shape of this path, and is either an instance of <a href="../../kite">Kite</a>'s
      <a href="../../kite/doc#shape">Shape</a>, or it is a string representing an <a href="http://www.w3.org/TR/SVG/paths.html#DAttribute">SVG
      path</a>,
      and will be converted into a <a href="../../kite/doc#shape">Shape</a>.
    </p>

    <h3 id="image" class="section">Image</h3>

    <p>
      Image is a <a href="#node">Node</a> subtype that displays a single image in either Canvas,
      SVG or DOM. An image node is constructed with <code>new scenery.Image( image, [options] )</code>,
      where <code>image</code> is as described in <a href="#image-image">image</a>, and
      <code>options</code> is the normal <a href="#node-options">options parameter object</a>.
    </p>

    <div id="example-image" class="exampleScene" style="width: 130px; height: 85px; margin: 0 auto;"></div>
    <script type="text/javascript">
      docExample( 'example-image', function( scene, display ) {
        var url = 'http://phet.colorado.edu/sims/my-solar-system/my-solar-system-thumbnail.png';
        /*START*/
        scene.addChild( new scenery.Image( url ) );
        /*END*/
        display.updateOnRequestAnimationFrame();
      } );
    </script>

    <h4 id="image-image">image</h4>

    <p>
      <code>node.image</code> (<code>node.getImage()</code>, <code>node.setImage( image )</code>)
      gets or sets the 'image' of the Image node. It can be one of the following:
    </p>
    <ul>
      <li>
        A <strong>String</strong>, treated as a URL and loads the image. <strong>Bounds-based mutators
        like <a href="#node-left">left</a> and <a href="#node-centerY">centerY</a> will not work</strong>,
        since the image will not have the correct dimensions on node construction.
      </li>
      <li>
        A <strong>HTMLImageElement</strong> will be used directly. If the image is not loaded yet,
        the bounds-based mutators (as noted above for the String case) will not work properly.
      </li>
      <li>
        A <strong>HTMLCanvasElement</strong> can also be used, but will force the node to use
        a Canvas renderer.
      </li>
    </ul>

    <h3 id="text" class="section">Text</h3>

    <p>
      Text is a <a href="#node">Node</a> subtype that (currently) displays a single line of text
      in Canvas or SVG. DOM and multiline support is planned. It also mixes in
      <a href="#paintable">Paintable</a>,
      so it supports fills and strokes with colors, gradients and patterns.
      The default fill is <code>'#000'</code>, so text is black by default, with no stroke, so
      to JUST stroke text, set fill to null.
    </p>

    <p>
      Text nodes are constructed with <code>new scenery.Text( text, [options] )</code>, where
      <code>text</code> is described by <a href="#text-text">text</a>, and <code>options</code>
      is the standard <a href="#node">Node</a> parameter object.
    </p>

    <div id="example-text" class="exampleScene" style="width: 256px; height: 64px; margin: 0 auto;"></div>
    <script type="text/javascript">
      docExample( 'example-text', function( scene ) {
        /*START*/
        scene.addChild( new scenery.Text( 'Some text', {
          font: '20px sans-serif',
          centerX: 128, centerY: 32
        } ) );
        /*END*/
      } );
    </script>

    <h4 id="text-options">Text Options</h4>

    <p>
      A <a href="#text">Text</a> node has the following parameter object options, in addition to
      the ones from <a href="#paintable">Paintable</a>.
    </p>
    <ul>
      <li><a href="#text-text">text</a></li>
      <li><a href="#text-font">font</a></li>
      <li><a href="#text-fontWeight">fontWeight</a></li>
      <li><a href="#text-fontFamily">fontFamily</a></li>
      <li><a href="#text-fontStretch">fontStretch</a></li>
      <li><a href="#text-fontStyle">fontStyle</a></li>
      <li><a href="#text-fontSize">fontSize</a></li>
      <li><a href="#text-lineHeight">lineHeight</a></li>
      <li><a href="#text-textAlign">textAlign</a></li>
      <li><a href="#text-textBaseline">textBaseline</a></li>
      <li><a href="#text-direction">direction</a></li>
    </ul>

    <h4 id="text-text">text</h4>

    <p>
      <code>node.text</code> (<code>node.getText()</code>, <code>node.setText( string )</code>)
      gets or sets the string text.
    </p>

    <h4 id="text-font">font</h4>

    <p>
      <code>node.font</code> (<code>node.getFont()</code>, <code>node.setFont( font )</code>)
      gets or sets the entire font. This can be a <a href="#font">Font</a> object, or a String
      that is interpreted as a <a href="http://www.w3.org/TR/css3-fonts/">CSS font</a>.
    </p>

    <p>
      Note that Canvas places <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-font">restrictions</a>
      on the possible interpreted values, so
      only those should be set on a <a href="#text">Text</a> node.
    </p>

    <h4 id="text-fontWeight">fontWeight</h4>

    <p>
      <code>node.fontWeight</code> (<code>node.getFontWeight()</code>, <code>node.setFontWeight( weight )</code>)
      gets or sets the <a href="#font-weight">font weight</a> by internally forwarding to the <a href="#text">Text</a> node's
      internal <a href="#font">Font</a> reference.
    </p>

    <p>
      Setting the fontWeight will create a new internal Font object, so future changes to the original Font will not apply to this node.
    </p>

    <h4 id="text-fontFamily">fontFamily</h4>

    <p>
      <code>node.fontFamily</code> (<code>node.getFontFamily()</code>, <code>node.setFontFamily( family )</code>)
      gets or sets the <a href="#font-family">font family</a> by internally forwarding to the <a href="#text">Text</a> node's
      internal <a href="#font">Font</a> reference.
    </p>

    <p>
      Setting the fontWeight will create a new internal Font object, so future changes to the original Font will not apply to this node.
    </p>

    <h4 id="text-fontStretch">fontStretch</h4>

    <p>
      <code>node.fontStretch</code> (<code>node.getFontStretch()</code>, <code>node.setFontStretch( stretch )</code>)
      gets or sets the <a href="#font-stretch">font stretch</a> by internally forwarding to the <a href="#text">Text</a> node's
      internal <a href="#font">Font</a> reference.
    </p>

    <p>
      Setting the fontWeight will create a new internal Font object, so future changes to the original Font will not apply to this node.
    </p>

    <h4 id="text-fontStyle">fontStyle</h4>

    <p>
      <code>node.fontStyle</code> (<code>node.getFontStyle()</code>, <code>node.setFontStyle( style )</code>)
      gets or sets the <a href="#font-style">font style</a> by internally forwarding to the <a href="#text">Text</a> node's
      internal <a href="#font">Font</a> reference.
    </p>

    <p>
      Setting the fontWeight will create a new internal Font object, so future changes to the original Font will not apply to this node.
    </p>

    <h4 id="text-fontSize">fontSize</h4>

    <p>
      <code>node.fontSize</code> (<code>node.getFontSize()</code>, <code>node.setFontSize( size )</code>)
      gets or sets the <a href="#font-size">font size</a> by internally forwarding to the <a href="#text">Text</a> node's
      internal <a href="#font">Font</a> reference.
    </p>

    <p>
      Setting the fontWeight will create a new internal Font object, so future changes to the original Font will not apply to this node.
    </p>

    <h4 id="text-lineHeight">lineHeight</h4>

    <p>
      <code>node.lineHeight</code> (<code>node.getLineHeight()</code>, <code>node.setLineHeight( lineHeight )</code>)
      gets or sets the <a href="#font-lineHeight">line height</a> by internally forwarding to the <a href="#text">Text</a> node's
      internal <a href="#font">Font</a> reference.
    </p>

    <p>
      Setting the fontWeight will create a new internal Font object, so future changes to the original Font will not apply to this node.
    </p>

    <h4 id="text-direction">direction</h4>

    <p>
      <code>node.direction</code> (<code>node.getDirection()</code>, <code>node.setDirection( direction )</code>)
      sets the LTR or RTL direction of the text. It should take on values from
      Canvas's <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-direction">context.direction</a>,
      but <strong>proper bounds and renderer compatibility is not ensured yet</strong>
    </p>

    <h4 id="text-boundsMethod">boundsMethod</h4>

    <p>
      <code>node.boundsMethod</code> (<code>node.getBoundsMethod()</code>, <code>node.setBoundsMethod( method )</code>)
      sets what type of method is used for determining Text bounds. Currently, there are three options: <code>"fast"</code>
      which may be somewhat inaccurate, is much faster, and disables Canvas rendering entirely, <code>"fastCanvas"</code> (default)
      which is similar but allows Canvas rendering but with dirty region redrawing disabled, or <code>"accurate"</code>
      which is accurate and supports dirty regions, but is much slower.
    </p>

    <h3 id="htmlText" class="section">HTMLText</h3>

    <p>
      HTMLText behaves exactly like <a href="#text">Text</a>, except that it displays the text as unescaped HTML.
      It will force the DOM renderer (possibly it might also allow the SVG renderer with foreignObject in the future).
      The <code>"accurate"</code> <a href="#text-boundsMethod">boundsMethod</a> is also disallowed, since using
      Canvas for HTML bounds would be extremely inaccurate.
    </p>

    <div id="example-htmlText" class="exampleScene" style="width: 256px; height: 64px; margin: 0 auto;"></div>
    <script type="text/javascript">
      docExample( 'example-htmlText', function( scene ) {
        /*START*/
        scene.addChild( new scenery.HTMLText( '<strong>bold</strong>, <em>italic</em>', {
          font: '20px sans-serif',
          centerX: 128, centerY: 32,
        } ) );
        /*END*/
      } );
    </script>

    <h3 id="dom" class="section">DOM</h3>

    <p>
      DOM is a subtype of <a href="#node">Node</a> that positions a DOM element inside the scene using
      <a href="http://www.w3.org/TR/css3-transforms/">CSS transforms</a>. If the element is attached somewhere
      else, it will be removed and added into the DOM within the <a href="#display">display</a>'s container
      block-level element.
    </p>

    <p>
      DOM nodes should be constructed by passing in the DOM element, along with a parameter object if desired:
      <code>new scenery.DOM( element, [options] )</code>
    </p>

    <div id="example-dom" class="exampleScene" style="width: 256px; height: 128px; margin: 0 auto;"></div>
    <script type="text/javascript">
      docExample( 'example-dom', function( scene ) {
        /*START*/
        var element = document.createElement( 'span' );
        element.innerHTML = '<label style="display: inline;">Type in me: </label><input type="text">';
        scene.addChild( new scenery.DOM( element, { x: 30, rotation: Math.PI / 6 } ) );
        /*END*/
      } );
    </script>

    <h4 id="dom-element">element</h4>

    <p>
      <code>node.element</code> (<code>node.getElement()</code>, <code>node.setElement( domElement )</code>)
      controls the displayed DOM element. If the element is a block-level element, it should have a specified
      width and height.
    </p>

    <h4 id="dom-interactive">interactive</h4>

    <p>
      <code>node.interactive</code> (<code>node.getInteractive()</code>, <code>node.setInteractive( boolean )</code>),
      when set to true, will signal to Scenery's event system that preventDefault() should not be called
      on DOM events when the DOM node is the event target.
    </p>


    <h3 id="linearGradient" class="section">LinearGradient</h3>

    <p>
      A LinearGradient can be used in place of a color for any <a href="#paintable-fill">fill</a> or
      <a href="#paintable-stroke">stroke</a>, but is usually done for <a href="#path">Paths</a>.
    </p>

    <p>
      LinearGradient is constructed and used very similarly to Canvas's
      <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-createlineargradient">context.createLinearGradient</a>,
      with
      <code>new scenery.LinearGradient( x0, y0, x1, y1 )</code> where the gradient goes from (x0,y0) to
      (x1,y1), and then <a href="#linearGradient-addColorStop">color stops</a> can be added.
    </p>

    <div id="example-linearGradient" class="exampleScene" style="width: 128px; height: 128px; margin: 0 auto;"></div>
    <script type="text/javascript">
      docExample( 'example-linearGradient', function( scene ) {
        /*START*/
        scene.addChild( new scenery.Path( kite.Shape.rectangle( 0, 0, 128, 128 ), {

          // upper-left to lower-right
          fill: new scenery.LinearGradient( 0, 0, 128, 128 )
              .addColorStop( 0, '#888' )
              .addColorStop( 0.4, '#000' )
              .addColorStop( 1, '#555' )
        } ) );
        scene.addChild( new scenery.Text( 'A', {
          fontSize: 80,
          centerX: 64, centerY: 64,

          // left to right
          fill: new scenery.LinearGradient( 0, 0, 55, 0 )
              .addColorStop( 0, '#f00' )
              .addColorStop( 1, '#ff0' )
        } ) );
        /*END*/
      } );
    </script>

    <h4 id="linearGradient-addColorStop">addColorStop( <span class="args">ratio, color</span> )</h4>

    <p>
      Adds a point of color along the gradient, where a ratio of 0 is a color point at (x0,y0) and
      a ratio of 1 is a color point at (x1,y1).
    </p>

    <h4 id="linearGradient-setTransformMatrix">setTransformMatrix( <span class="args">matrix</span> )</h4>

    <p>
      Given a <a href="../../dot/doc#matrix3">Matrix3</a> for <code>matrix</code>, it will transform
      the gradient as it is applied. This should only be done before adding it as a fill/stroke to
      any nodes.
    </p>

    <h3 id="radialGradient" class="section">RadialGradient</h3>

    <p>
      A RadialGradient can be used in place of a color for any <a href="#paintable-fill">fill</a> or
      <a href="#paintable-stroke">stroke</a>, but is usually done for <a href="#path">Paths</a>.
    </p>

    <p>
      RadialGradient is constructed and used very similarly to Canvas's
      <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-createradialgradient">context.createRadialGradient</a>,
      with
      <code>new scenery.RadialGradient( x0, y0, r0, x1, y1, r1 )</code> where the gradient handled between
      two circles, one centered at (x0,y0) with a radius r0, and the other at (x1,y1) with a radius r1.
      Due to SVG compatibility, this is slightly constricted, as the smaller circle needs to be completely
      within the larger circle. Then <a href="#radialGradient-addColorStop">color stops</a> can be added.
    </p>

    <p>
      <strong>NOTE: Firefox 19 (Win 7) does not currently render "conic" radial gradients correctly (where x0 != x1 or y0 != y1).</strong>
      This does not appear to be the case with Firefox 19 on Mac, but please refrain from those edge-case gradients.
    </p>

    <div id="example-radialGradient" class="exampleScene" style="width: 128px; height: 128px; margin: 0 auto;"></div>
    <script type="text/javascript">
      docExample( 'example-radialGradient', function( scene ) {
        /*START*/
        scene.addChild( new scenery.Path( kite.Shape.rectangle( 0, 0, 128, 128 ), {

          // starts at a 10-px radius circle and expands out nonuniformly
          fill: new scenery.RadialGradient( 32, 32, 10, 64, 64, 90 )
              .addColorStop( 0, '#05f' )
              .addColorStop( 0.5, '#306' )
              .addColorStop( 1, '#000' )
        } ) );

        var transparent = 'rgba(255,255,255,0)';
        var letter = '#fff';
        scene.addChild( new scenery.Text( 'A', {
          fontSize: 80,
          centerX: 64, centerY: 64,

          // concentric circles
          fill: new scenery.RadialGradient( 25, -30, 0, 25, -30, 50 )
              .addColorStop( 0, transparent )
              .addColorStop( 0.1, letter )
              .addColorStop( 0.2, transparent )
              .addColorStop( 0.3, letter )
              .addColorStop( 0.4, transparent )
              .addColorStop( 0.5, letter )
              .addColorStop( 0.6, transparent )
              .addColorStop( 1, letter )
        } ) );
        /*END*/
      } );
    </script>

    <h4 id="radialGradient-addColorStop">addColorStop( <span class="args">ratio, color</span> )</h4>

    <p>
      Adds a point of color along the gradient, where a ratio of 0 is a color point at (x0,y0) and
      a ratio of 1 is a color point at (x1,y1).
    </p>

    <h4 id="radialGradient-setTransformMatrix">setTransformMatrix( <span class="args">matrix</span> )</h4>

    <p>
      Given a <a href="../../dot/doc#matrix3">Matrix3</a> for <code>matrix</code>, it will transform
      the gradient as it is applied. This should only be done before adding it as a fill/stroke to
      any nodes.
    </p>

    <h3 id="pattern" class="section">Pattern</h3>

    <p>
      A Pattern can be used in place of a color for any <a href="#paintable-fill">fill</a> or
      <a href="#paintable-stroke">stroke</a>, but is usually done for <a href="#path">Paths</a>.
    </p>

    <p>
      Pattern is constructed and used very similarly to Canvas's
      <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-createpattern">context.createPattern</a>,
      with
      <code>new scenery.Pattern( image )</code> where <code>image</code> is an HTMLImageElement.
    </p>

    <div id="example-pattern" class="exampleScene" style="width: 256px; height: 256px; margin: 0 auto;"></div>
    <script type="text/javascript">
      docExample( 'example-pattern', function( scene, display ) {
        var loadedImg = document.createElement( 'img' );
        loadedImg.addEventListener( 'load', function() {
          /*START*/
          scene.addChild( new scenery.Path( kite.Shape.roundRectangle( 10, 10, 236, 236, 64, 64 ), {

            // tile the image, and rotate it 30 degrees, and scale it down
            fill: new scenery.Pattern( loadedImg ).setTransformMatrix(
                dot.Matrix3.rotation2( Math.PI / 6 )
                    .timesMatrix( dot.Matrix3.scale( 0.5 ) ) ),
            stroke: '#000'
          } ) );
          /*END*/
          display.updateDisplay();
        } );
        loadedImg.src = 'http://phet.colorado.edu/images/phet-logo-yellow.png';
// loadedImg.src = 'http://phet.colorado.edu/sims/plate-tectonics/plate-tectonics-thumbnail.png';
      } );
    </script>

    <h4 id="pattern-setTransformMatrix">setTransformMatrix( <span class="args">matrix</span> )</h4>

    <p>
      Given a <a href="../../dot/doc#matrix3">Matrix3</a> for <code>matrix</code>, it will transform
      the gradient as it is applied. This should only be done before adding it as a fill/stroke to
      any nodes.
    </p>

    <h3 id="vbox" class="section">VBox</h3>

    <h3 id="rectangle" class="section">Rectangle</h3>

    <p>
      Rectangle is a subtype of <a href="#path">Path</a> that is more convenient to construct
      and modify, and contains more optimized drawing routines for Canvas and SVG.
    </p>

    <p>
      A Rectangle is normally created with <code>new scenery.Rectangle( x, y, width, height, [options] )</code>,
      but rounded corners can be specified with <code>new scenery.Rectangle( x, y, width, height, arcWidth, arcHeight, [options] )</code>,
      or all of the parameters can be specified in the options with
      <code>new scenery.Rectangle( { rectX: _, rectY: _, rectWidth: _, rectHeight: _, ... } )</code>
    </p>

    <div id="example-rectangle" class="exampleScene" style="width: 128px; height: 64px; margin: 0 auto;"></div>
    <script type="text/javascript">
      docExample( 'example-rectangle', function( scene ) {
        /*START*/
// red rectangle
        scene.addChild( new scenery.Rectangle( 10, 10, 44, 44, {
          fill: '#f00',
        } ) );

// green rotated rectangle
        var s = 44 / Math.sqrt( 2 );
        scene.addChild( new scenery.Rectangle( -s / 2, -s / 2, s, s, {
          fill: '#0f0',
          x: 32, y: 32,
          rotation: Math.PI / 4
        } ) );

// blue rectangle with 10px rounded corners
        scene.addChild( new scenery.Rectangle( 74, 10, 44, 44, 10, 10, {
          fill: '#00f',
        } ) );
        /*END*/
      } );
    </script>

    <h4 id="rectangle-rectX">rectX</h4>

    <p>
      <code>node.rectX</code> (<code>node.getRectX()</code>, <code>node.setRectX( x )</code>)
      retrieves or modifies the 'x' parameter of the <a href="#rectangle">Rectangle</a>.
    </p>

    <h4 id="rectangle-rectY">rectY</h4>

    <p>
      <code>node.rectY</code> (<code>node.getRectY()</code>, <code>node.setRectY( y )</code>)
      retrieves or modifies the 'y' parameter of the <a href="#rectangle">Rectangle</a>.
    </p>

    <h4 id="rectangle-rectWidth">rectWidth</h4>

    <p>
      <code>node.rectWidth</code> (<code>node.getRectWidth()</code>, <code>node.setRectWidth( width )</code>)
      retrieves or modifies the 'width' parameter of the <a href="#rectangle">Rectangle</a>.
    </p>

    <h4 id="rectangle-rectHeight">rectHeight</h4>

    <p>
      <code>node.rectHeight</code> (<code>node.getRectHeight()</code>, <code>node.setRectHeight( height )</code>)
      retrieves or modifies the 'height' parameter of the <a href="#rectangle">Rectangle</a>.
    </p>

    <h4 id="rectangle-cornerRadius">cornerRadius</h4>

    <p>
      <code>node.cornerRadius</code> (<code>node.getCornerRadius()</code>, <code>node.setCornerRadius( radius )</code>)
      retrieves or modifies the 'cornerRadius' parameter of the <a href="#rectangle">Rectangle</a>. This effectively
      sets both the <a href="#rectangle-cornerXRadus">cornerXRadius</a> and
      <a href="#rectangle-cornerYRadus">cornerYRadius</a> at the same time. An assertion will fail if the getter is
      called while the two corner radii are different.
    </p>

    <h4 id="rectangle-cornerXRadius">cornerXRadius</h4>

    <p>
      <code>node.cornerXRadius</code> (<code>node.getCornerXRadius()</code>, <code>node.setCornerXRadius( radius )</code>)
      retrieves or modifies the 'cornerXRadius' parameter of the <a href="#rectangle">Rectangle</a>.
    </p>

    <h4 id="rectangle-cornerYRadius">cornerYRadius</h4>

    <p>
      <code>node.cornerYRadius</code> (<code>node.getCornerYRadius()</code>, <code>node.setCornerYRadius( radius )</code>)
      retrieves or modifies the 'cornerYRadius' parameter of the <a href="#rectangle">Rectangle</a>.
    </p>

    <h3 id="circle" class="section">Circle</h3>

    <p>
      Circle is a subtype of <a href="#path">Path</a> that is more convenient to construct
      and modify, and contains more optimized drawing routines for SVG.
    </p>

    <p>
      A Circle is created with <code>new scenery.Circle( radius, [options] )</code> with the specified radius.
    </p>

    <div id="example-circle" class="exampleScene" style="width: 64px; height: 64px; margin: 0 auto;"></div>
    <script type="text/javascript">
      docExample( 'example-circle', function( scene ) {
        /*START*/
        scene.addChild( new scenery.Circle( 22, {
          x: 32, y: 32, fill: '#f00'
        } ) );
        scene.addChild( new scenery.Circle( 11, {
          x: 43, y: 32, fill: '#0f0'
        } ) );
        /*END*/
      } );
    </script>

    <h4 id="circle-radius">radius</h4>

    <p>
      <code>node.radius</code> (<code>node.getRadius()</code>, <code>node.setRadius( radius )</code>)
      retrieves or modifies the 'radius' parameter of the <a href="#circle">Circle</a>.
    </p>

    <h3 id="line" class="section">Line</h3>

    <p>
      Line is a subtype of <a href="#path">Path</a> that is more convenient to construct
      and modify, and contains more optimized drawing routines for SVG.
    </p>

    <p>
      A Line is created with <code>new scenery.Line( x1, y1, x2, y2, [options] )</code> as a line from (x1,y1) to (x2,y2). Additionally,
      the constructors <code>new scenery.Line( new Vector2( x1, y1 ), new Vector2( x2, y2 ), [options] )</code> and
      <code>new scenery.Line( { x1: x1, y1: y1, x2: x2, y2: y2, [other options] } )</code>
      are supported.
    </p>

    <div id="example-line" class="exampleScene" style="width: 64px; height: 64px; margin: 0 auto;"></div>
    <script type="text/javascript">
      docExample( 'example-line', function( scene ) {
        /*START*/
        scene.addChild( new scenery.Line( 8, 8, 56, 56, {
          stroke: 'red', lineWidth: 5, lineCap: 'round'
        } ) );
        scene.addChild( new scenery.Line( 8, 56, 56, 8, {
          stroke: 'blue', lineWidth: 5, lineCap: 'round'
        } ) );
        /*END*/
      } );
    </script>

    <h4 id="line-x1">x1</h4>

    <p>
      <code>node.x1</code> (<code>node.getX1()</code>, <code>node.setX1( x1 )</code>)
      retrieves or modifies the 'x1' parameter of the <a href="#line">Line</a>.
    </p>
    <h4 id="line-y1">y1</h4>

    <p>
      <code>node.y1</code> (<code>node.getY1()</code>, <code>node.setY1( y1 )</code>)
      retrieves or modifies the 'y1' parameter of the <a href="#line">Line</a>.
    </p>
    <h4 id="line-x2">x2</h4>

    <p>
      <code>node.x2</code> (<code>node.getX2()</code>, <code>node.setX2( x2 )</code>)
      retrieves or modifies the 'x2' parameter of the <a href="#line">Line</a>.
    </p>
    <h4 id="line-y2">y2</h4>

    <p>
      <code>node.y2</code> (<code>node.getY2()</code>, <code>node.setY2( y2 )</code>)
      retrieves or modifies the 'y2' parameter of the <a href="#line">Line</a>.
    </p>
    <h4 id="line-p1">p1</h4>

    <p>
      <code>node.p1</code> (<code>node.getPoint1()</code>, <code>node.setPoint1( p1 )</code>)
      retrieves or modifies the Vector2 (x1,y1) of the <a href="#line">Line</a>.
    </p>
    <h4 id="line-p2">p2</h4>

    <p>
      <code>node.p2</code> (<code>node.getPoint2()</code>, <code>node.setPoint2( p2 )</code>)
      retrieves or modifies the Vector2 (x2,y2) of the <a href="#line">Line</a>.
    </p>

    <h3 id="font" class="section">Font</h3>

    <p>
      Font represents a single <strong>immutable</strong>font, which can be queried for various parameters, and can be changed.
    </p>

    <p>
      It can be constructed with <code>new scenery.Font()</code> initialized with the default font '10px sans-serif',
      <code>scenery.Font.fromCSS( cssFontString )</code> initialized with the specified <a href="http://www.w3.org/TR/css3-fonts/">CSS Font</a>,
      or with a property object <code>new scenery.Font( { ... } )</code>, where any of the Font's properties
      (<a href="#font-font">font</a>, <a href="#font-family">family</a>, <a href="#font-weight">weight</a>, <a href="#font-stretch">stretch</a>, <a
        href="#font-style">style</a>, <a href="#font-size">size</a>, and <a href="#font-lineHeight">lineHeight</a>)
      can be present.
    </p>

    <p>
      For example, <code>new scenery.Font( { size: 16, style: 'italic' } )</code> and <code>scenery.Font.fromCSS( 'italic 16px sans-serif' )</code>
      are equivalent ways of creating that specific Font instance. In addition:
    </p>
      <pre class="brush: js">
new scenery.Font().font                      // "10px sans-serif" (the default)
new scenery.Font( { family: 'serif' } ).font // "10px serif"
new scenery.Font( { weight: 'bold' } ).font  // "bold 10px sans-serif"
new scenery.Font( { size: 16 } ).font        // "16px sans-serif"
var font = new scenery.Font( {
  family: '"Times New Roman", serif',
  style: 'italic',
  lineHeight: 10
} );
font.font;                                   // "italic 10px/10 'Times New Roman', serif"
font.family;                                 // "'Times New Roman', serif"
font.weight;                                 // 400 (the default)
      </pre>

    <h4 id="font-font">font</h4>

    <p>
      <code>font.font</code> (<code>font.getFont()</code>)
      retrieves the <a href="http://www.w3.org/TR/css3-fonts/#propdef-font">shorthand CSS 'font' property</a> of the Font object.
      This property completely specifies all font settings.
    </p>

    <h4 id="font-family">family</h4>

    <p>
      <code>font.family</code> (<code>font.getFamily()</code>)
      retrieves the <a href="http://www.w3.org/TR/css3-fonts/#propdef-font-family">CSS 'font-family' property</a> of the Font object.
    </p>

    <h4 id="font-weight">weight</h4>

    <p>
      <code>font.weight</code> (<code>font.getWeight()</code>)
      retrieves the <a href="http://www.w3.org/TR/css3-fonts/#propdef-font-weight">CSS 'font-weight' property</a> of the Font object.
    </p>

    <h4 id="font-stretch">stretch</h4>

    <p>
      <code>font.stretch</code> (<code>font.getStretch()</code>)
      retrieves the <a href="http://www.w3.org/TR/css3-fonts/#propdef-font-stretch">CSS 'font-stretch' property</a> of the Font object.
    </p>

    <h4 id="font-style">style</h4>

    <p>
      <code>font.style</code> (<code>font.getStyle()</code>)
      retrieves the <a href="http://www.w3.org/TR/css3-fonts/#propdef-font-style">CSS 'font-style' property</a> of the Font object.
    </p>

    <h4 id="font-size">size</h4>

    <p>
      <code>font.size</code> (<code>font.getSize()</code>)
      retrieves the <a href="http://www.w3.org/TR/css3-fonts/#propdef-font-size">CSS 'font-size' property</a> of the Font object.
    </p>

    <h4 id="font-lineHeight">lineHeight</h4>

    <p>
      <strong>Deprecated</strong>: <code>font.lineHeight</code> (<code>font.getLineHeight()</code>)
      retrieves the <a href="http://www.w3.org/TR/CSS21/visudet.html#propdef-line-height">CSS 'line-height' property</a> of the Font object.
    </p>


    <h3 id="color" class="section">Color</h3>

    <p>
      A Color can be constructed either with any valid CSS color (<code>new scenery.Color( cssColorString )</code>), or with components directly
      (<code>new scenery.Color( red, green blue [, alpha] )</code>) where red/green/blue are 0-255, and alpha is 0-1.
    </p>

    <p>Color operations will assume that the color is not pre-multiplied.</p>

    <h4 id="color-red">red</h4>

    <p>
      <code>color.red</code> (<code>color.getRed()</code>, <code>color.setRed( redInt )</code>)
      retrieves or modifies the red component of the color. It will be returned or converted to an integral value between 0-255 (inclusive).
    </p>

    <h4 id="color-green">green</h4>

    <p>
      <code>color.green</code> (<code>color.getGreen()</code>, <code>color.setGreen( greenInt )</code>)
      retrieves or modifies the green component of the color. It will be returned or converted to an integral value between 0-255 (inclusive).
    </p>

    <h4 id="color-blue">blue</h4>

    <p>
      <code>color.blue</code> (<code>color.getBlue()</code>, <code>color.setBlue( blueInt )</code>)
      retrieves or modifies the blue component of the color. It will be returned or converted to an integral value between 0-255 (inclusive).
    </p>

    <h4 id="color-alpha">alpha</h4>

    <p>
      <code>color.alpha</code> (<code>color.getAlpha()</code>, <code>color.setAlpha( alphaFloat )</code>)
      retrieves or modifies the alpha component of the color. It will be returned or converted to an integral value between 0-1 (inclusive).
    </p>

    <h4 id="color-toCSS">toCSS()</h4>

    <p>
      Returns a CSS value for the color, currently using 'rgb' or 'rgba'.
    </p>


    <h3 id="event" class="section">Event</h3>

    <h3 id="pointer" class="section">Pointer</h3>

    <h3 id="mouse" class="section">Mouse</h3>

    <h3 id="touch" class="section">Touch</h3>

    <h3 id="pen" class="section">Pen</h3>

    <h3 id="trail" class="section">Trail</h3>

  </div>
  <div class="span3"></div>
</div>

<footer style="background-color: #191919;">
  <a class="brand" href="/scenery">Scenery</a>
</footer>

<script type="text/javascript">
  SyntaxHighlighter.all();
</script>
</body>
</html>
