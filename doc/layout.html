<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">


  <title>Scenery Layout</title>

  <link rel="shortcut icon" type="image/x-icon" href="../assets/logo-v1.svg">
  <link rel="stylesheet" href="../../sherpa/lib/bootstrap-2.2.2.css">
  <link rel="stylesheet" href="../../sherpa/lib/bootstrap-responsive-2.2.2.css">
  <link rel="stylesheet" href="../../sherpa/lib/syntaxhighlighter-3.0.83/shCore.css">
  <link rel="stylesheet" href="../../sherpa/lib/syntaxhighlighter-3.0.83/shThemeDefault.css">
  <link rel="stylesheet" href="../assets/scenery.css">

  <!-- Before loading other things (that might error), create hooks to report errors/loads for continuous testing -->
  <script src="../../chipper/js/sim-tests/pageload-connector.js"></script>

  <!-- jQuery and LoDash are dependencies -->
  <script src="../../sherpa/lib/jquery-2.1.0.min.js"></script>
  <script src="../../sherpa/lib/lodash-4.17.4.min.js"></script>

  <!-- For the styling -->
  <script src="../../sherpa/lib/bootstrap-2.2.2.js"></script>

  <link rel="stylesheet" href="../../sherpa/lib/highlightjs-11.5.1-a11y-light.min.css">
  <script src="../../sherpa/lib/highlightjs-11.5.1.min.js"></script>
  <script src="./doc.js"></script>
  <link rel="stylesheet" href="./doc.css">

  <style>

  </style>

  <!-- Our code, in either the concatenated 'with comments' version or the minified version -->
  <script src="../dist/scenery.min.js"></script>

  <script type="text/javascript">
    scenery.Utils.polyfillRequestAnimationFrame();

    function dynamicDemo( id, getBox, options ) {
      options = phetCore.merge( {
        resize: 'both',
        useMinWidth: true,
        useMinHeight: false,
        adjustDisplay: false,
        step: null
      }, options );

      const container = document.getElementById( id );
      const scene = new scenery.Node();
      const box = getBox();
      scene.addChild( box );
      const display = new scenery.Display( scene, {
        allowCSSHacks: false,

        // so Display input does not interfere with documentation links
        listenToOnlyElement: true
      } );
      display.domElement.classList.add( 'exampleScene' );
      display.domElement.style.position = 'relative';
      display.domElement.style.resize = options.resize;

      // Initials
      display.width = Math.ceil( scene.right );
      display.height = Math.ceil( scene.bottom );
      display.domElement.style.width = display.width + 'px';
      display.domElement.style.height = display.height + 'px';
      if ( options.useMinWidth ) {
        display.domElement.style.minWidth = display.width + 'px';
      }
      if ( options.useMinHeight ) {
        display.domElement.style.minHeight = display.height + 'px';
      }

      display.updateOnRequestAnimationFrame( dt => {
        options.step && options.step( dt );

        if ( options.adjustDisplay ) {
          display.width = Math.ceil( scene.right );
          display.height = Math.ceil( scene.bottom );
          display.domElement.style.width = display.width + 'px';
          display.domElement.style.height = display.height + 'px';
        }
        else {
          if ( display.domElement.clientWidth ) {
            display.width = display.domElement.clientWidth;
            box.preferredWidth = display.domElement.clientWidth;
          }
          if ( display.domElement.clientHeight ) {
            display.height = display.domElement.clientHeight;
            box.preferredHeight = display.domElement.clientHeight;
          }
        }
      } );

      container.appendChild( display.domElement );
      container.appendChild( getCodeSnippet( getBox ) );
    }

    const colors = [
      new scenery.Color( 62, 171, 3 ),
      new scenery.Color( 23, 180, 77 ),
      new scenery.Color( 24, 183, 138 ),
      new scenery.Color( 23, 178, 194 ),
      new scenery.Color( 20, 163, 238 ),
      new scenery.Color( 71, 136, 255 ),
      new scenery.Color( 171, 101, 255 ),
      new scenery.Color( 228, 72, 235 ),
      new scenery.Color( 252, 66, 186 ),
      new scenery.Color( 252, 82, 127 )
    ];
  </script>
</head>

<body>
<div class="navbar navbar-inverse navbar-static-top">
  <div class="navbar-inner">
    <a class="brand" href="/scenery">Scenery</a>
    <ul class="nav">
      <li><a href="../">Home</a></li>
      <li class="active"><a href="../doc">Documentation</a></li>
      <li><a href="../examples">Examples</a></li>
      <li><a href="../tests">Tests</a></li>
    </ul>
  </div>
</div>

<div class="row-fluid">
  <div class="span2"></div>
  <div class="span8">
    <div class="page-header" style="text-align: center;">
      <h1>Scenery Layout</h1>
    </div>
  </div>
  <div class="span2"></div>
</div>

<div class="row-fluid">
  <div class="span2" id="apiList">
    <!-- the apiList will be filled in by JS -->
  </div>
  <div class="span8">

    <p>
      If you have the main PhET libraries checked out (sun, etc.), there are a
      <a href="../../sun/sun_en.html?brand=phet&ea&debugger&screens=4">number of examples</a> that show layout in action with
      common components.
    </p>

    <p>NOTE: Many examples can be resized from the lower-right corner. This adjusts the preferred size of the container.</p>

    <h2 id="FlowBox" class="index">FlowBox</h2>

    <h3 id="FlowBox-orientation" class="index">orientation</h3>

    <p class="index" data-index="HBox">
      For horizontal line-based layout, use <code>HBox</code>:
    </p>

    <div id="HBox-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'HBox-example', () => {
        /*START*/
        return new scenery.HBox( {
          children: [
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
            new scenery.Circle( 25, { fill: colors[ 6 ] } ),
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 8 ] } )
          ]
        } );
        /*END*/
      }, { resize: 'horizontal' } );
    </script>

    <p class="index" data-index="VBox">
      For vertical line-based layout, use <code>VBox</code>:
    </p>

    <div id="VBox-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'VBox-example', () => {
        /*START*/
        return new scenery.VBox( {
          children: [
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
            new scenery.Circle( 25, { fill: colors[ 6 ] } ),
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 8 ] } )
          ]
        } );
        /*END*/
      }, { resize: 'vertical', useMinHeight: true } );
    </script>

    <p>
      NOTE: For FlowBox, the orientation provided is typically called the <em>primary</em> orientation. This is the
      orientation along which each Node in a line is positioned. The <em>secondary</em> orientation is the opposite one,
      along which each Node is aligned. e.g. for an HBox, its primary orientation is horizontal, and its secondary
      orientation is vertical (so its elements will be positioned with increasing x values, and its <code>align</code> will control
      the y values).
    </p>

    <p>For cases where the orientation needs to be determined programmatically, use FlowBox:</p>

    <div id="orientation-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'orientation-example', () => {
        /*START*/
        return new scenery.FlowBox( {
          orientation: phetCore.Orientation.horizontal,
          children: [
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
            new scenery.Circle( 25, { fill: colors[ 6 ] } ),
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 8 ] } )
          ]
        } );
        /*END*/
      }, { resize: 'horizontal' } );
    </script>

    <h3 id="FlowBox-resizing">Resizing</h3>

    <p>The box adjusts to changing cell sizes:</p>

    <div id="dynamic-example"></div>
    <script type="text/javascript">
      {
        let step;
        dynamicDemo( 'dynamic-example', () => {
          /*START*/
          const circle = new scenery.Circle( 25, { fill: colors[ 6 ] } );
          let time = 0;
          step = dt => {
            time += dt;
            circle.radius = 25 + 10 * Math.sin( 4 * time );
          };
          const box = new scenery.HBox( {
            children: [
              new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
              new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
              circle,
              new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 8 ] } )
            ]
          } );
          /*END*/
          const foreground = new scenery.Rectangle( {
            stroke: 'black',
            lineWidth: 2
          } );
          box.boundsProperty.link( bounds => {
            foreground.rectBounds = bounds;
          } );
          const visualNode = new scenery.Node( {
            children: [ box, foreground ]
          } );
          const alignBox = new scenery.AlignBox( visualNode, {
            alignBounds: new dot.Bounds2( 0, 0, 230, 80 ),
            xAlign: 'left',
            yAlign: 'top',
            margin: 5
          } );
          return alignBox;
        }, { resize: 'none', useMinWidth: false, adjustDisplay: true, step: dt => step( dt ) } );
      }
    </script>

    <p id="FlowBox-resize" class="index" data-index="resize">Resizing/layout can be disabled with <code>resize: false</code>:</p>

    <div id="locked-sizing-example"></div>
    <script type="text/javascript">
      {
        let circle;
        let step;
        dynamicDemo( 'locked-sizing-example', () => {
          /*START*/
          circle = new scenery.Circle( 25, { fill: colors[ 6 ] } );
          let time = 0;
          step = dt => {
            time += dt;
            circle.radius = 25 + 10 * Math.sin( 4 * time );
          };
          return new scenery.HBox( {
            resize: false,
            children: [
              new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
              new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
              circle,
              new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 8 ] } )
            ]
          } );
          /*END*/
        }, { resize: 'none', useMinWidth: false, adjustDisplay: true, step: dt => step( dt ) } );
      }
    </script>

    <h3>Invisible children</h3>

    <p>Invisible nodes are not included in layout/bounds by default:</p>

    <div id="invis-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'invis-example', () => {
        /*START*/
        return new scenery.HBox( {
          children: [
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ], visible: false } ),
            new scenery.Circle( 25, { fill: colors[ 6 ] } ),
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 8 ] } )
          ]
        } );
        /*END*/
      }, { resize: 'horizontal' } );
    </script>

    <p id="FlowBox-excludeInvisibleChildrenFromBounds">Invisible nodes can be forced into the layout:</p>

    <div id="force-vis-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'force-vis-example', () => {
        /*START*/
        return new scenery.HBox( {
          excludeInvisibleChildrenFromBounds: false,
          children: [
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ], visible: false } ),
            new scenery.Circle( 25, { fill: colors[ 6 ] } ),
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 8 ] } )
          ]
        } );
        /*END*/
      }, { resize: 'horizontal' } );
    </script>

    <h3 id="FlowBox-grow" class="index">grow</h3>

    <p>Nodes with preferred sizes can be added, and the <code>grow</code> in <code>layoutOptions</code> will attempt to put extra space into that
      cell. If all nodes have the same <code>grow</code>, then all nodes will receive the same share of the extra space.
      Otherwise, extra space is distributed proportionally as defined by each node's <code>grow</code> value.</p>

    <div id="resizable-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'resizable-example', () => {
        /*START*/
        return new scenery.HBox( {
          children: [
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
            new scenery.Rectangle( {
              sizable: true,
              localMinimumWidth: 50,
              localMinimumHeight: 50,
              fill: 'gray',
              layoutOptions: { grow: 1 }
            } ),
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
            new scenery.Circle( 25, { fill: colors[ 6 ] } ),
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 8 ] } )
          ]
        } );
        /*END*/
      }, { resize: 'horizontal' } );
    </script>

    <p>Extra space can be allocated proportionally (a node with 4 times the <code>grow</code> value will grow 4 times as fast):</p>

    <div id="grow-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'grow-example', () => {
        /*START*/
        return new scenery.HBox( {
          children: [
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
            new scenery.Rectangle( {
              sizable: true,
              localMinimumWidth: 50,
              localMinimumHeight: 50,
              fill: 'gray',
              layoutOptions: { grow: 1 }
            } ),
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
            new scenery.Rectangle( {
              sizable: true,
              localMinimumWidth: 50,
              localMinimumHeight: 50,
              fill: 'gray',
              layoutOptions: { grow: 4 }
            } ),
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 8 ] } )
          ]
        } );
        /*END*/
      }, { resize: 'horizontal' } );
    </script>

    <h3>Constraining dimensions</h3>

    <p id="FlowBox-maxContent" class="index" data-index="maxContent">Maximums can be applied to constrain this growing (it won't grow past the max content dimension):</p>

    <div id="maxContentWidth-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'maxContentWidth-example', () => {
        /*START*/
        return new scenery.HBox( {
          children: [
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
            new scenery.Rectangle( {
              sizable: true,
              localMinimumWidth: 50,
              localMinimumHeight: 50,
              fill: 'gray',
              layoutOptions: { grow: 1, maxContentWidth: 150 }
            } ),
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
            new scenery.Circle( 25, { fill: colors[ 6 ] } ),
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 8 ] } )
          ]
        } );
        /*END*/
      }, { resize: 'horizontal' } );
    </script>

    <p id="FlowBox-minContent" class="index" data-index="minContent">Minimums can also force a certain expansion:</p>

    <div id="minContentWidth-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'minContentWidth-example', () => {
        /*START*/
        return new scenery.HBox( {
          children: [
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
            new scenery.Rectangle( {
              sizable: true,
              localMinimumWidth: 50,
              localMinimumHeight: 50,
              fill: 'gray',
              layoutOptions: { grow: 1, minContentWidth: 100 }
            } ),
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
            new scenery.Circle( 25, { fill: colors[ 6 ] } ),
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 8 ] } )
          ]
        } );
        /*END*/
      }, { resize: 'horizontal' } );
    </script>

    <p>Minimums and maximums also apply on the secondary axis:</p>

    <div id="secondaryAxisContent-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'secondaryAxisContent-example', () => {
        /*START*/
        return new scenery.HBox( {
          children: [
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
            new scenery.Rectangle( {
              sizable: true,
              localMinimumWidth: 50,
              localMinimumHeight: 50,
              fill: 'gray',
              layoutOptions: {
                grow: 1,
                minContentWidth: 50,
                minContentHeight: 50,
                maxContentHeight: 100,
                stretch: true
              }
            } ),
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
            new scenery.Circle( 25, { fill: colors[ 6 ] } ),
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 8 ] } )
          ]
        } );
        /*END*/
      }, { resize: 'both', useMinHeight: true } );
    </script>

    <h3 id="FlowBox-justify" class="index">justify</h3>

    <p><code>justify</code> controls how extra space is allocated around cells (after any possible growing has been done):</p>

    <div id="justification-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'justification-example', () => {
        const createBoxes = label => [
          new scenery.Rectangle( 0, 0, 170, 30, { fill: colors[ 2 ], children: [
            new scenery.Text( label, { fontSize: 16, centerY: 15 } )
          ] } ),
          new scenery.Rectangle( 0, 0, 50, 30, { fill: colors[ 4 ] } ),
          new scenery.Circle( 15, { fill: colors[ 6 ] } ),
          new scenery.Rectangle( 0, 0, 50, 30, { fill: colors[ 8 ] } )
        ];
        /*START*/
        const boxes = [
          new scenery.HBox( {
            justify: 'left',
            children: createBoxes( 'justify:left' )
          } ),
          new scenery.HBox( {
            justify: 'right',
            children: createBoxes( 'justify:right' )
          } ),
          new scenery.HBox( {
            justify: 'spaceBetween',
            children: createBoxes( 'justify:spaceBetween' )
          } ),
          new scenery.HBox( {
            justify: 'spaceAround',
            children: createBoxes( 'justify:spaceAround' )
          } ),
          new scenery.HBox( {
            justify: 'spaceEvenly',
            children: createBoxes( 'justify:spaceEvenly' )
          } ),
          new scenery.HBox( {
            justify: 'center',
            children: createBoxes( 'justify:center' )
          } )
        ];
        /*END*/
        const container = new scenery.VBox( {
          justify: 'top',
          children: boxes
        } );
        container.preferredWidthProperty.link( preferredWidth => boxes.forEach( box => {
          box.preferredWidth = preferredWidth;
        } ) );
        return container;
      }, { resize: 'horizontal' } );
    </script>

    <h3 id="FlowBox-wrap" class="index">wrap</h3>

    <p><code>wrap</code> will shift content that doesn't fit the preferred size into new rows/columns (try resizing it to be less wide):</p>

    <div id="wrap-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'wrap-example', () => {
        /*START*/
        return new scenery.HBox( {
          wrap: true,
          justify: 'left',
          justifyLines: 'top',
          children: [
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
            new scenery.Circle( 25, { fill: colors[ 6 ] } ),
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 8 ] } )
          ]
        } );
        /*END*/
      }, { resize: 'both', useMinWidth: false } );
    </script>

    <h3 id="FlowBox-align" class="index">align</h3>

    <p><code>align</code> controls how cells are positioned in the secondary orientation:</p>

    <div id="align-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'align-example', () => {
        /*START*/
        const boxes = [
          'top',
          'bottom',
          'center',
          'origin'
        ].map( align => {
          return new scenery.HBox( {
            children: [
              new scenery.Rectangle( 0, 0, 50, 15, { fill: colors[ 9 ] } ),
              new scenery.Rectangle( 0, 0, 50, 20, { fill: colors[ 6 ] } ),
              new scenery.Rectangle( 0, 0, 50, 5, { fill: colors[ 4 ] } ),
              new scenery.Rectangle( 0, 0, 50, 15, { fill: colors[ 2 ] } ),
              new scenery.Circle( 7, { fill: colors[ 0 ] } ),
              new scenery.Text( `Alignment: ${align}` )
            ],
            justify: 'left',
            align: align
          } );
        } );
        /*END*/
        return new scenery.VBox( {
          children: boxes,
          spacing: 10,
          align: 'left'
        } );
      }, { resize: 'none', useMinWidth: false } );
    </script>

    <p>
      For horizontal boxes, the values are: <code>'left', 'right', 'center', 'origin'</code>. For vertical boxes, the values are:
      <code>'top', 'bottom', 'center', 'origin'</code>. See
      <a href="https://github.com/phetsims/scenery/blob/master/js/layout/LayoutAlign.ts">LayoutAlign</a> for more details
    </p>

    <h3 id="FlowBox-justifyLines" class="index">justifyLines</h3>

    <p><code>justifyLines</code> controls how lines are positioned in the secondary orientation (null will default to a stretch):</p>

    <div id="justifyLines-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'justifyLines-example', () => {
        /*START*/
        const boxes = [
          'top',
          'bottom',
          'center',
          'spaceBetween',
          'spaceAround',
          'spaceEvenly',
          null
        ].map( justifyLines => {
          const createResizable = () => {
            const node = new scenery.Rectangle( {
              sizable: true,
              localMinimumWidth: 20,
              localMinimumHeight: 20,
              fill: 'gray'
            } );
            return node;
          };
          return new scenery.HBox( {
            preferredWidth: 40,
            widthSizable: false,
            wrap: true,
            stretch: true,
            children: [
              new scenery.Rectangle( 0, 0, 20, 20, { fill: colors[ 2 ] } ),
              createResizable(),
              new scenery.Rectangle( 0, 0, 20, 20, { fill: colors[ 4 ] } ),
              createResizable(),
              new scenery.Rectangle( 0, 0, 20, 20, { fill: colors[ 6 ] } ),
              createResizable(),
              new scenery.Rectangle( 0, 0, 20, 20, { fill: colors[ 8 ] } ),
              createResizable()
            ],
            justifyLines: justifyLines
          } );
        } );
        /*END*/
        const container = new scenery.HBox( {
          justify: 'left',
          stretch: true,
          children: boxes
        } );
        // container.preferredHeightProperty.link( preferredHeight => boxes.forEach( box => {
        //   box.preferredHeight = preferredHeight;
        // } ) );
        return container;
      }, { resize: 'vertical', useMinHeight: true } );
    </script>

    <h3 id="FlowBox-spacing" class="index">spacing</h3>

    <p><code>spacing</code> controls extra space that can be added between cells:</p>

    <div id="spacing-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'spacing-example', () => {
        /*START*/
        return new scenery.HBox( {
          spacing: 10,
          children: [
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
            new scenery.Circle( 25, { fill: colors[ 6 ] } ),
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 8 ] } )
          ]
        } );
        /*END*/
      }, { resize: 'horizontal' } );
    </script>

    <h3 id="FlowBox-lineSpacing" class="index">lineSpacing</h3>

    <p><code>lineSpacing</code> adds space between rows/columns, which applies when wrapped:</p>

    <div id="lineSpacing-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'lineSpacing-example', () => {
        /*START*/
        return new scenery.HBox( {
          lineSpacing: 10,
          wrap: true,
          children: [
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
            new scenery.Circle( 25, { fill: colors[ 6 ] } ),
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 8 ] } )
          ]
        } );
        /*END*/
      }, { resize: 'both', useMinWidth: false } );
    </script>

    <h3 id="FlowBox-margins" class="index">Margins</h3>

    <p>Margins can also be added to every cell (<code>margin</code> affects all 4 sides, <code>xMargin</code> affects left/right, <code>yMargin</code> affects top/bottom):</p>

    <div id="margin-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'margin-example', () => {
        /*START*/
        return new scenery.HBox( {
          leftMargin: 10,
          yMargin: 10, // controls topMargin and bottomMargin
          children: [
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
            new scenery.Circle( 25, { fill: colors[ 6 ] } ),
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 8 ] } )
          ]
        } );
        /*END*/
      }, { resize: 'horizontal' } );
    </script>

    <h3>Per-cell layout options</h3>

    <p>Margins can also be applied to individual cells:</p>

    <div id="marginCell-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'marginCell-example', () => {
        /*START*/
        return new scenery.HBox( {
          align: 'top',
          children: [
            new scenery.Rectangle( 0, 0, 50, 50, {
              fill: colors[ 2 ],
              layoutOptions: { topMargin: 10 }
            } ),
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
            new scenery.Circle( 25, { fill: colors[ 6 ] } ),
            new scenery.Rectangle( 0, 0, 50, 50, {
              fill: colors[ 8 ],
              layoutOptions: { leftMargin: 10 }
            } )
          ]
        } );
        /*END*/
      }, { resize: 'horizontal' } );
    </script>

    <p>Similarly, alignment can also be customized by individual cells:</p>

    <div id="alignCell-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'alignCell-example', () => {
        /*START*/
        return new scenery.HBox( {
          children: [
            new scenery.Rectangle( 0, 0, 50, 100, {
              fill: colors[ 2 ]
            } ),
            new scenery.Rectangle( 0, 0, 50, 50, {
              fill: colors[ 4 ],
              layoutOptions: { align: 'top' }
            } ),
            new scenery.Circle( 25, {
              fill: colors[ 6 ],
              layoutOptions: { align: 'bottom' }
            } ),
            new scenery.Rectangle( 0, 0, 50, 50, {
              fill: colors[ 8 ],
              layoutOptions: { align: 'center' }
            } )
          ]
        } );
        /*END*/
      }, { resize: 'horizontal' } );
    </script>

    <p>These options use the default on the container, but can be overridden by cells:</p>

    <div id="override-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'override-example', () => {
        /*START*/
        return new scenery.HBox( {
          topMargin: 10,
          align: 'top',
          children: [
            new scenery.Rectangle( 0, 0, 50, 50, {
              fill: colors[ 2 ],
              layoutOptions: { topMargin: 0 }
            } ),
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
            new scenery.Circle( 25, { fill: colors[ 6 ] } ),
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 8 ] } )
          ]
        } );
        /*END*/
      }, { resize: 'horizontal' } );
    </script>

    <h3 id="FlowBox-stretch" class="index">stretch</h3>

    <p><code>stretch</code> will have a resizable element take up the entire row/column size:</p>

    <div id="stretch-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'stretch-example', () => {
        /*START*/
        return new scenery.HBox( {
          children: [
            new scenery.Rectangle( 0, 0, 50, 100, {
              fill: colors[ 2 ]
            } ),
            new scenery.Rectangle( 0, 0, 50, 50, {
              fill: colors[ 4 ],
              layoutOptions: { align: 'top' }
            } ),
            new scenery.Rectangle( {
              sizable: true,
              localMinimumWidth: 50,
              localMinimumHeight: 50,
              fill: 'gray',
              layoutOptions: { stretch: true }
            } ),
            new scenery.Circle( 25, {
              fill: colors[ 6 ],
              layoutOptions: { align: 'bottom' }
            } ),
            new scenery.Rectangle( 0, 0, 50, 50, {
              fill: colors[ 8 ],
              layoutOptions: { align: 'center' }
            } )
          ]
        } );
        /*END*/
      }, { resize: 'both', useMinHeight: true } );
    </script>

    <h3 class="index">Separators</h3>

    <p>Separators are also available for easy of use (separators at the visible start/end, and duplicates will be marked as
      <code>visible: false</code>, while all other separators will be marked as <code>visible: true</code>):</p>

    <div id="separators-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'separators-example', () => {
        /*START*/
        return new scenery.HBox( {
          margin: 5,
          children: [
            new scenery.VSeparator(),
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
            new scenery.VSeparator(),
            new scenery.VSeparator(),
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
            new scenery.Circle( 25, { fill: colors[ 6 ] } ),
            new scenery.VSeparator(),
            new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 8 ] } ),
            new scenery.VSeparator()
          ]
        } );
        /*END*/
      }, { resize: 'horizontal' } );
    </script>

    <h2 id="GridBox" class="index">GridBox</h2>

    <h3 id="GridBox-layoutOptions-location" class="index" data-index="Coordinates">Cell coordinates</h3>

    <p>Can be constructed with absolute coordinates (which can include gaps):</p>

    <div id="absolute-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'absolute-example', () => {
        /*START*/
        return new scenery.GridBox( {
          children: [
            new scenery.Rectangle( 0, 0, 75, 50, {
              fill: colors[ 0 ],
              layoutOptions: { column: 0, row: 0 }
            } ),
            new scenery.Rectangle( 0, 0, 50, 75, {
              fill: colors[ 2 ],
              layoutOptions: { column: 1, row: 0 }
            } ),
            new scenery.Circle( 25, {
              fill: colors[ 4 ],
              layoutOptions: { column: 2, row: 0 }
            } ),
            new scenery.Rectangle( 0, 0, 50, 50, {
              fill: colors[ 6 ],
              layoutOptions: { column: 0, row: 1 }
            } ),
            new scenery.Rectangle( 0, 0, 50, 50, {
              fill: colors[ 8 ],
              layoutOptions: { column: 1, row: 2 }
            } )
          ]
        } );
        /*END*/
      }, { resize: 'none', useMinHeight: true } );
    </script>

    <p>
      The <strong>x</strong> value indicates the column (starting at index 0), and the <strong>y</strong> value
      indicates the row (starting at index 0).
    </p>

    <p>
      NOTE: Skipped rows/columns will be collapsed and won't apply (except for any spacing added):
    </p>

    <div id="skip-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'skip-example', () => {
        /*START*/
        return new scenery.GridBox( {
          children: [
            new scenery.Rectangle( 0, 0, 75, 50, {
              fill: colors[ 0 ],
              layoutOptions: { column: 0, row: 0 }
            } ),
            new scenery.Rectangle( 0, 0, 50, 75, {
              fill: colors[ 2 ],
              layoutOptions: { column: 50, row: 0 }
            } ),
            new scenery.Circle( 25, {
              fill: colors[ 4 ],
              layoutOptions: { column: 25, row: 102 }
            } )
          ]
        } );
        /*END*/
      }, { resize: 'none', useMinHeight: true } );
    </script>

    <h3 id="GridBox-rows" class="index">rows</h3>

    <p>Grids can be constructed by specifying all the children in rows (<code>null</code> for gaps):</p>

    <div id="rows-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'rows-example', () => {
        /*START*/
        return new scenery.GridBox( {
          rows: [
            [
              new scenery.Rectangle( 0, 0, 75, 50, {
                fill: colors[ 0 ]
              } ),
              new scenery.Rectangle( 0, 0, 50, 75, {
                fill: colors[ 2 ]
              } ),
              new scenery.Circle( 25, {
                fill: colors[ 4 ]
              } )
            ],
            [
              new scenery.Rectangle( 0, 0, 50, 50, {
                fill: colors[ 6 ]
              } ),
              null,
              new scenery.Rectangle( 0, 0, 50, 50, {
                fill: colors[ 8 ]
              } )
            ]
          ]
        } );
        /*END*/
      }, { resize: 'none', useMinHeight: true } );
    </script>

    <h3 id="GridBox-columns" class="index">columns</h3>

    <p>or with columns:</p>

    <div id="columns-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'columns-example', () => {
        /*START*/
        return new scenery.GridBox( {
          columns: [
            [
              new scenery.Rectangle( 0, 0, 75, 50, {
                fill: colors[ 0 ]
              } ),
              new scenery.Rectangle( 0, 0, 50, 75, {
                fill: colors[ 2 ]
              } ),
              new scenery.Circle( 25, {
                fill: colors[ 4 ]
              } )
            ],
            [
              new scenery.Rectangle( 0, 0, 50, 50, {
                fill: colors[ 6 ]
              } ),
              null,
              new scenery.Rectangle( 0, 0, 50, 50, {
                fill: colors[ 8 ]
              } )
            ]
          ]
        } );
        /*END*/
      }, { resize: 'none', useMinHeight: true } );
    </script>

    <h3 id="GridBox-autoLines" class="index" data-index="auto">autoRows/autoColumn</h3>

    <p>
      Additionally, if a certain number of rows/columns are desired, <code>autoRows</code> / <code>autoColumns</code> can be used to wrap and
      position the children based on this (auto-filling all spaces)
    </p>

    <div id="autoColumns-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'autoColumns-example', () => {
        /*START*/
        return new scenery.GridBox( {
          autoColumns: 3,
          children: colors.map( color => {
            return new scenery.Rectangle( 0, 0, 50, 50, { fill: color } );
          } )
        } );
        /*END*/
      }, { resize: 'none', useMinHeight: true } );
    </script>

    <div id="autoRows-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'autoRows-example', () => {
        /*START*/
        return new scenery.GridBox( {
          autoRows: 3,
          children: colors.map( color => {
            return new scenery.Rectangle( 0, 0, 50, 50, { fill: color } );
          } )
        } );
        /*END*/
      }, { resize: 'none', useMinHeight: true } );
    </script>

    <h3 id="GridBox-addLine" class="index" data-index="adding">addRow/addColumn</h3>

    <p>
      Rows and columns can also be added dynamically in a similar way (rows will be below all current content, columns
      will be to the right of all current content):
    </p>

    <div id="addLines-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'addLines-example', () => {
        /*START*/
        const box = new scenery.GridBox();
        box.addRow( [
          new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
          new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } )
        ] );
        box.addColumn( [
          new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
          new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
          new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } )
        ] );
        /*END*/
        return box;
      }, { resize: 'none', useMinHeight: true } );
    </script>

    <h3 id="GridBox-insertLine">insertRow/insertColumn</h3>

    <p>
      Rows and columns can also be directly inserted by index:
    </p>

    <div id="insertLines-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'insertLines-example', () => {
        /*START*/
        const box = new scenery.GridBox();
        box.insertRow( 0, [
          new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
          new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } )
        ] );
        box.insertColumn( 1, [
          new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
          new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
          new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } )
        ] );
        box.insertRow( 2, [
          new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 6 ] } ),
          new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 6 ] } ),
          new scenery.Rectangle( 0, 0, 50, 50, { fill: colors[ 6 ] } )
        ] );
        /*END*/
        return box;
      }, { resize: 'none', useMinHeight: true } );
    </script>

    <h3 id="GridBox-removeLine" class="index" data-index="removing">removeRow/removeColumn</h3>

    <p>
      Or removed by index:
    </p>

    <div id="deleteLines-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'deleteLines-example', () => {
        /*START*/
        const box = new scenery.GridBox( {
          rows: _.range( 0, 8 ).map( row => {
            return _.range( 0, 8 ).map( column => {
              return new scenery.Rectangle( 0, 0, 20, 20, {
                fill: new scenery.Color( row * 32, column * 32, 1 )
              } );
            } );
          } )
        } );
        box.removeRow( 2 );
        box.removeRow( 2 );
        box.removeColumn( 5 );
        box.removeColumn( 5 );
        /*END*/
        return box;
      }, { resize: 'none', useMinHeight: true } );
    </script>

    <h3 id="GridBox-getters" class="index" data-index="getters">line/cell getters</h3>

    <p>
      Assorted operations can get the row/column of a child Node, or get all of the Nodes contained within a specific
      row or column:
    </p>

    <div id="findCell-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'findCell-example', () => {
        /*START*/
        const boxes = colors.map( color => new scenery.Rectangle( 0, 0, 50, 50, { fill: color } ) );
        const box = new scenery.GridBox( {
          children: boxes,
          autoColumns: 3
        } );
        box.autoColumns = null;

        // Find a node and insert a row before it
        box.insertRow( box.getRowOfNode( boxes[ 4 ] ), [
          new scenery.Rectangle( 0, 0, 50, 50, { fill: 'black' } ),
          new scenery.Rectangle( 0, 0, 50, 50, { fill: 'black' } ),
          new scenery.Rectangle( 0, 0, 50, 50, { fill: 'black' } )
        ] );

        // Find a node and insert a column before it
        box.insertColumn( box.getColumnOfNode( boxes[ 4 ] ), [
          new scenery.Rectangle( 0, 0, 50, 50, { fill: 'black' } ),
          new scenery.Rectangle( 0, 0, 50, 50, { fill: 'black' } ),
          new scenery.Rectangle( 0, 0, 50, 50, { fill: 'black' } ),
          new scenery.Rectangle( 0, 0, 50, 50, { fill: 'black' } ),
          new scenery.Rectangle( 0, 0, 50, 50, { fill: 'black' } )
        ] );
        /*END*/
        return box;
      }, { resize: 'none', useMinHeight: true } );
    </script>

    <div id="getLines-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'getLines-example', () => {
        /*START*/
        const box = new scenery.GridBox( {
          rows: _.range( 0, 8 ).map( row => {
            return _.range( 0, 8 ).map( column => {
              return new scenery.Rectangle( 0, 0, 20, 20, {
                fill: new scenery.Color( row * 32, column * 32, 1 )
              } );
            } );
          } )
        } );
        box.getNodesInRow( 3 ).forEach( node => { node.opacity = 0.5; } );
        box.getNodesInColumn( 3 ).forEach( node => { node.opacity = 0.5; } );
        /*END*/
        return box;
      }, { resize: 'none', useMinHeight: true } );
    </script>

    <h3 id="GridBox-grow" class="index">grow</h3>

    <p>Grids by default don't auto-expand all rows/columns in size to the preferred size, but they can with a similar
      style to FlowBox, where <code>grow</code> applies to both the x and y dimensions:</p>

    <div id="grow-grid-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'grow-grid-example', () => {
        /*START*/
        return new scenery.GridBox( {
          grow: 1,
          rows: [
            [
              new scenery.Rectangle( 0, 0, 75, 50, {
                fill: colors[ 0 ]
              } ),
              new scenery.Rectangle( 0, 0, 50, 75, {
                fill: colors[ 2 ]
              } ),
              new scenery.Circle( 25, {
                fill: colors[ 4 ]
              } ),
            ],
            [
              new scenery.Rectangle( 0, 0, 50, 50, {
                fill: colors[ 6 ]
              } ),
              new scenery.Rectangle( 0, 0, 50, 50, {
                fill: colors[ 8 ]
              } )
            ]
          ]
        } );
        /*END*/
      }, { resize: 'both', useMinHeight: true } );
    </script>

    <p>This space can be grown in specified rows/columns only (and independently) with <code>xGrow</code> or <code>yGrow</code>:</p>

    <div id="grow-2-grid-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'grow-2-grid-example', () => {
        /*START*/
        return new scenery.GridBox( {
          rows: [
            [
              new scenery.Rectangle( 0, 0, 75, 50, {
                fill: colors[ 0 ],
                layoutOptions: { xGrow: 1 }
              } ),
              new scenery.Rectangle( 0, 0, 50, 75, {
                fill: colors[ 2 ]
              } ),
              new scenery.Circle( 25, {
                fill: colors[ 4 ]
              } ),
            ],
            [
              new scenery.Rectangle( 0, 0, 50, 50, {
                fill: colors[ 6 ]
              } ),
              new scenery.Rectangle( 0, 0, 50, 50, {
                fill: colors[ 8 ],
                layoutOptions: { yGrow: 1 }
              } )
            ]
          ]
        } );
        /*END*/
      }, { resize: 'both', useMinHeight: true } );
    </script>

    <h3 id="GridBox-stretch" class="index">stretch</h3>

    <p>Use <code>stretch</code> (or <code>xStretch</code> / <code>yStretch</code>) to grow a cell dynamically with the preferred dimensions to match the row/column:</p>

    <div id="preferred-grid-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'preferred-grid-example', () => {
        /*START*/
        return new scenery.GridBox( {
          rows: [
            [
              new scenery.Rectangle( 0, 0, 50, 50, {
                fill: colors[ 0 ]
              } ),
              new scenery.Rectangle( 0, 0, 50, 50, {
                fill: colors[ 2 ]
              } ),
              new scenery.Circle( 25, {
                fill: colors[ 4 ]
              } )
            ],
            [
              new scenery.Rectangle( 0, 0, 50, 50, {
                fill: colors[ 6 ]
              } ),
              new scenery.Rectangle( {
                sizable: true,
                localMinimumWidth: 50,
                localMinimumHeight: 50,
                fill: 'gray',
                layoutOptions: { grow: 1, stretch: true }
              } ),
              new scenery.Rectangle( 0, 0, 50, 50, {
                fill: colors[ 8 ]
              } )
            ]
          ]
        } );
        /*END*/
      }, { resize: 'both', useMinHeight: true } );
    </script>

    <h3 id="GridBox-sizable" class="index">sizable</h3>

    <p>Additionally, <code>widthSizable</code> / <code>heightSizable</code> can be used to turn off resizing in a
      component (particularly useful if you want to set a preferredWidth/preferredHeight on it that won't change):</p>

    <div id="gridResizable-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'gridResizable-example', () => {
        /*START*/
        return new scenery.GridBox( {
          rows: [
            [
              new scenery.Rectangle( 0, 0, 50, 50, {
                fill: colors[ 0 ]
              } ),
              new scenery.Rectangle( 0, 0, 50, 50, {
                fill: colors[ 2 ]
              } ),
              new scenery.Circle( 25, {
                fill: colors[ 4 ]
              } )
            ],
            [
              new scenery.Rectangle( 0, 0, 50, 50, {
                fill: colors[ 6 ]
              } ),
              new scenery.Rectangle( {
                heightSizable: true,
                localMinimumHeight: 50,
                fill: 'gray',
                preferredWidth: 50,
                widthSizable: false,
                layoutOptions: { grow: 1, stretch: true }
              } ),
              new scenery.Rectangle( 0, 0, 50, 50, {
                fill: colors[ 8 ]
              } )
            ]
          ]
        } );
        /*END*/
      }, { resize: 'both', useMinHeight: true } );
    </script>

    <h3 id="GridBox-align" class="index">align</h3>

    <p>Cells can be aligned in a similar way to FlowBox, but in both dimensions:</p>

    <div id="align-grid-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'align-grid-example', () => {
        /*START*/
        return new scenery.GridBox( {
          grow: 1,
          rows: [
            [
              new scenery.Rectangle( 0, 0, 75, 50, {
                fill: colors[ 0 ],
                layoutOptions: { xAlign: 'left', yAlign: 'top' }
              } ),
              new scenery.Rectangle( 0, 0, 50, 75, {
                fill: colors[ 2 ]
              } ),
              new scenery.Circle( 25, {
                fill: colors[ 4 ],
                layoutOptions: { yAlign: 'bottom' }
              } ),
            ],
            [
              new scenery.Rectangle( 0, 0, 50, 50, {
                fill: colors[ 6 ]
              } ),
              new scenery.Rectangle( 0, 0, 50, 50, {
                fill: colors[ 8 ],
                layoutOptions: { yAlign: 'top' }
              } )
            ]
          ]
        } );
        /*END*/
      }, { resize: 'both', useMinHeight: true } );
    </script>

    <h3 id="GridBox-layoutOptions-size" class="index">width/height</h3>

    <p>Cells can take up more than one row/column with the <code>width</code> / <code>height</code> layout options:</p>

    <div id="span-grid-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'span-grid-example', () => {
        /*START*/
        return new scenery.GridBox( {
          children: [
            new scenery.Rectangle( 0, 0, 50, 50, {
              fill: colors[ 0 ],
              layoutOptions: { column: 0, row: 0 }
            } ),
            new scenery.Rectangle( 0, 0, 100, 50, {
              fill: colors[ 2 ],
              sizable: true,
              localMinimumWidth: 100,
              localMinimumHeight: 50,
              layoutOptions: { column: 1, row: 0, width: 2, stretch: true, grow: 1 }
            } ),
            new scenery.Rectangle( 0, 0, 100, 100, {
              fill: colors[ 4 ],
              sizable: true,
              localMinimumWidth: 100,
              localMinimumHeight: 100,
              layoutOptions: { column: 0, row: 1, width: 2, height: 2, stretch: true }
            } ),
            new scenery.Rectangle( 0, 0, 50, 50, {
              fill: colors[ 6 ],
              layoutOptions: { column: 2, row: 1 }
            } ),
            new scenery.Rectangle( 0, 0, 50, 50, {
              fill: colors[ 8 ],
              layoutOptions: { column: 2, row: 2 }
            } ),
            new scenery.Circle( 25, {
              fill: colors[ 0 ],
              layoutOptions: { column: 0, row: 3 }
            } ),
            new scenery.Circle( 25, {
              fill: colors[ 1 ],
              layoutOptions: { column: 1, row: 3 }
            } ),
            new scenery.Circle( 25, {
              fill: colors[ 2 ],
              layoutOptions: { column: 2, row: 3 }
            } )
          ]
        } );
        /*END*/
      }, { resize: 'both', useMinHeight: true } );
    </script>

    <h3 id="GridBox-spacing" class="index">spacing</h3>

    <p>Grids can have consistent internal spacing:</p>

    <div id="grid-spacing-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'grid-spacing-example', () => {
        /*START*/
        return new scenery.GridBox( {
          spacing: 10,
          children: [
            new scenery.Rectangle( 0, 0, 50, 50, {
              fill: colors[ 0 ],
              layoutOptions: { column: 0, row: 0 }
            } ),
            new scenery.Rectangle( 0, 0, 50, 50, {
              fill: colors[ 2 ],
              layoutOptions: { column: 1, row: 0 }
            } ),
            new scenery.Circle( 25, {
              fill: colors[ 4 ],
              layoutOptions: { column: 2, row: 0 }
            } ),
            new scenery.Rectangle( 0, 0, 50, 50, {
              fill: colors[ 6 ],
              layoutOptions: { column: 0, row: 1 }
            } ),
            new scenery.Rectangle( 0, 0, 50, 50, {
              fill: colors[ 8 ],
              layoutOptions: { column: 1, row: 1 }
            } )
          ]
        } );
        /*END*/
      }, { resize: 'none', useMinHeight: true } );
    </script>

    <p>Grids can have different spacing on each dimension:</p>

    <div id="grid-2-spacing-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'grid-2-spacing-example', () => {
        /*START*/
        return new scenery.GridBox( {
          xSpacing: 5,
          ySpacing: 15,
          children: [
            new scenery.Rectangle( 0, 0, 50, 50, {
              fill: colors[ 0 ],
              layoutOptions: { column: 0, row: 0 }
            } ),
            new scenery.Rectangle( 0, 0, 50, 50, {
              fill: colors[ 2 ],
              layoutOptions: { column: 1, row: 0 }
            } ),
            new scenery.Circle( 25, {
              fill: colors[ 4 ],
              layoutOptions: { column: 2, row: 0 }
            } ),
            new scenery.Rectangle( 0, 0, 50, 50, {
              fill: colors[ 6 ],
              layoutOptions: { column: 0, row: 1 }
            } ),
            new scenery.Rectangle( 0, 0, 50, 50, {
              fill: colors[ 8 ],
              layoutOptions: { column: 1, row: 1 }
            } )
          ]
        } );
        /*END*/
      }, { resize: 'none', useMinHeight: true } );
    </script>

    <p>Grids can have custom arrays adjusting the spacing between every single row/column:</p>

    <div id="grid-3-spacing-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'grid-3-spacing-example', () => {
        /*START*/
        return new scenery.GridBox( {
          xSpacing: [ 10, 0 ],
          ySpacing: [ 5 ],
          children: [
            new scenery.Rectangle( 0, 0, 50, 50, {
              fill: colors[ 0 ],
              layoutOptions: { column: 0, row: 0 }
            } ),
            new scenery.Rectangle( 0, 0, 50, 50, {
              fill: colors[ 2 ],
              layoutOptions: { column: 1, row: 0 }
            } ),
            new scenery.Circle( 25, {
              fill: colors[ 4 ],
              layoutOptions: { column: 2, row: 0 }
            } ),
            new scenery.Rectangle( 0, 0, 50, 50, {
              fill: colors[ 6 ],
              layoutOptions: { column: 0, row: 1 }
            } ),
            new scenery.Rectangle( 0, 0, 50, 50, {
              fill: colors[ 8 ],
              layoutOptions: { column: 1, row: 1 }
            } )
          ]
        } );
        /*END*/
      }, { resize: 'none', useMinHeight: true } );
    </script>

    <h3 id="GridBox-margins" class="index">Margins</h3>

    <p>Similar to FlowBox, grids can have margins applied to all elements:</p>

    <div id="margin-1-spacing-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'margin-1-spacing-example', () => {
        /*START*/
        return new scenery.GridBox( {
          margin: 5,
          children: [
            new scenery.Rectangle( 0, 0, 50, 50, {
              fill: colors[ 0 ],
              layoutOptions: { column: 0, row: 0 }
            } ),
            new scenery.Rectangle( 0, 0, 50, 50, {
              fill: colors[ 2 ],
              layoutOptions: { column: 1, row: 0 }
            } ),
            new scenery.Circle( 25, {
              fill: colors[ 4 ],
              layoutOptions: { column: 2, row: 0 }
            } ),
            new scenery.Rectangle( 0, 0, 50, 50, {
              fill: colors[ 6 ],
              layoutOptions: { column: 0, row: 1 }
            } ),
            new scenery.Rectangle( 0, 0, 50, 50, {
              fill: colors[ 8 ],
              layoutOptions: { column: 1, row: 1 }
            } )
          ]
        } );
        /*END*/
      }, { resize: 'none', useMinHeight: true } );
    </script>

    <p>Or can have margins specified on individual elements:</p>

    <div id="margin-2-spacing-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'margin-2-spacing-example', () => {
        /*START*/
        return new scenery.GridBox( {
          yAlign: 'top',
          children: [
            new scenery.Rectangle( 0, 0, 50, 50, {
              fill: colors[ 0 ],
              layoutOptions: { column: 0, row: 0 }
            } ),
            new scenery.Rectangle( 0, 0, 50, 50, {
              fill: colors[ 2 ],
              layoutOptions: { column: 1, row: 0, topMargin: 10 }
            } ),
            new scenery.Circle( 25, {
              fill: colors[ 4 ],
              layoutOptions: { column: 2, row: 0 }
            } ),
            new scenery.Rectangle( 0, 0, 50, 50, {
              fill: colors[ 6 ],
              layoutOptions: { column: 0, row: 1 }
            } ),
            new scenery.Rectangle( 0, 0, 50, 50, {
              fill: colors[ 8 ],
              layoutOptions: { column: 1, row: 1 }
            } )
          ]
        } );
        /*END*/
      }, { resize: 'none', useMinHeight: true } );
    </script>

    <h2 id="Sizable" class="index">Sizables</h2>

    <p>
      Certain Node subtypes are <code>sizable:</code> they can be adjusted to different <em>preferred</em> sizes/bounds, which are
      equal to or larger than their <em>minimum</em> sizes. When the preferred size is set, the Node should adjust its
      own layout so that it takes up that size. This includes FlowBox (VBox/HBox), GridBox, Panel, and a growing list of
      Nodes.
    </p>

    <p>
      Sizable nodes will either mix in <code>WidthSizable</code>, <code>HeightSizable</code>, or <code>Sizable</code>
      (indicating that both width and height can be adjusted). This provides preferred and minimum sizes in BOTH local
      and parent coordinate frames (e.g. <code>preferredWidth</code> / <code>localPreferredWidth</code>).
      These separate coordinate frame versions will be kept in sync (and are backed by Properties).
    </p>

    <p>
      Typically Nodes will compute their own minimum width/height. The local version of this (e.g. <code>localMinimumWidth</code>)
      is considered the "primary" one, since Nodes usually do layout in their local coordinate frame. This means that
      when a Node's transform changes, its minimum sizes will be adjusted to match the equivalent <code>localMinimum</code> sizes.
    </p>

    <p>
      Typically layout containers (but also clients, manually) will set the preferred sizes on a Node, thus the
      parent version will be primary (e.g. when a sizable Node is transformed, its <code>localPreferredWidth</code> will be adjusted
      to match the <code>preferredWidth</code> after the transformation).
    </p>

    <p>
      Some Nodes by default have this "sizability" turned off, and clients can do this manually with
      <code>widthSizable/heightSizable/sizable:false</code>. Layout containers should not attempt to set preferred sizes when the
      Node is not considered "sizable".
    </p>

    <p>
      For instance, Rectangles mix in Sizable, but are marked as <code>sizable: false</code> by default, so it won't take up space
      even when a container has a larger preferred size. They can be made resizable with <code>sizable: true</code>:
    </p>

    <div id="rectUnsizable-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'rectUnsizable-example', () => {
        /*START*/
        return new scenery.GridBox( {
          // Resize everything up evenly
          grow: 1,
          stretch: true,

          // Show the effect without having to drag to make it larger
          minContentWidth: 100,
          minContentHeight: 100,
          rows: [ [
            new scenery.Rectangle( 0, 0, 50, 50, {
              fill: colors[ 2 ]
            } ),
            new scenery.Rectangle( 0, 0, 50, 50, {
              minimumWidth: 50,
              fill: colors[ 4 ],
              widthSizable: true
            } )
          ], [
            new scenery.Rectangle( 0, 0, 50, 50, {
              minimumHeight: 50,
              fill: colors[ 6 ],
              heightSizable: true
            } ),
            new scenery.Rectangle( 0, 0, 50, 50, {
              minimumWidth: 50,
              minimumHeight: 50,
              fill: colors[ 8 ],
              sizable: true
            } )
          ] ]
        } );
        /*END*/
      }, { resize: 'both', useMinWidth: true, useMinHeight: true } );
    </script>

    <h2 id="layoutOptions" class="index">layoutOptions</h2>

    <p>
      Layout options can be set on individual child Nodes of a layout container. These will override the container's
      default for any options included. These can be mutated after (by setting the entire thing with <code>node.layoutOptions =</code>
      or with <code>mutateLayoutOptions</code>). <code>mutateLayoutOptions</code> is recommended, since it will keep some layout options that may
      be set by <code>rows/columns/autoRows/autoColumns</code> in GridBox.
    </p>

    <div id="layoutOptionsMutate-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'layoutOptionsMutate-example', () => {
        /*START*/
        const box = new scenery.HBox( {
          children: colors.map( color => new scenery.Rectangle( 0, 0, 50, 50, { fill: color } ) )
        } );
        box.children[ 0 ].rectHeight = 100;
        box.children[ 3 ].mutateLayoutOptions( {
          leftMargin: 10
        } );
        box.children[ 5 ].mutateLayoutOptions( {
          align: 'top'
        } );
        /*END*/
        return box;
      }, { resize: 'both', useMinWidth: true, useMinHeight: true } );
    </script>

    <h2 id="layoutOrigin" class="index">layoutOrigin</h2>

    <p>
      FlowBox/GridBox typically lay out content so that the origin (0,0) is at the upper-left. There are some exceptions
      to this.
    </p>

    <p>The default behavior:</p>

    <div id="defaultOrigin-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'defaultOrigin-example', () => {
        const originSize = 50;
        const originNode = new scenery.Path( new kite.Shape().moveTo( -originSize, 0 ).lineTo( originSize, 0 ).moveTo( 0, originSize ).lineTo( 0, -originSize ), {
          stroke: 'rgba(0,0,0,0.5)'
        } );
        /*START*/
        const box = new scenery.GridBox( {
          opacity: 0.5,
          children: colors.map( color => new scenery.Rectangle( 0, 0, 40, 40, { fill: color } ) ),
          autoColumns: 3
        } );
        /*END*/
        return new scenery.AlignBox( new scenery.Node( {
          children: [ originNode, box ]
        } ) );
      }, { resize: 'none' } );
    </script>

    <p>When using <code>align: origin</code>, the origin of the entire FlowBox will be at the origin of the first line:</p>

    <div id="flowOrigin-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'flowOrigin-example', () => {
        const originSize = 50;
        const originNode = new scenery.Path( new kite.Shape().moveTo( -originSize, 0 ).lineTo( originSize, 0 ).moveTo( 0, originSize ).lineTo( 0, -originSize ), {
          stroke: 'rgba(0,0,0,0.5)'
        } );
        const normalText = ( str, options ) => new scenery.Text( str, phetCore.merge( {
          font: new scenery.Font( { size: 12 } )
        }, options ) );
        const bigText = ( str, options ) => new scenery.Text( str, phetCore.merge( {
          font: new scenery.Font( { size: 18, weight: 'bold' } )
        }, options ) );
        /*START*/
        const box = new scenery.HBox( {
          align: 'origin',
          spacing: 5,
          lineSpacing: 5,
          children: [
            new scenery.Circle( 20, { fill: 'rgba(255,0,0,0.3)' } ),
            bigText( 'Text' ),
            normalText( 'Text' ),
            new scenery.Circle( 20, { fill: 'rgba(255,0,0,0.3)' } ),
            bigText( 'Text' ),
            normalText( 'text' ),
            new scenery.Circle( 20, { fill: 'rgba(255,0,0,0.3)' } ),
            bigText( 'Text' ),
            normalText( 'text' ),
            new scenery.Circle( 20, { fill: 'rgba(255,0,0,0.3)' } ),
            bigText( 'Text' ),
            normalText( 'text' )
          ],
          wrap: true,
          preferredWidth: 170,
          widthSizable: false,
          justify: 'left'
        } );
        /*END*/
        return new scenery.AlignBox( new scenery.Node( {
          children: [ originNode, box ]
        } ) );
      }, { resize: 'none' } );
    </script>

    <p>When using <code>align: origin</code>, the origin of the entire GridBox will be at the origin of the first cell:</p>

    <div id="gridOrigin-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'gridOrigin-example', () => {
        const originSize = 50;
        const originNode = new scenery.Path( new kite.Shape().moveTo( -originSize, 0 ).lineTo( originSize, 0 ).moveTo( 0, originSize ).lineTo( 0, -originSize ), {
          stroke: 'rgba(0,0,0,0.5)'
        } );
        /*START*/
        const box = new scenery.GridBox( {
          xAlign: 'origin',
          yAlign: 'origin',
          children: [
            new scenery.Circle( 20, { fill: 'rgba(255,0,0,0.3)', layoutOptions: { column: 0, row: 0 } } ),
            new scenery.Circle( 10, { fill: 'rgba(255,0,0,0.3)', layoutOptions: { column: 1, row: 0 } } ),
            new scenery.Circle( 15, { fill: 'rgba(255,0,0,0.3)', layoutOptions: { column: 0, row: 1 } } ),
            new scenery.Circle( 25, { fill: 'rgba(255,0,0,0.3)', layoutOptions: { column: 1, row: 1 } } )
          ]
        } );
        /*END*/
        return new scenery.AlignBox( new scenery.Node( {
          children: [ originNode, box ]
        } ) );
      }, { resize: 'none' } );
    </script>

    <p>The position of this origin can be shifted by using <code>layoutOrigin</code></p>

    <div id="layoutOrigin-example"></div>
    <script type="text/javascript">
      dynamicDemo( 'layoutOrigin-example', () => {
        const originSize = 50;
        const originNode = new scenery.Path( new kite.Shape().moveTo( -originSize, 0 ).lineTo( originSize, 0 ).moveTo( 0, originSize ).lineTo( 0, -originSize ), {
          stroke: 'rgba(0,0,0,0.5)'
        } );
        /*START*/
        const box = new scenery.GridBox( {
          layoutOrigin: new dot.Vector2( 40, 20 ),
          opacity: 0.5,
          children: colors.map( color => new scenery.Rectangle( 0, 0, 40, 40, { fill: color } ) ),
          autoColumns: 3
        } );
        /*END*/
        return new scenery.AlignBox( new scenery.Node( {
          children: [ originNode, box ]
        } ) );
      }, { resize: 'none' } );
    </script>

    <h2 id="ManualConstraint" class="index">ManualConstraint</h2>

    <p>
      ManualConstraint is for hooking up imperative-style layout code (e.g. <code>someNode.left = otherNode.right</code>) so that
      it correctly auto-updates whenever one of those values may have changed. It also works across different Node
      parents and coordinate frames.
    </p>

    <p>
      It will also robustly handle cases where the Nodes are not connected (and will not run the layout), so the
      constraint can be created before all of the Node structure is finalized.
    </p>

    <p>
      Children are dynamically added/removed in this demo, and <code>child1</code> is constantly translated.
    </p>

    <div id="manualConstraint-example"></div>
    <script type="text/javascript">
      ( () => {
        const createLabeledBox = ( label, fill, width, height ) => {
          return new scenery.Rectangle( 0, 0, width, height, {
            stroke: 'black',
            fill: fill,
            children: [
              new scenery.Text( label, { font: new scenery.Font( { size: 8 } ), left: 3, bottom: height - 3 } )
            ]
          } );
        };
        let step;
        let elapsedTime = 0;
        dynamicDemo( 'manualConstraint-example', () => {
          /*START*/
          const background = new scenery.Rectangle( 0, 0, 400, 200, {
            fill: '#ccc'
          } );

          const child1 = createLabeledBox( 'Child 1', colors[ 2 ], 50, 50 );
          const child2 = createLabeledBox( 'Child 2', colors[ 4 ], 50, 50 );
          const child3 = createLabeledBox( 'Child 3', colors[ 5 ], 50, 50 );

          scenery.ManualConstraint.create( background, [ child1, child2 ], ( child1Proxy, child2Proxy ) => {
            child2Proxy.leftCenter = child1Proxy.rightCenter;
          } );
          scenery.ManualConstraint.create( background, [ child2, child3 ], ( child2Proxy, child3Proxy ) => {
            child3Proxy.left = child2Proxy.right;
          } );
          scenery.ManualConstraint.create( background, [ child1, child3 ], ( child1Proxy, child3Proxy ) => {
            child3Proxy.centerY = child1Proxy.centerY;
          } );

          const nodes = [
            new scenery.Node( { x: 50, y: 50, children: [ child1 ] } ),
            new scenery.Node( { scale: 2, y: 20, children: [ child2 ] } ),
            new scenery.Node( { matrix: dot.Matrix3.rowMajor(
              0.5, 0, 0,
              0, 1, 0,
              0, 0, 1 ), children: [ child3 ] } )
          ]

          step = dt => {
            elapsedTime += dt;
            child1.translation = dot.Vector2.createPolar( 10, 2 * elapsedTime );

            background.children = [
              ...( elapsedTime % 3 < 2 ? [ nodes[ 0 ] ] : [] ),
              ...( elapsedTime % 5 < 4 ? [ nodes[ 1 ] ] : [] ),
              ...( elapsedTime % 7 < 5 ? [ nodes[ 2 ] ] : [] )
            ];
          };

          /*END*/
          return background;
        }, { resize: 'none', useMinHeight: true, useMinWidth: true, step: dt => step( dt ) } );
      } )();
    </script>

    <h2 id="FlowConstraint" class="index">FlowConstraint</h2>

    <p>
      FlowBox's constraint can also be used with disconnected Nodes that share some ancestor (with qualities
      similar to ManualConstraint:
    </p>

    <div id="flowConstraint-example"></div>
    <script type="text/javascript">
      ( () => {
        const createLabeledBox = ( label, fill, width, height ) => {
          return new scenery.Rectangle( 0, 0, width, height, {
            stroke: 'black',
            fill: fill,
            children: [
              new scenery.Text( label, { font: new scenery.Font( { size: 8 } ), left: 3, bottom: height - 3 } )
            ]
          } );
        };
        dynamicDemo( 'flowConstraint-example', () => {
          /*START*/
          const firstChild = createLabeledBox( 'First child', '#faa', 150, 30 );
          const secondChild = createLabeledBox( 'Second child', '#afa', 150, 30 );
          const thirdChild = createLabeledBox( 'Third child', '#aaf', 150, 30 );

          const firstParent = new scenery.Node( {
            children: [
              firstChild,
              createLabeledBox( 'First parent', null, 400, 200 )
            ]
          } );
          const secondParent = new scenery.Node( {
            children: [
              secondChild,
              createLabeledBox( 'Second parent', null, 400, 200 )
            ],
            scale: 0.75
          } );
          const thirdParent = new scenery.Node( {
            children: [
              thirdChild,
              createLabeledBox( 'Third parent', null, 400, 200 )
            ],
            scale: 0.5
          } );

          const scene = new scenery.Node( {
            children: [ firstParent, secondParent, thirdParent ]
          } );

          // Directly create the constraint, specifying a layoutOrigin to position the content
          const constraint = new scenery.FlowConstraint( scene, {
            layoutOriginProperty: new axon.Property( new dot.Vector2( 10, 10 ) ),
            align: 'top',
            spacing: 10,
          } );

          // For Flow constraints, we need to know the order, so cells are inserted at specific indices. They can be
          // removed later
          constraint.insertCell( 0, new scenery.FlowCell( constraint, firstChild, null ) );
          constraint.insertCell( 1, new scenery.FlowCell( constraint, secondChild, null ) );
          constraint.insertCell( 2, new scenery.FlowCell( constraint, thirdChild, null ) );
          constraint.updateLayout();

          /*END*/
          return scene;
        }, { resize: 'none' } );
      } )();
    </script>

    <h2 id="GridConstraint" class="index">GridConstraint</h2>

    <p>
      GridBox's constraint can also be used with disconnected Nodes that share some ancestor (with qualities
      similar to ManualConstraint:
    </p>

    <div id="gridConstraint-example"></div>
    <script type="text/javascript">
      ( () => {
        const createLabeledBox = ( label, fill, width, height ) => {
          return new scenery.Rectangle( 0, 0, width, height, {
            stroke: 'black',
            fill: fill,
            children: [
              new scenery.Text( label, { font: new scenery.Font( { size: 8 } ), left: 3, bottom: height - 3 } )
            ]
          } );
        };
        dynamicDemo( 'gridConstraint-example', () => {
          /*START*/
          const firstChild = createLabeledBox( 'First child', '#faa', 150, 30 );
          const secondChild = createLabeledBox( 'Second child', '#afa', 150, 30 );
          const thirdChild = createLabeledBox( 'Third child', '#aaf', 150, 30 );
          firstChild.layoutOptions = { x: 0, y: 0 };
          secondChild.layoutOptions = { x: 1, y: 0 };
          thirdChild.layoutOptions = { x: 0, y: 1 };

          const firstParent = new scenery.Node( {
            children: [
              firstChild,
              createLabeledBox( 'First parent', null, 400, 200 )
            ]
          } );
          const secondParent = new scenery.Node( {
            children: [
              secondChild,
              createLabeledBox( 'Second parent', null, 400, 200 )
            ],
            scale: 0.75
          } );
          const thirdParent = new scenery.Node( {
            children: [
              thirdChild,
              createLabeledBox( 'Third parent', null, 400, 200 )
            ],
            scale: 0.5
          } );

          const scene = new scenery.Node( {
            children: [ firstParent, secondParent, thirdParent ]
          } );

          // Directly create the constraint, specifying a layoutOrigin to position the content
          const constraint = new scenery.GridConstraint( scene, {
            layoutOriginProperty: new axon.Property( new dot.Vector2( 10, 10 ) ),
            xAlign: 'left',
            yAlign: 'top',
            spacing: 10
          } );

          // For the grid, cells are created and added (they can be removed/disposed later).
          constraint.addCell( new scenery.GridCell( constraint, firstChild, null ) );
          constraint.addCell( new scenery.GridCell( constraint, secondChild, null ) );
          constraint.addCell( new scenery.GridCell( constraint, thirdChild, null ) );
          constraint.updateLayout();

          /*END*/
          return scene;
        }, { resize: 'none' } );
      } )();
    </script>

    <h2 id="AlignBox" class="index">AlignBox</h2>

    <h3 class="index">alignBounds</h3>

    <p>AlignBox on its own will position content within a specific bounding box (its <code>alignBounds</code>):</p>

    <div id="simpleAlignBox-example"></div>
    <script type="text/javascript">
      ( () => {
        dynamicDemo( 'simpleAlignBox-example', () => {
          /*START*/
          const rect = new scenery.Rectangle( 0, 0, 50, 50, {
            fill: 'red'
          } );
          return new scenery.AlignBox( rect, {
            alignBounds: new dot.Bounds2( 0, 0, 100, 100 )
          } );
          /*END*/
        }, { resize: 'none' } );
      } )();
    </script>

    <h3 class="index">Alignment</h3>

    <p>Content can be aligned within this:</p>

    <div id="alignBoxAlign-example"></div>
    <script type="text/javascript">
      ( () => {
        dynamicDemo( 'alignBoxAlign-example', () => {
          /*START*/
          const rect = new scenery.Rectangle( 0, 0, 50, 50, {
            fill: 'red'
          } );
          return new scenery.AlignBox( rect, {
            alignBounds: new dot.Bounds2( 0, 0, 100, 100 ),
            xAlign: 'left',
            yAlign: 'bottom'
          } );
          /*END*/
        }, { resize: 'none' } );
      } )();
    </script>

    <h3 class="index">Margins</h3>

    <p>And margins can be specified on each side:</p>

    <div id="alignBoxMargins-example"></div>
    <script type="text/javascript">
      ( () => {
        dynamicDemo( 'alignBoxMargins-example', () => {
          /*START*/
          const rect = new scenery.Rectangle( 0, 0, 50, 50, {
            fill: 'red'
          } );
          return new scenery.AlignBox( rect, {
            alignBounds: new dot.Bounds2( 0, 0, 100, 100 ),
            xAlign: 'left',
            yAlign: 'bottom',
            leftMargin: 5,
            bottomMargin: 10
          } );
          /*END*/
        }, { resize: 'none' } );
      } )();
    </script>

    <p>Margins can also be used on their own (without <code>alignBounds</code> / <code>align</code>) to just create a Node with larger bounds:</p>

    <div id="alignBoxOnlyMargins-example"></div>
    <script type="text/javascript">
      ( () => {
        dynamicDemo( 'alignBoxOnlyMargins-example', () => {
          /*START*/
          const rect = new scenery.Rectangle( 0, 0, 50, 50, {
            fill: 'red'
          } );
          return new scenery.AlignBox( rect, {
            topMargin: 30,
            xMargin: 10
          } );
          /*END*/
        }, { resize: 'none' } );
      } )();
    </script>

    <p>AlignBox can also be used with preferred dimensions instead of an explicit <code>alignBounds</code>:</p>

    <div id="alignBoxPreferred-example"></div>
    <script type="text/javascript">
      ( () => {
        dynamicDemo( 'alignBoxPreferred-example', () => {
          /*START*/
          const rect = new scenery.Rectangle( 0, 0, 50, 50, {
            fill: 'red'
          } );
          return new scenery.AlignBox( rect, {
            preferredWidth: 100,
            preferredHeight: 100,
            xAlign: 'left',
            yAlign: 'bottom'
          } );
          /*END*/
        }, { resize: 'none' } );
      } )();
    </script>

    <p>and can be dynamically resizable (off by default because it's usually not used for that purpose in legacy code):</p>

    <div id="alignBoxSizable-example"></div>
    <script type="text/javascript">
      ( () => {
        dynamicDemo( 'alignBoxSizable-example', () => {
          /*START*/
          const rect = new scenery.Rectangle( 0, 0, 50, 50, {
            fill: 'red'
          } );
          return new scenery.AlignBox( rect, {
            xAlign: 'left',
            yAlign: 'bottom',
            sizable: true,
            margin: 10
          } );
          /*END*/
        }, { resize: 'both', useMinWidth: true, useMinHeight: true } );
      } )();
    </script>

  </div>
  <div class="span2"></div>
</div>

<footer style="background-color: #191919;">
  <a class="brand" href="/scenery">Scenery</a>
</footer>

<script>
  generateAPIList();
</script>
</body>
</html>
