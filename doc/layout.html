<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">


  <title>Scenery Layout</title>

  <link rel="shortcut icon" type="image/x-icon" href="../assets/logo-v1.svg">
  <link rel="stylesheet" href="../../sherpa/lib/bootstrap-2.2.2.css">
  <link rel="stylesheet" href="../../sherpa/lib/bootstrap-responsive-2.2.2.css">
  <link rel="stylesheet" href="../../sherpa/lib/syntaxhighlighter-3.0.83/shCore.css">
  <link rel="stylesheet" href="../../sherpa/lib/syntaxhighlighter-3.0.83/shThemeDefault.css">
  <link rel="stylesheet" href="../assets/scenery.css">

  <!-- Before loading other things (that might error), create hooks to report errors/loads for continuous testing -->
  <script src="../../chipper/js/browser/sim-tests/pageload-connector.js"></script>

  <!-- jQuery and LoDash are dependencies -->
  <script src="../../sherpa/lib/jquery-2.1.0.min.js"></script>
  <script src="../../sherpa/lib/lodash-4.17.4.min.js"></script>

  <!-- For the styling -->
  <script src="../../sherpa/lib/bootstrap-2.2.2.js"></script>

  <link rel="stylesheet" href="../../sherpa/lib/highlightjs-11.5.1-a11y-light.min.css">
  <script src="../../sherpa/lib/highlightjs-11.5.1.min.js"></script>
  <script src="./doc.js"></script>
  <link rel="stylesheet" href="./doc.css">

  <link rel="stylesheet" href="../../sherpa/lib/codemirror-5.52.2.min.css">
  <link rel="stylesheet" href="../../sherpa/lib/codemirror-5.52.2.monokai.min.css">

  <script src="../../sherpa/lib/codemirror-5.52.2.min.js"></script>
  <script src="../../sherpa/lib/codemirror-5.52.2.javascript.min.js"></script>

  <script src="./extractFunctionJS.js"></script>
  <script src="./scenery-sandbox.js"></script>
  <link rel="stylesheet" href="./scenery-sandbox.css">

  <style>

  </style>

  <!-- Our code, in either the concatenated 'with comments' version or the minified version -->
  <script src="../dist/scenery.min.js"></script>
  <!-- eslint-disable --> <!--TODO: fix lint https://github.com/phetsims/chipper/issues/1405-->

  <script type="text/javascript">
    phet.scenery.Utils.polyfillRequestAnimationFrame();

    _.extend( window, phet.phetCore );
    _.extend( window, phet.axon );
    _.extend( window, phet.dot );
    _.extend( window, phet.kite );
    _.extend( window, phet.scenery );

    const colors = [
      new Color( 62, 171, 3 ),
      new Color( 23, 180, 77 ),
      new Color( 24, 183, 138 ),
      new Color( 23, 178, 194 ),
      new Color( 20, 163, 238 ),
      new Color( 71, 136, 255 ),
      new Color( 171, 101, 255 ),
      new Color( 228, 72, 235 ),
      new Color( 252, 66, 186 ),
      new Color( 252, 82, 127 )
    ];

    const createLabeledBox = ( label, fill, width, height ) => {
      return new Rectangle( 0, 0, width, height, {
        stroke: 'black',
        fill: fill,
        children: [
          new Text( label, { font: new Font( { size: 8 } ), left: 3, bottom: height - 3 } )
        ]
      } );
    };

    class ResizableNode extends Node {
      constructor( display, content, providedOptions ) {
        const options = merge( {
          widthResizable: false,
          heightResizable: false
        }, providedOptions );

        if ( options.widthResizable ) {
          content.preferredWidth = content.minimumWidth;
        }
        if ( options.heightResizable ) {
          content.preferredHeight = content.minimumHeight;
        }

        const resizeIconColor = new Color( 140, 140, 140 );
        const resizeBackgroundColor = new Color( 210, 210, 210 );
        const resizeStrokeColor = new Color( 140, 140, 140 );
        const resizeStrokeLineWidth = 0.5;

        const resizeHandleSize = 12;
        const space = 3;
        const radius = 1.2;
        const singleResizeShape = new Shape()
          .circle( 0, 0, radius ).close()
          .circle( space, space, radius ).close()
          .circle( 2 * space, 0, radius ).close()
          .circle( 3 * space, space, radius ).close()
          .circle( 4 * space, 0, radius ).close()
          .circle( 5 * space, space, radius ).close()
          .circle( 6 * space, 0, radius ).close()
          .circle( 7 * space, space, radius ).close()
          .circle( 8 * space, 0, radius ).close();
        const singleResizeIcon = new Path( singleResizeShape, {
          fill: resizeIconColor
        } );

        const fullResizePath = new Shape()
          .moveTo( 1, resizeHandleSize - 1 ).lineTo( resizeHandleSize - 1, 1 )
          .moveTo( 5, resizeHandleSize - 1 ).lineTo( resizeHandleSize - 1, 5 )
          .moveTo( 9, resizeHandleSize - 1 ).lineTo( resizeHandleSize - 1, 9 );
        const fullResizeIcon = new Path( fullResizePath, {
          stroke: resizeIconColor
        } );

        const horizontalDragHandle = new Rectangle( 0, 0, resizeHandleSize, resizeHandleSize, {
          fill: resizeBackgroundColor,
          stroke: resizeStrokeColor,
          lineWidth: resizeStrokeLineWidth,
          cursor: 'pointer',
          inputListeners: [
            new DragListener( {
              drag: ( event, listener ) => {
                content.preferredWidth = Math.min( display.width - resizeHandleSize, Math.max( content.minimumWidth, 2 * listener.modelPoint.x ) );
              }
            } )
          ],
          children: [ new Node( { children: [ singleResizeIcon ], rotation: -Math.PI / 2 } ) ]
        } );
        const verticalDragHandle = new Rectangle( 0, 0, resizeHandleSize, resizeHandleSize, {
          fill: resizeBackgroundColor,
          stroke: resizeStrokeColor,
          lineWidth: resizeStrokeLineWidth,
          cursor: 'pointer',
          inputListeners: [
            new DragListener( {
              drag: ( event, listener ) => {
                content.preferredHeight = Math.max( content.minimumHeight, listener.modelPoint.y );
              }
            } )
          ],
          children: [ new Node( { children: [ singleResizeIcon ] } ) ]
        } );
        const fullDragHandle = new Rectangle( 0, 0, resizeHandleSize + resizeStrokeLineWidth, resizeHandleSize + resizeStrokeLineWidth, {
          fill: resizeBackgroundColor,
          cursor: 'pointer',
          inputListeners: [
            new DragListener( {
              drag: ( event, listener ) => {
                content.preferredWidth = Math.min( display.width - resizeHandleSize, Math.max( content.minimumWidth, 2 * listener.modelPoint.x ) );
                content.preferredHeight = Math.max( content.minimumHeight, listener.modelPoint.y );
              }
            } )
          ],
          children: [
            fullResizeIcon
          ]
        } );

        options.children = [
          content,
          ...( options.widthResizable ? [ horizontalDragHandle ] : [] ),
          ...( options.heightResizable ? [ verticalDragHandle ] : [] ),
          ...( options.widthResizable && options.heightResizable ? [ fullDragHandle ] : [] )
        ];

        content.localBoundsProperty.link( () => {
          content.top = 0;
          content.centerX = 0;

          horizontalDragHandle.rectHeight = content.height - resizeStrokeLineWidth;
          verticalDragHandle.rectWidth = content.width - resizeStrokeLineWidth;

          horizontalDragHandle.children[ 0 ].center = horizontalDragHandle.selfBounds.center;
          verticalDragHandle.children[ 0 ].center = verticalDragHandle.selfBounds.center;

          horizontalDragHandle.left = content.right;
          horizontalDragHandle.centerY = content.centerY;

          verticalDragHandle.top = content.bottom;
          verticalDragHandle.centerX = content.centerX;

          fullDragHandle.left = content.right;
          fullDragHandle.top = content.bottom;
        } );

        super( options );
      }
    }
  </script>
</head>

<body>
<div class="navbar navbar-inverse navbar-static-top">
  <div class="navbar-inner">
    <a class="brand" href="/scenery">Scenery</a>
    <ul class="nav">
      <li><a href="../">Home</a></li>
      <li class="active"><a href="../doc">Documentation</a></li>
      <li><a href="../examples">Examples</a></li>
      <li><a href="../tests">Tests</a></li>
    </ul>
  </div>
</div>

<div class="row-fluid">
  <div class="span2"></div>
  <div class="span8">
    <div class="page-header" style="text-align: center;">
      <h1>Scenery Layout</h1>
    </div>
  </div>
  <div class="span2"></div>
</div>

<div class="row-fluid">
  <div class="span2" id="apiList">
    <!-- the apiList will be filled in by JS -->
  </div>
  <div class="span8">

    <h2 id="introduction" class="index">Introduction</h2>

    <p>
      Here we will cover the layout system in <a href="https://phetsims.github.io/scenery/">Scenery</a>.
    </p>

    <h3 id="bounds" class="index">Bounds</h3>

    <p>
      The layout system in Scenery is based on the concept of <code>bounds</code>. Each <em>paintable</em> Node (that
      displays something, like <code>Text</code> or <code>Path</code>) will define its own <code>selfBounds</code>
      (as a <code>Bounds2</code> object, that stores a left/top/right/bottom).
    </p>

    <p>
      The <code>localBounds</code> of a Node is the combination of the <code>selfBounds</code> along with the <code>bounds</code>
      of each of the child Nodes. This defines the size of the Node within its <em>local coordinate frame</em>.
    </p>

    <p>
      Each Node has an affine transform that can be used to transform the Node's local coordinate frame into the parent's
      coordinate frame. This is used to position and scale the Node within its parent.
    </p>

    <p>
      This transform is used to calculate the <code>bounds</code> of the Node from its <code>localBounds</code>. The
      <code>bounds</code> are in what is known as the <em>parent coordinate frame</em>, and define the size of the Node to
      everything else.
    </p>

    <p>
      Most getters for things like <code>width</code> / <code>height</code> will return the value of the <code>bounds</code>.
    </p>

    <h3 id="layout-containers" class="index">Layout Containers</h3>

    <p>
      Some Nodes are called <em>layout containers</em> if they will control the position and size of child content.
      Some, like <code>HBox</code> / <code>VBox</code> / <code>GridBox</code> (discussed below), will be responsible for
      all of their children. Some, like <code>Panel</code> will only control one child (its main content).
      Layout containers will also usually control the <em>preferred</em> bounds of their children, if they are sizable
      (discussed later).
    </p>

    <p>
      When a layout container is given children, it will typically reposition them whenever any of the children change
      in size, or have any change in properties that would affect the layout. Sometimes this is done immediately,
      however for performance reasons many times bounds are not proactively computed, and are instead computed lazily
      (at the next animation frame) when needed. To force the bounds of a Node to be updated immediately, please use
      `node.validateBounds()`. It is usually best to write code where this is not needed.
    </p>

    <p>
      The most important Scenery layout containers are discussed below:
    </p>

    <ul>
      <li><code>FlowBox</code>, with its <code>HBox</code> / <code>VBox</code> shortcuts, acts similarly to a CSS flexbox container</li>
      <li><code>GridBox</code> acts similarly to CSS grid</li>
      <li><code>ManualConstraint</code> allows writing imperative-style connections between Nodes with different parents</li>
      <li><code>AlignBox</code> allows positioning a Node within a rectangle, with margins/alignment</li>
    </ul>

    <h3 id="sizable-components" class="index">Sizable Components</h3>

    <p>
      Nodes like FlowBox (HBox/VBox), GridBox, and many <a href="https://github.com/phetsims/sun">sun</a> components
      (buttons, AccordionBox, Panel, Slider, Checkbox) are <em>sizable</em>: they can be adjusted to different
      <em>preferred</em> sizes/bounds, which are equal to or larger than their <em>minimum</em> sizes. When the preferred
      size is set, the Node is responsible for adjusting its own layout so that it takes up that size.
    </p>

    <p>
      Sizable nodes will either mix in <code>WidthSizable</code>, <code>HeightSizable</code>, or <code>Sizable</code>
      (indicating that both width and height can be adjusted). This provides preferred and minimum sizes in BOTH local
      and parent coordinate frames (e.g. <code>preferredWidth</code> / <code>localPreferredWidth</code>).
      These separate coordinate frame versions will be kept in sync (and are backed by Properties).
    </p>

    <p>
      Typically Nodes will compute their own minimum width/height. The local version of this (e.g. <code>localMinimumWidth</code>)
      is considered the "primary" one, since Nodes usually do layout in their local coordinate frame. This means that
      when a Node's transform changes, its minimum sizes will be adjusted to match the equivalent
      <code>localMinimum</code> sizes.
    </p>

    <p>
      Typically layout containers (but also clients, manually) will set the preferred sizes on a Node, thus the
      parent version will be primary (e.g. when a sizable Node is transformed, its <code>localPreferredWidth</code> will
      be adjusted to match the <code>preferredWidth</code> after the transformation).
    </p>

    <p>
      Some Nodes by default have this "sizability" turned off, and clients can do this manually with
      <code>widthSizable/heightSizable/sizable:false</code>. Layout containers should not attempt to set preferred sizes
      when the Node is not considered "sizable".
    </p>

    <p>
      For instance, Rectangles mix in Sizable, but are marked as <code>sizable: false</code> by default, so it won't
      take up space even when a container has a larger preferred size. They can be made resizable with <code>sizable:
      true</code>:
    </p>

    <p>
      NOTE: This is different than the <code>stretch</code> layout option. <code>stretch</code> will potentially change
      what preferred size it will set to a Node. <code>sizable</code> on a Node will prevent that setting of preferred
      size.
    </p>

    <h3 id="layoutOptions" class="index">Layout Options</h3>

    <p>
      The section below will show off many layout options that are typically set on the container (and apply to all
      children). These can also be set on individual children, and will override the container's default for any options
      included. These can be mutated after (by setting the entire thing with <code>node.layoutOptions =</code> or with
      <code>mutateLayoutOptions</code>).
    </p>

    <p>
      <code>mutateLayoutOptions</code> is recommended when applying additional adjustments to <code>layoutOptions</code>,
      so that it won't by accident remove any layout options that were set earlier OR some set by the container. For
      example, GridBox with <code>rows/columns/autoRows/autoColumns</code> will set some layout options, and using
      <code>gridBox.layoutOptions =</code> may wipe out the positioning information for the child.
    </p>

    <div id="layoutOptionsMutate-example"></div>
    <script type="text/javascript">
      createSandbox( 'layoutOptionsMutate-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          const box = new HBox( {
            children: [
              new Rectangle( 0, 0, 50, 100, {
                fill: colors[ 0 ]
              } ),
              new Rectangle( 0, 0, 50, 50, {
                fill: colors[ 2 ],
                layoutOptions: { leftMargin: 10 }
              } ),
              new Rectangle( 0, 0, 50, 50, {
                fill: colors[ 4 ],
                layoutOptions: { align: 'top' }
              } ),
              new Rectangle( 0, 0, 50, 50, {
                fill: colors[ 6 ]
              } )
            ]
          } );
          return box;
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {
          widthResizable: true,
          heightResizable: true
        } ) );
      } );
    </script>

    <h3 id="references-and-documentation" class="index">References and Documentation</h3>

    <p>
      It is recommended to view assorted PhET simulations and libraries for examples to see how layout is used in practice.
    </p>

    <p>
      There are a <a href="../../phet-lib/doc/layout-exemplars.html">number of examples</a> that show layout in action with
      assorted <a href="https://github.com/phetsims/sun">sun</a> components.
    </p>

    <script>
      if ( window.location.hostname === 'phetsims.github.io' ) {
        document.getElementById( 'localOnly' ).style.display = 'none';
      }
    </script>

    <p>
      If you're using a built version of Scenery, you'll need to add the relevant namespaces to objects. Almost
      everything here will need a <code>scenery.</code> prefix, e.g. <code>new phet.scenery.Node()</code> instead of
      <code>new Node()</code>. The built version of Scenery will include <code>scenery</code>, <code>kite</code>
      (for Shape), <code>dot</code> (for Vector2), <code>axon</code> (for Properties) and <code>phetCore</code>.
      The code examples here can use either the prefixed versions or non-prefixed.
    </p>

    <p>
      All of the code examples here are editable. You can change the code and see the results immediately.
    </p>

    <p>
      Many examples can be resized using drag handles. This adjusts the preferred size of the container.
    </p>

    <h2 id="FlowBox" class="index">FlowBox</h2>

    <p>
      A FlowBox is a layout container that lays out its children in a row or column (depending on the orientation).
      It can optionally wrap content to the next row/column when there is no more room (e.g. like text).
    </p>

    <h3 id="FlowBox-orientation" class="index">orientation</h3>

    <p class="index" data-index="HBox">
      For horizontal line-based layout, use <code>HBox</code>:
    </p>

    <div id="HBox-example"></div>
    <script type="text/javascript">
      createSandbox( 'HBox-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          return new HBox( {
            children: [
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
              new Circle( 25, { fill: colors[ 6 ] } ),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 8 ] } )
            ]
          } );
          /*END*/
        } )();
        scene.addChild( box );
      } );
    </script>

    <p class="index" data-index="VBox">
      For vertical line-based layout, use <code>VBox</code>:
    </p>

    <div id="VBox-example"></div>
    <script type="text/javascript">
      createSandbox( 'VBox-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          return new VBox( {
            children: [
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
              new Circle( 25, { fill: colors[ 6 ] } ),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 8 ] } )
            ]
          } );
          /*END*/
        } )();
        scene.addChild( box );
      } );
    </script>

    <p>
      NOTE: For FlowBox, the orientation provided is typically called the <em>primary</em> axis. This is the
      axis along which each Node in a line is positioned. The <em>secondary</em> axis is the opposite one,
      along which each Node is aligned. e.g. for an HBox, its primary axis is horizontal, and its secondary
      axis is vertical (so its elements will be positioned with increasing x values, and its <code>align</code> will
      control the y values).
    </p>

    <p>For cases where the orientation needs to be determined programmatically, use FlowBox:</p>

    <div id="orientation-example"></div>
    <script type="text/javascript">
      createSandbox( 'orientation-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          return new FlowBox( {
            orientation: 'horizontal',
            children: [
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
              new Circle( 25, { fill: colors[ 6 ] } ),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 8 ] } )
            ]
          } );
          /*END*/
        } )();
        scene.addChild( box );
      } );
    </script>

    <h3 id="FlowBox-resizing">Resizing</h3>

    <p>The box adjusts to changing cell sizes:</p>

    <div id="dynamic-example"></div>
    <script type="text/javascript">
      createSandbox( 'dynamic-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          const circle = new Circle( 25, { fill: colors[ 6 ] } );
          let time = 0;
          stepEmitter.addListener( dt => {
            time += dt;
            circle.radius = 25 + 10 * Math.sin( 4 * time );
          } );
          const box = new HBox( {
            children: [
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
              circle,
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 8 ] } )
            ]
          } );
          /*END*/
          const alignBox = new AlignBox( box, {
            alignBounds: new Bounds2( 0, 0, 230, 80 ),
            xAlign: 'left',
            yAlign: 'top',
            margin: 5
          } );
          return alignBox;
        } )();
        scene.addChild( box );
      } );
    </script>

    <p id="FlowBox-resize" class="index" data-index="resize">Resizing/layout can be disabled with <code>resize:
      false</code>:</p>

    <div id="locked-sizing-example"></div>
    <script type="text/javascript">
      createSandbox( 'locked-sizing-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          const circle = new Circle( 25, { fill: colors[ 6 ] } );
          let time = 0;
          stepEmitter.addListener( dt => {
            time += dt;
            circle.radius = 25 + 10 * Math.sin( 4 * time );
          } );
          const box = new HBox( {
            resize: false,
            children: [
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
              circle,
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 8 ] } )
            ]
          } );
          /*END*/
          return box;
        } )();
        scene.addChild( box );
      } );
    </script>

    <h3>Invisible children</h3>

    <p>Invisible nodes are not included in layout/bounds by default:</p>

    <div id="invis-example"></div>
    <script type="text/javascript">
      createSandbox( 'invis-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          return new HBox( {
            children: [
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ], visible: false } ),
              new Circle( 25, { fill: colors[ 6 ] } ),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 8 ] } )
            ]
          } );
          /*END*/
        } )();
        scene.addChild( box );
      } );
    </script>

    <p id="FlowBox-excludeInvisibleChildrenFromBounds">Invisible nodes can be forced into the layout:</p>

    <div id="force-vis-example"></div>
    <script type="text/javascript">
      createSandbox( 'force-vis-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          return new HBox( {
            excludeInvisibleChildrenFromBounds: false,
            children: [
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ], visible: false } ),
              new Circle( 25, { fill: colors[ 6 ] } ),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 8 ] } )
            ]
          } );
          /*END*/
        } )();
        scene.addChild( box );
      } );
    </script>

    <h3 id="FlowBox-grow" class="index">grow</h3>

    <p>
      Nodes with preferred sizes can be added, and the <code>grow</code> in <code>layoutOptions</code> will attempt to
      put extra space into that cell. If all nodes have the same <code>grow</code>, then all nodes will receive the same
      share of the extra space. Otherwise, extra space is distributed proportionally as defined by each node's <code>grow</code>
      value.
    </p>

    <div id="resizable-example"></div>
    <script type="text/javascript">
      createSandbox( 'resizable-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          return new HBox( {
            children: [
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
              new Rectangle( {
                sizable: true,
                localMinimumWidth: 50,
                localMinimumHeight: 50,
                fill: 'gray',
                layoutOptions: { grow: 1 }
              } ),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
              new Circle( 25, { fill: colors[ 6 ] } ),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 8 ] } )
            ]
          } );
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {
          widthResizable: true
        } ) );
      } );
    </script>

    <p>Extra space can be allocated proportionally (a node with 4 times the <code>grow</code> value will grow 4 times as
      fast):</p>

    <div id="grow-example"></div>
    <script type="text/javascript">
      createSandbox( 'grow-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          return new HBox( {
            children: [
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
              new Rectangle( {
                sizable: true,
                localMinimumWidth: 50,
                localMinimumHeight: 50,
                fill: 'gray',
                layoutOptions: { grow: 1 }
              } ),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
              new Rectangle( {
                sizable: true,
                localMinimumWidth: 50,
                localMinimumHeight: 50,
                fill: 'gray',
                layoutOptions: { grow: 4 }
              } ),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 8 ] } )
            ]
          } );
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {
          widthResizable: true
        } ) );
      } );
    </script>

    <h3 id="FlowBox-cellAlign" class="index">cellAlign</h3>

    <p>
      When <code>grow</code> is used to expand a cell, but the content does not fill the cell, <code>cellAlign</code> can
      control the relative positioning of the content within the cell. The default is to the left/top of the cell.
    </p>

    <div id="cellAlign-example"></div>
    <script type="text/javascript">
      createSandbox( 'cellAlign-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          return new HBox( {
            grow: 1, // expand everything
            children: [
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 0 ] } ),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
              new Rectangle( 0, 0, 50, 50, {
                fill: colors[ 4 ],
                layoutOptions: { cellAlign: 'right' }
              } ),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 6 ] } ),
              new Rectangle( 0, 0, 50, 50, {
                fill: colors[ 7 ],
                layoutOptions: { cellAlign: 'center' }
              } ),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 8 ] } )
            ]
          } );
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {
          widthResizable: true
        } ) );
      } );
    </script>

    <h3 id="FlowBox-stretch" class="index">stretch</h3>

    <p><code>stretch</code> will have a resizable element take up the entire row/column size:</p>

    <div id="stretch-example"></div>
    <script type="text/javascript">
      createSandbox( 'stretch-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          return new HBox( {
            children: [
              new Rectangle( 0, 0, 50, 100, {
                fill: colors[ 2 ]
              } ),
              new Rectangle( 0, 0, 50, 50, {
                fill: colors[ 4 ],
                layoutOptions: { align: 'top' }
              } ),
              new Rectangle( {
                sizable: true,
                localMinimumWidth: 50,
                localMinimumHeight: 50,
                fill: 'gray',
                layoutOptions: { stretch: true }
              } ),
              new Circle( 25, {
                fill: colors[ 6 ],
                layoutOptions: { align: 'bottom' }
              } ),
              new Rectangle( 0, 0, 50, 50, {
                fill: colors[ 8 ],
                layoutOptions: { align: 'center' }
              } )
            ]
          } );
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {
          widthResizable: true,
          heightResizable: true
        } ) );
      } );
    </script>

    <h3>Constraining dimensions</h3>

    <p id="FlowBox-maxContent" class="index" data-index="maxContent">Maximums can be applied to constrain this growing
      (it won't grow past the max content dimension):</p>

    <div id="maxContentWidth-example"></div>
    <script type="text/javascript">
      createSandbox( 'maxContentWidth-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          return new HBox( {
            children: [
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
              new Rectangle( {
                sizable: true,
                localMinimumWidth: 50,
                localMinimumHeight: 50,
                fill: 'gray',
                layoutOptions: { grow: 1, maxContentWidth: 150 }
              } ),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
              new Circle( 25, { fill: colors[ 6 ] } ),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 8 ] } )
            ]
          } );
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {
          widthResizable: true
        } ) );
      } );
    </script>

    <p id="FlowBox-minContent" class="index" data-index="minContent">Minimums can also force a certain expansion:</p>

    <div id="minContentWidth-example"></div>
    <script type="text/javascript">
      createSandbox( 'minContentWidth-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          return new HBox( {
            children: [
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
              new Rectangle( {
                sizable: true,
                localMinimumWidth: 50,
                localMinimumHeight: 50,
                fill: 'gray',
                layoutOptions: { grow: 1, minContentWidth: 100 }
              } ),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
              new Circle( 25, { fill: colors[ 6 ] } ),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 8 ] } )
            ]
          } );
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {
          widthResizable: true
        } ) );
      } );
    </script>

    <p>Minimums and maximums also apply on the secondary axis:</p>

    <div id="secondaryAxisContent-example"></div>
    <script type="text/javascript">
      createSandbox( 'secondaryAxisContent-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          return new HBox( {
            children: [
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
              new Rectangle( {
                sizable: true,
                localMinimumWidth: 50,
                localMinimumHeight: 50,
                fill: 'gray',
                layoutOptions: {
                  grow: 1,
                  minContentWidth: 50,
                  minContentHeight: 50,
                  maxContentHeight: 100,
                  stretch: true
                }
              } ),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
              new Circle( 25, { fill: colors[ 6 ] } ),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 8 ] } )
            ]
          } );
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {
          widthResizable: true,
          heightResizable: true
        } ) );
      } );
    </script>

    <p>
      Content minimums and maximums can be applied to all layout cells in the FlowBox by using <code>layoutOptions: {
      minContentWidth: {{NUMBER}}, minContentHeight: {{NUMBER}} }</code>. For example, setting
      <code>minContentWidth</code> in a FlowBox's <code>layoutOption</code> constrains all of its layout cells to
      a certain width ( with margin and spacing added to calculate the total width). This occurs even if the children
      are smaller and do not occupy the full width. However, this method still allows the FlowBox to dynamically resize
      if the children grow. A common mistake is to use <code>preferredWidth</code> / <code>preferredHeight</code>to size
      any content that will end up inside a layout container. These options will get overwritten by a parent with <code>resizable:
      true</code>, which is the default option value for all FlowBoxes.
    </p>

    <p>
      A good thing to note is that the content width/height can multiply the width/height of the parent container when
      wrapping occurs.
    </p>

    <div id="dimension-example"></div>
    <script type="text/javascript">
      createSandbox( 'dimension-example', ( scene, stepEmitter, display ) => {

        /*START*/

        const resizingWidthRectangle = new Rectangle( 0, 0, 20, 20, { fill: colors[ 0 ] } );

        const vBox = new VBox( {
          layoutOptions: {
            minContentWidth: 100
          },
          children: [
            resizingWidthRectangle,
            new Rectangle( 0, 0, 30, 30, { fill: colors[ 2 ] } )
          ]
        } );

        const resizingHeightRectangle = new Rectangle( 0, 0, 20, 20, { fill: colors[ 4 ] } );

        const hBox = new HBox( {
          preferredHeight: 100,
          heightSizable: false,
          children: [
            resizingHeightRectangle,
            new Rectangle( 0, 0, 30, 30, { fill: colors[ 8 ] } )
          ]
        } );

        /*END*/

        let elapsedTime = 0;
        stepEmitter.addListener( dt => {
          elapsedTime += dt;
          const minWidth = 20;
          const maxWidth = 120;
          resizingWidthRectangle.rectWidth = ( minWidth + maxWidth ) / 2 + Math.cos( elapsedTime ) * ( maxWidth - minWidth ) / 2;

          const minHeight = 20;
          const maxHeight = 120;
          resizingHeightRectangle.rectHeight = ( minHeight + maxHeight ) / 2 + Math.cos( elapsedTime ) * ( maxHeight - minHeight ) / 2;
        } );

        const container = new HBox( { children: [ vBox, hBox ], preferredHeight: 120 } );

        scene.addChild( container );
      } );
    </script>

    <h3 id="FlowBox-justify" class="index">justify</h3>

    <p>
      <code>justify</code> controls how extra space is allocated around cells (after any possible growing has been
      done)
    </p>

    <p>
      This closely models the CSS flexbox <a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/#aa-justify-content">justify-content</a> property.
    </p>

    <p>
      The default is <code>spaceBetween</code>, which will only place space between cells, not at the start or end (with an even split of space between every object).
      This works very well for common layout cases, especially where two items are placed into a FlowBox, so they will expand to either side of it.
    </p>

    <p>
      <code>left/top</code> / <code>right/bottom</code> simply puts all of the extra space either at the start or the end of the FlowBox.
    </p>

    <p>
      <code>center</code> puts an even amount of extra space both at the start AND the end of the FlowBox.
    </p>

    <p>
      <code>spaceEvenly</code> will place the same amount of space at the start, end, and between each object.
    </p>

    <p>
      <code>spaceAround</code> is as if each object has margins, such that each object gets evenly-split space before and after it.
      Thus the space at the start would be half that of the space between object A and B (since that space is a combined margin for both objects).
    </p>

    <div id="justification-example"></div>
    <script type="text/javascript">
      createSandbox( 'justification-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          const createBoxes = label => [
            new Rectangle( 0, 0, 170, 30, {
              fill: colors[ 2 ], children: [
                new Text( label, { fontSize: 16, centerY: 15 } )
              ]
            } ),
            new Rectangle( 0, 0, 50, 30, { fill: colors[ 4 ] } ),
            new Circle( 15, { fill: colors[ 6 ] } ),
            new Rectangle( 0, 0, 50, 30, { fill: colors[ 8 ] } )
          ];
          /*START*/
          const boxes = [
            new HBox( {
              justify: 'left',
              children: createBoxes( 'justify:left' )
            } ),
            new HBox( {
              justify: 'right',
              children: createBoxes( 'justify:right' )
            } ),
            new HBox( {
              justify: 'spaceBetween',
              children: createBoxes( 'justify:spaceBetween' )
            } ),
            new HBox( {
              justify: 'spaceAround',
              children: createBoxes( 'justify:spaceAround' )
            } ),
            new HBox( {
              justify: 'spaceEvenly',
              children: createBoxes( 'justify:spaceEvenly' )
            } ),
            new HBox( {
              justify: 'center',
              children: createBoxes( 'justify:center' )
            } )
          ];
          /*END*/
          const container = new VBox( {
            justify: 'top',
            stretch: true,
            children: boxes
          } );
          return container;
        } )();
        scene.addChild( new ResizableNode( display, box, {
          widthResizable: true
        } ) );
        box.preferredWidth = 400;
      } );
    </script>

    <h3 id="FlowBox-wrap" class="index">wrap</h3>

    <p><code>wrap</code> will shift content that doesn't fit the preferred size into new rows/columns (try resizing it
      to be less wide):</p>

    <div id="wrap-example"></div>
    <script type="text/javascript">
      createSandbox( 'wrap-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          return new HBox( {
            wrap: true,
            justify: 'left',
            justifyLines: 'top',
            children: [
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
              new Circle( 25, { fill: colors[ 6 ] } ),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 8 ] } )
            ]
          } );
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {
          widthResizable: true
        } ) );
        box.preferredWidth = 200;
      } );
    </script>

    <h3 id="FlowBox-align" class="index">align</h3>

    <p><code>align</code> controls how cells are positioned along the secondary axis:</p>

    <div id="align-example"></div>
    <script type="text/javascript">
      createSandbox( 'align-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          const boxes = [
            'top',
            'bottom',
            'center',
            'origin'
          ].map( align => {
            return new HBox( {
              children: [
                new Rectangle( 0, 0, 50, 15, { fill: colors[ 9 ] } ),
                new Rectangle( 0, 0, 50, 20, { fill: colors[ 6 ] } ),
                new Rectangle( 0, 0, 50, 5, { fill: colors[ 4 ] } ),
                new Rectangle( 0, 0, 50, 15, { fill: colors[ 2 ] } ),
                new Circle( 7, { fill: colors[ 0 ] } ),
                new Text( `Alignment: ${align}` )
              ],
              justify: 'left',
              align: align
            } );
          } );
          /*END*/
          return new VBox( {
            children: boxes,
            spacing: 10,
            align: 'left'
          } );
        } )();
        scene.addChild( box );
      } );
    </script>

    <p>
      For horizontal boxes, the values are: <code>'left', 'right', 'center', 'origin'</code>. For vertical boxes, the
      values are:
      <code>'top', 'bottom', 'center', 'origin'</code>. See
      <a href="https://github.com/phetsims/scenery/blob/main/js/layout/LayoutAlign.ts">LayoutAlign</a> for more
      details
    </p>

    <p>
      For the <code>'origin'</code> align, it is useful to note that the origin is at the top-left of the rectangles,
      at the center of circles, and at the left of the baseline of text. For the above example of an HBox, the align
      will control the vertical positioning of Nodes, and thus will only care about the Y component of the origin.
      It places the origin of all of the Nodes at the same Y value (top of rectangles, center of circles, baseline of text).
    </p>

    <h3 id="FlowBox-justifyLines" class="index">justifyLines</h3>

    <p><code>justifyLines</code> controls how lines are positioned along the secondary axis (null will default to a
      stretch):</p>

    <div id="justifyLines-example"></div>
    <script type="text/javascript">
      createSandbox( 'justifyLines-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          const boxes = [
            'top',
            'bottom',
            'center',
            'spaceBetween',
            'spaceAround',
            'spaceEvenly',
            null
          ].map( justifyLines => {
            const createResizable = () => {
              const node = new Rectangle( {
                sizable: true,
                localMinimumWidth: 20,
                localMinimumHeight: 20,
                fill: 'gray'
              } );
              return node;
            };
            return new HBox( {
              preferredWidth: 40,
              widthSizable: false,
              wrap: true,
              stretch: true,
              children: [
                new Rectangle( 0, 0, 20, 20, { fill: colors[ 2 ] } ),
                createResizable(),
                new Rectangle( 0, 0, 20, 20, { fill: colors[ 4 ] } ),
                createResizable(),
                new Rectangle( 0, 0, 20, 20, { fill: colors[ 6 ] } ),
                createResizable(),
                new Rectangle( 0, 0, 20, 20, { fill: colors[ 8 ] } ),
                createResizable()
              ],
              justifyLines: justifyLines
            } );
          } );
          /*END*/
          const container = new HBox( {
            justify: 'left',
            stretch: true,
            children: boxes
          } );
          return container;
        } )();
        scene.addChild( new ResizableNode( display, box, {
          heightResizable: true
        } ) );
        box.preferredHeight = 150;
      } );
    </script>

    <h3 id="FlowBox-spacing" class="index">spacing</h3>

    <p><code>spacing</code> controls extra space that can be added between cells:</p>

    <div id="spacing-example"></div>
    <script type="text/javascript">
      createSandbox( 'spacing-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          return new HBox( {
            spacing: 10,
            children: [
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
              new Circle( 25, { fill: colors[ 6 ] } ),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 8 ] } )
            ]
          } );
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {
          widthResizable: true
        } ) );
      } );
    </script>

    <h3 id="FlowBox-lineSpacing" class="index">lineSpacing</h3>

    <p><code>lineSpacing</code> adds space between rows/columns, which applies when wrapped:</p>

    <div id="lineSpacing-example"></div>
    <script type="text/javascript">
      createSandbox( 'lineSpacing-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          return new HBox( {
            lineSpacing: 10,
            wrap: true,
            children: [
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
              new Circle( 25, { fill: colors[ 6 ] } ),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 8 ] } )
            ]
          } );
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {
          widthResizable: true
        } ) );
        box.preferredWidth = 100;
      } );
    </script>

    <h3 id="FlowBox-margins" class="index">Margins</h3>

    <p>Margins can also be added to every cell (<code>margin</code> affects all 4 sides, <code>xMargin</code> affects
      left/right, <code>yMargin</code> affects top/bottom):</p>

    <div id="margin-example"></div>
    <script type="text/javascript">
      createSandbox( 'margin-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          return new HBox( {
            leftMargin: 10,
            yMargin: 10, // controls topMargin and bottomMargin
            children: [
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
              new Circle( 25, { fill: colors[ 6 ] } ),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 8 ] } )
            ]
          } );
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {
          widthResizable: true
        } ) );
      } );
    </script>

    <h3>Per-cell layout options</h3>

    <p>Margins can also be applied to individual cells:</p>

    <div id="marginCell-example"></div>
    <script type="text/javascript">
      createSandbox( 'marginCell-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          return new HBox( {
            align: 'top',
            children: [
              new Rectangle( 0, 0, 50, 50, {
                fill: colors[ 2 ],
                layoutOptions: { topMargin: 10 }
              } ),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
              new Circle( 25, { fill: colors[ 6 ] } ),
              new Rectangle( 0, 0, 50, 50, {
                fill: colors[ 8 ],
                layoutOptions: { leftMargin: 10 }
              } )
            ]
          } );
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {
          widthResizable: true
        } ) );
      } );
    </script>

    <p>Similarly, alignment can also be customized by individual cells:</p>

    <div id="alignCell-example"></div>
    <script type="text/javascript">
      createSandbox( 'alignCell-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          return new HBox( {
            children: [
              new Rectangle( 0, 0, 50, 100, {
                fill: colors[ 2 ]
              } ),
              new Rectangle( 0, 0, 50, 50, {
                fill: colors[ 4 ],
                layoutOptions: { align: 'top' }
              } ),
              new Circle( 25, {
                fill: colors[ 6 ],
                layoutOptions: { align: 'bottom' }
              } ),
              new Rectangle( 0, 0, 50, 50, {
                fill: colors[ 8 ],
                layoutOptions: { align: 'center' }
              } )
            ]
          } );
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {
          widthResizable: true
        } ) );
      } );
    </script>

    <p>These options use the default on the container, but can be overridden by cells:</p>

    <div id="override-example"></div>
    <script type="text/javascript">
      createSandbox( 'override-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          return new HBox( {
            topMargin: 10,
            align: 'top',
            children: [
              new Rectangle( 0, 0, 50, 50, {
                fill: colors[ 2 ],
                layoutOptions: { topMargin: 0 }
              } ),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
              new Circle( 25, { fill: colors[ 6 ] } ),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 8 ] } )
            ]
          } );
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {
          widthResizable: true
        } ) );
      } );
    </script>

    <h3 id="separators" class="index">Separators</h3>

    <p>
      Separators are also available for easy of use (separators at the visible start/end, and duplicates will be marked
      as <code>visible: false</code>, while all other separators will be marked as <code>visible: true</code>):
    </p>

    <div id="separators-example"></div>
    <script type="text/javascript">

      createSandbox( 'separators-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          return new HBox( {
            margin: 5,
            children: [
              new VSeparator(),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
              new VSeparator(),
              new VSeparator(),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
              new Circle( 25, { fill: colors[ 6 ] } ),
              new VSeparator(),
              new Rectangle( 0, 0, 50, 50, { fill: colors[ 8 ] } ),
              new VSeparator()
            ]
          } );
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {
          widthResizable: true
        } ) );
      } );
    </script>

    <p>
      Additionally, arbitrary nodes can be made to act like separators by passing <code>isSeparator: true</code> in its
      <code>layoutOptions</code>
    </p>

    <h2 id="GridBox" class="index">GridBox</h2>

    <p>
      A GridBox is a layout container that lays out its children in a grid. It has numbered rows and columns (both
      starting at zero), which define cells where nodes can be placed. Most layout options are available in either the
      horizontal or vertical direction, and can be specified for each cell.
    </p>

    <h3 id="GridBox-layoutOptions-location" class="index" data-index="Coordinates">Cell coordinates</h3>

    <p>Can be constructed with absolute coordinates (which can include gaps):</p>

    <div id="absolute-example"></div>
    <script type="text/javascript">
      createSandbox( 'absolute-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          return new GridBox( {
            children: [
              new Rectangle( 0, 0, 75, 50, {
                fill: colors[ 0 ],
                layoutOptions: { column: 0, row: 0 }
              } ),
              new Rectangle( 0, 0, 50, 75, {
                fill: colors[ 2 ],
                layoutOptions: { column: 1, row: 0 }
              } ),
              new Circle( 25, {
                fill: colors[ 4 ],
                layoutOptions: { column: 2, row: 0 }
              } ),
              new Rectangle( 0, 0, 50, 50, {
                fill: colors[ 6 ],
                layoutOptions: { column: 0, row: 1 }
              } ),
              new Rectangle( 0, 0, 50, 50, {
                fill: colors[ 8 ],
                layoutOptions: { column: 1, row: 2 }
              } )
            ]
          } );
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {} ) );
      } );
    </script>

    <p>
      The <strong>x</strong> value indicates the column (starting at index 0), and the <strong>y</strong> value
      indicates the row (starting at index 0).
    </p>

    <p>
      NOTE: Skipped rows/columns will be collapsed and won't apply (except for any spacing added):
    </p>

    <div id="skip-example"></div>
    <script type="text/javascript">
      createSandbox( 'skip-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          return new GridBox( {
            children: [
              new Rectangle( 0, 0, 75, 50, {
                fill: colors[ 0 ],
                layoutOptions: { column: 0, row: 0 }
              } ),
              new Rectangle( 0, 0, 50, 75, {
                fill: colors[ 2 ],
                layoutOptions: { column: 50, row: 0 }
              } ),
              new Circle( 25, {
                fill: colors[ 4 ],
                layoutOptions: { column: 25, row: 102 }
              } )
            ]
          } );
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {} ) );
      } );
    </script>

    <h3 id="GridBox-rows" class="index">rows</h3>

    <p>Grids can be constructed by specifying all the children in rows (<code>null</code> for gaps):</p>

    <div id="rows-example"></div>
    <script type="text/javascript">
      createSandbox( 'rows-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          return new GridBox( {
            rows: [
              [
                new Rectangle( 0, 0, 75, 50, {
                  fill: colors[ 0 ]
                } ),
                new Rectangle( 0, 0, 50, 75, {
                  fill: colors[ 2 ]
                } ),
                new Circle( 25, {
                  fill: colors[ 4 ]
                } )
              ],
              [
                new Rectangle( 0, 0, 50, 50, {
                  fill: colors[ 6 ]
                } ),
                null,
                new Rectangle( 0, 0, 50, 50, {
                  fill: colors[ 8 ]
                } )
              ]
            ]
          } );

          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {} ) );
      } );
    </script>

    <h3 id="GridBox-columns" class="index">columns</h3>

    <p>or with columns:</p>

    <div id="columns-example"></div>
    <script type="text/javascript">
      createSandbox( 'columns-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          return new GridBox( {
            columns: [
              [
                new Rectangle( 0, 0, 75, 50, {
                  fill: colors[ 0 ]
                } ),
                new Rectangle( 0, 0, 50, 75, {
                  fill: colors[ 2 ]
                } ),
                new Circle( 25, {
                  fill: colors[ 4 ]
                } )
              ],
              [
                new Rectangle( 0, 0, 50, 50, {
                  fill: colors[ 6 ]
                } ),
                null,
                new Rectangle( 0, 0, 50, 50, {
                  fill: colors[ 8 ]
                } )
              ]
            ]
          } );
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {} ) );
      } );
    </script>

    <h3 id="GridBox-autoLines" class="index" data-index="auto">autoRows/autoColumn</h3>

    <p>
      Additionally, if a certain number of rows/columns are desired, <code>autoRows</code> / <code>autoColumns</code>
      can be used to wrap and position the children based on this (auto-filling all spaces)
    </p>

    <div id="autoColumns-example"></div>
    <script type="text/javascript">
      createSandbox( 'autoColumns-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          return new GridBox( {
            autoColumns: 3,
            children: colors.map( color => {
              return new Rectangle( 0, 0, 50, 50, { fill: color } );
            } )
          } );
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {} ) );
      } );
    </script>

    <div id="autoRows-example"></div>
    <script type="text/javascript">
      createSandbox( 'autoRows-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          return new GridBox( {
            autoRows: 3,
            children: colors.map( color => {
              return new Rectangle( 0, 0, 50, 50, { fill: color } );
            } )
          } );
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {} ) );
      } );
    </script>

    <h3 id="GridBox-addLine" class="index" data-index="adding">addRow/addColumn</h3>

    <p>
      Rows and columns can also be added dynamically in a similar way (rows will be below all current content, columns
      will be to the right of all current content):
    </p>

    <div id="addLines-example"></div>
    <script type="text/javascript">
      createSandbox( 'addLines-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          const box = new GridBox();
          box.addRow( [
            new Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
            new Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } )
          ] );
          box.addColumn( [
            new Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
            new Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
            new Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } )
          ] );
          return box;
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {} ) );
      } );
    </script>

    <h3 id="GridBox-insertLine">insertRow/insertColumn</h3>

    <p>
      Rows and columns can also be directly inserted by index:
    </p>

    <div id="insertLines-example"></div>
    <script type="text/javascript">
      createSandbox( 'insertLines-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          const box = new GridBox( { grow: 1 } );
          box.insertRow( 0, [
            new Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } ),
            new Rectangle( 0, 0, 50, 50, { fill: colors[ 2 ] } )
          ] );
          box.insertColumn( 1, [
            new Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
            new Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } ),
            new Rectangle( 0, 0, 50, 50, { fill: colors[ 4 ] } )
          ] );
          box.insertRow( 2, [
            new Rectangle( 0, 0, 50, 50, { fill: colors[ 6 ] } ),
            new Rectangle( 0, 0, 50, 50, { fill: colors[ 6 ] } ),
            new Rectangle( 0, 0, 50, 50, { fill: colors[ 6 ] } )
          ] );
          return box;
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {} ) );
      } );
    </script>

    <h3 id="GridBox-removeLine" class="index" data-index="removing">removeRow/removeColumn</h3>

    <p>
      Or removed by index:
    </p>

    <div id="deleteLines-example"></div>
    <script type="text/javascript">
      createSandbox( 'deleteLines-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          const box = new GridBox( {
            rows: _.range( 0, 8 ).map( row => {
              return _.range( 0, 8 ).map( column => {
                return new Rectangle( 0, 0, 80, 20, {
                  fill: new Color( row * 32, column * 32, 1 ),
                  children: [
                    new Text( `row ${row}, column ${column}`, { fill: 'white', centerX: 40, centerY: 10 } )
                  ]
                } );
              } );
            } )
          } );
          box.removeRow( 2 );
          box.removeRow( 2 );
          box.removeColumn( 5 );
          box.removeColumn( 5 );

          return box;
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {} ) );
      } );
    </script>

    <h3 id="GridBox-getters" class="index" data-index="getters">line/cell getters</h3>

    <p>
      Assorted operations can get the row/column of a child Node, or get all of the Nodes contained within a specific
      row or column:
    </p>

    <div id="findCell-example"></div>
    <script type="text/javascript">
      createSandbox( 'findCell-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          const boxes = colors.map( color => new Rectangle( 0, 0, 50, 50, { fill: color } ) );
          const box = new GridBox( {
            children: boxes,
            autoColumns: 3,
            grow: 1
          } );
          box.autoColumns = null;

          // Find a node and insert a row before it
          box.insertRow( box.getRowOfNode( boxes[ 4 ] ), [
            new Rectangle( 0, 0, 50, 50, { fill: 'black' } ),
            new Rectangle( 0, 0, 50, 50, { fill: 'black' } ),
            new Rectangle( 0, 0, 50, 50, { fill: 'black' } )
          ] );

          // Find a node and insert a column before it
          box.insertColumn( box.getColumnOfNode( boxes[ 4 ] ), [
            new Rectangle( 0, 0, 50, 50, { fill: 'black' } ),
            new Rectangle( 0, 0, 50, 50, { fill: 'black' } ),
            new Rectangle( 0, 0, 50, 50, { fill: 'black' } ),
            new Rectangle( 0, 0, 50, 50, { fill: 'black' } ),
            new Rectangle( 0, 0, 50, 50, { fill: 'black' } )
          ] );

          return box;
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {} ) );
      } );
    </script>

    <div id="getLines-example"></div>
    <script type="text/javascript">
      createSandbox( 'getLines-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          const box = new GridBox( {
            rows: _.range( 0, 8 ).map( row => {
              return _.range( 0, 8 ).map( column => {
                return new Rectangle( 0, 0, 20, 20, {
                  fill: new Color( row * 32, column * 32, 1 )
                } );
              } );
            } )
          } );
          box.getNodesInRow( 3 ).forEach( node => { node.opacity = 0.5; } );
          box.getNodesInColumn( 3 ).forEach( node => { node.opacity = 0.5; } );
          return box;
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {} ) );
      } );
    </script>

    <h3 id="GridBox-grow" class="index">grow</h3>

    <p>
      Grids by default don't auto-expand all rows/columns in size to the preferred size, but they can with a similar
      style to FlowBox, where <code>grow</code> applies to both the x and y dimensions:
    </p>

    <div id="grow-grid-example"></div>
    <script type="text/javascript">
      createSandbox( 'grow-grid-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          return new GridBox( {
            grow: 1,
            rows: [
              [
                new Rectangle( 0, 0, 75, 50, {
                  fill: colors[ 0 ]
                } ),
                new Rectangle( 0, 0, 50, 75, {
                  fill: colors[ 2 ]
                } ),
                new Circle( 25, {
                  fill: colors[ 4 ]
                } )
              ],
              [
                new Rectangle( 0, 0, 50, 50, {
                  fill: colors[ 6 ]
                } ),
                new Rectangle( 0, 0, 50, 50, {
                  fill: colors[ 8 ]
                } )
              ]
            ]
          } );
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {
          widthResizable: true,
          heightResizable: true
        } ) );
      } );
    </script>

    <p>
      This space can be grown in specified rows/columns only (and independently) with <code>xGrow</code> or
      <code>yGrow</code>:
    </p>

    <div id="grow-2-grid-example"></div>
    <script type="text/javascript">
      createSandbox( 'grow-2-grid-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          return new GridBox( {
            rows: [
              [
                new Rectangle( 0, 0, 75, 50, {
                  fill: colors[ 0 ],
                  layoutOptions: { xGrow: 1 }
                } ),
                new Rectangle( 0, 0, 50, 75, {
                  fill: colors[ 2 ]
                } ),
                new Circle( 25, {
                  fill: colors[ 4 ]
                } )
              ],
              [
                new Rectangle( 0, 0, 50, 50, {
                  fill: colors[ 6 ]
                } ),
                new Rectangle( 0, 0, 50, 50, {
                  fill: colors[ 8 ],
                  layoutOptions: { yGrow: 1 }
                } )
              ]
            ]
          } );
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {
          widthResizable: true,
          heightResizable: true
        } ) );
      } );
    </script>

    <h3 id="GridBox-stretch" class="index">stretch</h3>

    <p>
      Use <code>stretch</code> (or <code>xStretch</code> / <code>yStretch</code>) to grow a cell dynamically with the
      preferred dimensions to match the row/column. <code>stretch</code> must be paired with a <code>grow</code> value
      to be activated.
    </p>

    <div id="preferred-grid-example"></div>
    <script type="text/javascript">
      createSandbox( 'preferred-grid-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          return new GridBox( {
            rows: [
              [
                new Rectangle( 0, 0, 50, 50, {
                  fill: colors[ 0 ]
                } ),
                new Rectangle( 0, 0, 50, 50, {
                  fill: colors[ 2 ]
                } ),
                new Circle( 25, {
                  fill: colors[ 4 ]
                } )
              ],
              [
                new Rectangle( 0, 0, 50, 50, {
                  fill: colors[ 6 ]
                } ),
                new Rectangle( {
                  sizable: true,
                  localMinimumWidth: 50,
                  localMinimumHeight: 50,
                  fill: 'gray',
                  layoutOptions: { grow: 1, stretch: true }
                } ),
                new Rectangle( 0, 0, 50, 50, {
                  fill: colors[ 8 ]
                } )
              ]
            ]
          } );

          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {
          widthResizable: true,
          heightResizable: true
        } ) );
      } );
    </script>

    <h3 id="GridBox-sizable" class="index">sizable</h3>

    <p>
      Additionally, <code>widthSizable</code> / <code>heightSizable</code> can be used to turn off resizing in a
      component (particularly useful if you want to set a preferredWidth/preferredHeight on it that won't change):
    </p>

    <p>
      In the example below, the rectangle is made to be sizable only for its height. It will have a fixed width,
      but the height will stretch to take up that of its cell.
    </p>

    <p>
      Additionally, if you do not want a child of a GridBox to grow in size at all, you can set <code>sizable: false</code> on it.
    </p>

    <div id="gridResizable-example"></div>
    <script type="text/javascript">
      createSandbox( 'gridResizable-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          return new GridBox( {
            rows: [
              [
                new Rectangle( 0, 0, 50, 50, {
                  fill: colors[ 0 ]
                } ),
                new Rectangle( 0, 0, 50, 50, {
                  fill: colors[ 2 ]
                } ),
                new Circle( 25, {
                  fill: colors[ 4 ]
                } )
              ],
              [
                new Rectangle( 0, 0, 50, 50, {
                  fill: colors[ 6 ]
                } ),
                new Rectangle( {
                  // This rectangle will adjust its height
                  heightSizable: true,
                  layoutOptions: { grow: 1, stretch: true },
                  localMinimumHeight: 50,

                  // But will not adjust its width
                  widthSizable: false,
                  rectWidth: 50,

                  fill: 'gray'
                } ),
                new Rectangle( 0, 0, 50, 50, {
                  fill: colors[ 8 ]
                } )
              ]
            ]
          } );
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {
          widthResizable: true,
          heightResizable: true
        } ) );
      } );
    </script>

    <h3 id="GridBox-align" class="index">align</h3>

    <p>
      Cells can be aligned in a similar way to FlowBox, but in both dimensions:
    </p>

    <div id="align-grid-example"></div>
    <script type="text/javascript">
      createSandbox( 'align-grid-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          return new GridBox( {
            grow: 1,
            rows: [
              [
                new Rectangle( 0, 0, 75, 50, {
                  fill: colors[ 0 ],
                  layoutOptions: { xAlign: 'left', yAlign: 'top' }
                } ),
                new Rectangle( 0, 0, 50, 75, {
                  fill: colors[ 2 ]
                } ),
                new Circle( 25, {
                  fill: colors[ 4 ],
                  layoutOptions: { yAlign: 'bottom' }
                } )
              ],
              [
                new Rectangle( 0, 0, 50, 50, {
                  fill: colors[ 6 ]
                } ),
                new Rectangle( 0, 0, 50, 50, {
                  fill: colors[ 8 ],
                  layoutOptions: { yAlign: 'top' }
                } )
              ]
            ]
          } );
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {
          widthResizable: true,
          heightResizable: true
        } ) );
      } );
    </script>

    <h3 id="GridBox-layoutOptions-size" class="index">horizontalSpan / verticalSpan</h3>

    <p>
      Cells can take up more than one row/column with the <code>horizontalSpan</code> / <code>verticalSpan</code>
      layout options.
    </p>

    <p>
      Each of these default to 1, meaning:
    </p>

    <ul>
      <li>
        <code>horizontalSpan</code> of 1 means "this cell takes up one column"
      </li>
      <li>
        <code>verticalSpan</code> of 1 means "this cell takes up one row"
      </li>
    </ul>

    <p>
      However, one or both values can be increased, and thus will take up multiple rows or columns, e.g.:
    </p>

    <ul>
      <li>
        <code>horizontalSpan</code> of 2 means "this cell takes up two columns", thus it will fill two "spots"
        in the grid, and the actual cell will span across both columns. In the example below, the second (blue-green)
        rectangle (in the upper right) does this. It effectively takes up both the <code>column:1, row:0</code> and
        <code>column:2, row:0</code> spots.
      </li>
      <li>
        <code>horizontalSpan</code> <em>and</em> <code>verticalSpan</code> of 2 means "this cell takes up two columns AND
        two rows". An example is the third rectangle in the below example (blue), which effectively takes up the spots
        <code>column:0, row:1</code>, <code>column:1, row:1</code>, <code>column:0, row:2</code>, and <code>column:1, row:2</code>.
      </li>
    </ul>

    <p>
      The content within these larger cells will use the rectangle that spans all of the rows and columns for layout.
    </p>

    <div id="span-grid-example"></div>
    <script type="text/javascript">
      createSandbox( 'span-grid-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          return new GridBox( {
            children: [
              new Rectangle( 0, 0, 50, 50, {
                fill: colors[ 0 ],
                layoutOptions: { column: 0, row: 0 }
              } ),
              new Rectangle( 0, 0, 100, 50, {
                fill: colors[ 2 ],
                sizable: true,
                localMinimumWidth: 100,
                localMinimumHeight: 50,
                layoutOptions: { column: 1, row: 0, horizontalSpan: 2, stretch: true, grow: 1 }
              } ),
              new Rectangle( 0, 0, 100, 100, {
                fill: colors[ 4 ],
                sizable: true,
                localMinimumWidth: 100,
                localMinimumHeight: 100,
                layoutOptions: { column: 0, row: 1, horizontalSpan: 2, verticalSpan: 2, stretch: true }
              } ),
              new Rectangle( 0, 0, 50, 50, {
                fill: colors[ 6 ],
                layoutOptions: { column: 2, row: 1 }
              } ),
              new Rectangle( 0, 0, 50, 50, {
                fill: colors[ 8 ],
                layoutOptions: { column: 2, row: 2 }
              } ),
              new Circle( 25, {
                fill: colors[ 0 ],
                layoutOptions: { column: 0, row: 3 }
              } ),
              new Circle( 25, {
                fill: colors[ 1 ],
                layoutOptions: { column: 1, row: 3 }
              } ),
              new Circle( 25, {
                fill: colors[ 2 ],
                layoutOptions: { column: 2, row: 3 }
              } )
            ]
          } );
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {
          widthResizable: true,
          heightResizable: true
        } ) );
      } );
    </script>

    <h3 id="GridBox-spacing" class="index">spacing</h3>

    <p>Grids can have consistent internal spacing:</p>

    <div id="grid-spacing-example"></div>
    <script type="text/javascript">
      createSandbox( 'grid-spacing-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          return new GridBox( {
            spacing: 10,
            children: [
              new Rectangle( 0, 0, 50, 50, {
                fill: colors[ 0 ],
                layoutOptions: { column: 0, row: 0 }
              } ),
              new Rectangle( 0, 0, 50, 50, {
                fill: colors[ 2 ],
                layoutOptions: { column: 1, row: 0 }
              } ),
              new Circle( 25, {
                fill: colors[ 4 ],
                layoutOptions: { column: 2, row: 0 }
              } ),
              new Rectangle( 0, 0, 50, 50, {
                fill: colors[ 6 ],
                layoutOptions: { column: 0, row: 1 }
              } ),
              new Rectangle( 0, 0, 50, 50, {
                fill: colors[ 8 ],
                layoutOptions: { column: 1, row: 1 }
              } )
            ]
          } );
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {} ) );
      } );
    </script>

    <p>Grids can have different spacing on each dimension:</p>

    <div id="grid-2-spacing-example"></div>
    <script type="text/javascript">
      createSandbox( 'grid-2-spacing-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          return new GridBox( {
            xSpacing: 5,
            ySpacing: 15,
            children: [
              new Rectangle( 0, 0, 50, 50, {
                fill: colors[ 0 ],
                layoutOptions: { column: 0, row: 0 }
              } ),
              new Rectangle( 0, 0, 50, 50, {
                fill: colors[ 2 ],
                layoutOptions: { column: 1, row: 0 }
              } ),
              new Circle( 25, {
                fill: colors[ 4 ],
                layoutOptions: { column: 2, row: 0 }
              } ),
              new Rectangle( 0, 0, 50, 50, {
                fill: colors[ 6 ],
                layoutOptions: { column: 0, row: 1 }
              } ),
              new Rectangle( 0, 0, 50, 50, {
                fill: colors[ 8 ],
                layoutOptions: { column: 1, row: 1 }
              } )
            ]
          } );
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {} ) );
      } );
    </script>

    <p>Grids can have custom arrays adjusting the spacing between every single row/column:</p>

    <div id="grid-3-spacing-example"></div>
    <script type="text/javascript">
      createSandbox( 'grid-3-spacing-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          return new GridBox( {
            xSpacing: [ 10, 0 ],
            ySpacing: [ 5 ],
            children: [
              new Rectangle( 0, 0, 50, 50, {
                fill: colors[ 0 ],
                layoutOptions: { column: 0, row: 0 }
              } ),
              new Rectangle( 0, 0, 50, 50, {
                fill: colors[ 2 ],
                layoutOptions: { column: 1, row: 0 }
              } ),
              new Circle( 25, {
                fill: colors[ 4 ],
                layoutOptions: { column: 2, row: 0 }
              } ),
              new Rectangle( 0, 0, 50, 50, {
                fill: colors[ 6 ],
                layoutOptions: { column: 0, row: 1 }
              } ),
              new Rectangle( 0, 0, 50, 50, {
                fill: colors[ 8 ],
                layoutOptions: { column: 1, row: 1 }
              } )
            ]
          } );
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {} ) );
      } );
    </script>

    <h3 id="GridBox-margins" class="index">Margins</h3>

    <p>Similar to FlowBox, grids can have margins applied to all elements:</p>

    <div id="margin-1-spacing-example"></div>
    <script type="text/javascript">
      createSandbox( 'margin-1-spacing-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          return new GridBox( {
            margin: 5,
            children: [
              new Rectangle( 0, 0, 50, 50, {
                fill: colors[ 0 ],
                layoutOptions: { column: 0, row: 0 }
              } ),
              new Rectangle( 0, 0, 50, 50, {
                fill: colors[ 2 ],
                layoutOptions: { column: 1, row: 0 }
              } ),
              new Circle( 25, {
                fill: colors[ 4 ],
                layoutOptions: { column: 2, row: 0 }
              } ),
              new Rectangle( 0, 0, 50, 50, {
                fill: colors[ 6 ],
                layoutOptions: { column: 0, row: 1 }
              } ),
              new Rectangle( 0, 0, 50, 50, {
                fill: colors[ 8 ],
                layoutOptions: { column: 1, row: 1 }
              } )
            ]
          } );
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {} ) );
      } );
    </script>

    <p>Or can have margins specified on individual elements:</p>

    <div id="margin-2-spacing-example"></div>
    <script type="text/javascript">
      createSandbox( 'margin-2-spacing-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          return new GridBox( {
            yAlign: 'top',
            children: [
              new Rectangle( 0, 0, 50, 50, {
                fill: colors[ 0 ],
                layoutOptions: { column: 0, row: 0 }
              } ),
              new Rectangle( 0, 0, 50, 50, {
                fill: colors[ 2 ],
                layoutOptions: { column: 1, row: 0, topMargin: 10 }
              } ),
              new Circle( 25, {
                fill: colors[ 4 ],
                layoutOptions: { column: 2, row: 0 }
              } ),
              new Rectangle( 0, 0, 50, 50, {
                fill: colors[ 6 ],
                layoutOptions: { column: 0, row: 1 }
              } ),
              new Rectangle( 0, 0, 50, 50, {
                fill: colors[ 8 ],
                layoutOptions: { column: 1, row: 1 }
              } )
            ]
          } );
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {} ) );
      } );
    </script>

    <h2 id="layoutOrigin" class="index">layoutOrigin</h2>

    <p>
      FlowBox/GridBox will typically lay out content so that the origin (0,0) of the FlowBox/GridBox is at the upper-left.
      There are some exceptions to this.
    </p>

    <p>The default behavior:</p>

    <div id="defaultOrigin-example"></div>
    <script type="text/javascript">
      createSandbox( 'defaultOrigin-example', ( scene, stepEmitter, display ) => {
        const originSize = 50;
        const originNode = new Path( new Shape().moveTo( -originSize, 0 ).lineTo( originSize, 0 ).moveTo( 0, originSize ).lineTo( 0, -originSize ), {
          stroke: 'rgba(0,0,0,0.5)'
        } );
        const box = ( () => {
          /*START*/
          return new GridBox( {
            opacity: 0.5,
            children: colors.map( color => new Rectangle( 0, 0, 40, 40, { fill: color } ) ),
            autoColumns: 3
          } );
          /*END*/
        } )();
        scene.addChild( new AlignBox( new Node( {
          children: [ originNode, box ]
        } ) ) );
      } );
    </script>

    <p>
      When using <code>align: origin</code>, the Y-origin of the entire FlowBox will be at the Y-origin of the first wrapped line of Nodes.
    </p>

    <p>
      NOTE: The origin of the Circle nodes below is at the center of the Circle. The origin of the Text nodes below
      (created by <code>bigText</code>/<code>normalText</code>) is the left end of the baseline of the text (since the word
      "Text" doesn't have any <a href="https://en.wikipedia.org/wiki/Descender">descenders</a>, this will be at the bottom).
    </p>

    <div id="flowOrigin-example"></div>
    <script type="text/javascript">
      createSandbox( 'flowOrigin-example', ( scene, stepEmitter, display ) => {
        const originSize = 50;
        const originNode = new Path( new Shape().moveTo( -originSize, 0 ).lineTo( originSize, 0 ).moveTo( 0, originSize ).lineTo( 0, -originSize ), {
          stroke: 'rgba(0,0,0,0.5)'
        } );
        const normalText = ( str, options ) => new Text( str, merge( {
          font: new Font( { size: 12 } )
        }, options ) );
        const bigText = ( str, options ) => new Text( str, merge( {
          font: new Font( { size: 18, weight: 'bold' } )
        }, options ) );
        const box = ( () => {
          /*START*/
          return new HBox( {
            align: 'origin',
            spacing: 5,
            lineSpacing: 5,
            children: [
              new Circle( 20, { fill: 'rgba(255,0,0,0.3)' } ),
              bigText( 'Text' ),
              normalText( 'Text' ),
              new Circle( 20, { fill: 'rgba(255,0,0,0.3)' } ),
              bigText( 'Text' ),
              normalText( 'text' ),
              new Circle( 20, { fill: 'rgba(255,0,0,0.3)' } ),
              bigText( 'Text' ),
              normalText( 'text' ),
              new Circle( 20, { fill: 'rgba(255,0,0,0.3)' } ),
              bigText( 'Text' ),
              normalText( 'text' )
            ],
            wrap: true,
            preferredWidth: 170,
            widthSizable: false,
            justify: 'left'
          } );
          /*END*/
        } )();
        scene.addChild( new AlignBox( new Node( {
          children: [ originNode, box ]
        } ) ) );
      } );
    </script>

    <p>
      When using <code>align: origin</code>, the origin of the entire GridBox will be at the origin of the first cell:
    </p>

    <div id="gridOrigin-example"></div>
    <script type="text/javascript">
      createSandbox( 'gridOrigin-example', ( scene, stepEmitter, display ) => {
        const originSize = 50;
        const originNode = new Path( new Shape().moveTo( -originSize, 0 ).lineTo( originSize, 0 ).moveTo( 0, originSize ).lineTo( 0, -originSize ), {
          stroke: 'rgba(0,0,0,0.5)'
        } );
        const box = ( () => {
          /*START*/
          return new GridBox( {
            xAlign: 'origin',
            yAlign: 'origin',
            children: [
              new Circle( 20, { fill: 'rgba(255,0,0,0.3)', layoutOptions: { column: 0, row: 0 } } ),
              new Circle( 10, { fill: 'rgba(255,0,0,0.3)', layoutOptions: { column: 1, row: 0 } } ),
              new Circle( 15, { fill: 'rgba(255,0,0,0.3)', layoutOptions: { column: 0, row: 1 } } ),
              new Circle( 25, { fill: 'rgba(255,0,0,0.3)', layoutOptions: { column: 1, row: 1 } } )
            ]
          } );
          /*END*/
        } )();
        scene.addChild( new AlignBox( new Node( {
          children: [ originNode, box ]
        } ) ) );
      } );
    </script>

    <p>The position of this origin can be shifted by using <code>layoutOrigin</code></p>

    <div id="layoutOrigin-example"></div>
    <script type="text/javascript">
      createSandbox( 'layoutOrigin-example', ( scene, stepEmitter, display ) => {
        const originSize = 50;
        const originNode = new Path( new Shape().moveTo( -originSize, 0 ).lineTo( originSize, 0 ).moveTo( 0, originSize ).lineTo( 0, -originSize ), {
          stroke: 'rgba(0,0,0,0.5)'
        } );
        const box = ( () => {
          /*START*/
          return new GridBox( {
            layoutOrigin: new Vector2( 40, 20 ),
            opacity: 0.5,
            children: colors.map( color => new Rectangle( 0, 0, 40, 40, { fill: color } ) ),
            autoColumns: 3
          } );
          /*END*/
        } )();
        scene.addChild( new AlignBox( new Node( {
          children: [ originNode, box ]
        } ) ) );
      } );
    </script>

    <h2 id="AlignBox" class="index">AlignBox</h2>

    <h3 class="index">alignBounds</h3>

    <p>AlignBox on its own will position content within a specific bounding box (its <code>alignBounds</code>):</p>

    <div id="simpleAlignBox-example"></div>
    <script type="text/javascript">
      createSandbox( 'simpleAlignBox-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          const rect = new Rectangle( 0, 0, 50, 50, {
            fill: 'red'
          } );
          return new AlignBox( rect, {
            alignBounds: new Bounds2( 0, 0, 100, 100 )
          } );
          /*END*/
        } )();
        scene.addChild( new Node( {
          children: [
            box,
            new Rectangle( {
              rectBounds: box.bounds,
              stroke: 'black'
            } )
          ]
        } ) );
      } );
    </script>

    <h3 class="index">Alignment</h3>

    <p>Content can be aligned within this:</p>

    <div id="alignBoxAlign-example"></div>
    <script type="text/javascript">
      createSandbox( 'alignBoxAlign-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          const rect = new Rectangle( 0, 0, 50, 50, {
            fill: 'red'
          } );
          return new AlignBox( rect, {
            alignBounds: new Bounds2( 0, 0, 100, 100 ),
            xAlign: 'left',
            yAlign: 'bottom'
          } );
          /*END*/
        } )();
        scene.addChild( new Node( {
          children: [
            box,
            new Rectangle( {
              rectBounds: box.bounds,
              stroke: 'black'
            } )
          ]
        } ) );
      } );
    </script>

    <h3 class="index">Margins</h3>

    <p>And margins can be specified on each side:</p>

    <div id="alignBoxMargins-example"></div>
    <script type="text/javascript">
      createSandbox( 'alignBoxMargins-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          const rect = new Rectangle( 0, 0, 50, 50, {
            fill: 'red'
          } );
          return new AlignBox( rect, {
            alignBounds: new Bounds2( 0, 0, 100, 100 ),
            xAlign: 'left',
            yAlign: 'bottom',
            leftMargin: 5,
            bottomMargin: 10
          } );
          /*END*/
        } )();
        scene.addChild( new Node( {
          children: [
            box,
            new Rectangle( {
              rectBounds: box.bounds,
              stroke: 'black'
            } )
          ]
        } ) );
      } );
    </script>

    <p>
      Margins can also be used on their own (without <code>alignBounds</code> / <code>align</code>) to just create a
      Node with larger bounds:
    </p>

    <div id="alignBoxOnlyMargins-example"></div>
    <script type="text/javascript">
      createSandbox( 'alignBoxOnlyMargins-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          const rect = new Rectangle( 0, 0, 50, 50, {
            fill: 'red'
          } );
          return new AlignBox( rect, {
            topMargin: 30,
            xMargin: 10
          } );
          /*END*/
        } )();
        scene.addChild( new Node( {
          children: [
            box,
            new Rectangle( {
              rectBounds: box.bounds,
              stroke: 'black'
            } )
          ]
        } ) );
      } );
    </script>

    <p>AlignBox can also be used with preferred dimensions instead of an explicit <code>alignBounds</code>:</p>

    <div id="alignBoxPreferred-example"></div>
    <script type="text/javascript">
      createSandbox( 'alignBoxPreferred-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          const rect = new Rectangle( 0, 0, 50, 50, {
            fill: 'red'
          } );
          return new AlignBox( rect, {
            preferredWidth: 100,
            preferredHeight: 100,
            xAlign: 'left',
            yAlign: 'bottom'
          } );
          /*END*/
        } )();
        scene.addChild( new Node( {
          children: [
            box,
            new Rectangle( {
              rectBounds: box.bounds,
              stroke: 'black'
            } )
          ]
        } ) );
      } );
    </script>

    <p>
      and can be dynamically resizable (off by default because it's usually not used for that purpose in legacy
      code):
    </p>

    <div id="alignBoxSizable-example"></div>
    <script type="text/javascript">
      createSandbox( 'alignBoxSizable-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          const rect = new Rectangle( 0, 0, 50, 50, {
            fill: 'red'
          } );
          return new AlignBox( rect, {
            xAlign: 'left',
            yAlign: 'bottom',
            sizable: true,
            margin: 10
          } );
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {
          widthResizable: true,
          heightResizable: true
        } ) );
      } );
    </script>

    <h3 class="index">AlignGroup</h3>

    <p>
      It is often the case where you want to wrap a bunch of different Nodes in AlignBoxes, such that they all have the
      same bounds (e.g. a set of icons for buttons that you want to be the same size, or need to align things on top of
      each other and toggle visibility).
    </p>

    <p>
      AlignGroup handles this with ease. Once you have an AlignGroup, AlignBoxes can be created with `alignGroup.createBox( content, options )`.
      This has the full power of the AlignBox API, however the AlignGroup controls the bounds of the boxes, so that
      their widths and heights are all the same.
    </p>

    <div id="alignGroup-example"></div>
    <script type="text/javascript">
      createSandbox( 'alignGroup-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/

          // AlignGroup by default matches both width and height
          const alignGroup = new AlignGroup();

          // Wrap some icons in AlignBoxes
          const iconA = alignGroup.createBox( new Rectangle( 0, 0, 50, 30, { fill: colors[ 0 ] } ) );
          const iconB = alignGroup.createBox( new Rectangle( 0, 0, 30, 50, { fill: colors[ 2 ] } ) );
          const iconC = alignGroup.createBox( new Circle( 20, { fill: colors[ 4 ] } ) );

          return new HBox( {
            spacing: 2,
            children: [ iconA, iconB, iconC ].map( icon => {
              // Shows a background behind each item (to see the AlignBox bounds)
              return new Node( {
                children: [
                  Rectangle.bounds( icon.bounds, { fill: '#ccc' } ),
                  icon
                ]
              } );
            } )
          } );
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {
          widthResizable: true,
          heightResizable: true
        } ) );
      } );
    </script>

    <p>
      It is possible to create an AlignGroup which only matches the width OR height (not both), by constructing with
      `matchHorizontal:false` or `matchVertical:false`. In this case, each AlignBox will use its own Node's width or
      height (for the dimension that is not matched). The below example shows this with `matchHorizontal:false`.
    </p>

    <div id="alignGroup-example2"></div>
    <script type="text/javascript">
      createSandbox( 'alignGroup-example2', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/

          // AlignGroup by default matches both width and height
          const alignGroup = new AlignGroup( {
            matchHorizontal: false
          } );

          // Wrap some icons in AlignBoxes
          const iconA = alignGroup.createBox( new Rectangle( 0, 0, 50, 30, { fill: colors[ 0 ] } ) );
          const iconB = alignGroup.createBox( new Rectangle( 0, 0, 30, 50, { fill: colors[ 2 ] } ) );
          const iconC = alignGroup.createBox( new Circle( 20, { fill: colors[ 4 ] } ) );

          return new HBox( {
            spacing: 2,
            children: [ iconA, iconB, iconC ].map( icon => {
              // Shows a background behind each item (to see the AlignBox bounds)
              return new Node( {
                children: [
                  Rectangle.bounds( icon.bounds, { fill: '#ccc' } ),
                  icon
                ]
              } );
            } )
          } );
          /*END*/
        } )();
        scene.addChild( new ResizableNode( display, box, {
          widthResizable: true,
          heightResizable: true
        } ) );
      } );
    </script>

    <h2 id="Constraint" class="index">Constraint</h2>

    <p>
      NOTE: Constraints are lower-level, and besides ManualConstraint will likely not be needed in most cases.
    </p>

    <p>
      Constraints are the foundational layer that handles layout logic for scenery elements. If you search through the
      PhET codebase you can find constraints such as: <code>ButtonConstraint</code>,<code>CarouselConstraint</code>,
      <code>SliderConstraint</code>, and many more. All of these constraints extend <code>LayoutConstraint</code>, and
      importantly, override the method
      <code>layout</code>. Its important to understand that the motor of the layout logic is housed in a constraint, not
      only for debugging, but
      also to empower developers to use existing constraints or create their own constraint as is desirable.
    </p>

    <p>
      In general, try to not place a Node in multiple layout containers, as this can lead to unexpected behavior
      (might trigger infinite loops when the layout constraints fight back-and-forth with where a Node should be placed).
      It will generally be detected (in the case of FlowBox/GridBox) and will trigger an eager error.
    </p>

    <h3 id="ManualConstraint" class="index">ManualConstraint</h3>

    <p>
      Sometimes more fine-grained control is needed over the layout of Nodes than what is provided by the built-in layout
      containers.
    </p>

    <p>
      ManualConstraint is for hooking up imperative-style layout code (e.g. <code>someNode.left = otherNode.right</code>)
      so that
      it correctly auto-updates whenever one of those values may have changed. It also works across different Node
      parents and coordinate frames. A good indication that ManualConstraint may be useful is when a developer is
      linking to multiple
      <code>BoundsProperty</code>, or connecting view positions for elements in different coordinate frames.
    </p>

    <p>
      Some layout examples where ManualConstraint is particularly useful:
    </p>

    <ul>
      <li>
        Aligning nodes in a single dimension, especially when the nodes are in different coordinate frames.
      </li>
      <li>
        Custom layout logic that is not easily expressed with the built-in layout containers.
      </li>
    </ul>

    <p>
      It will also robustly handle cases where the Nodes are not connected (and will not run the layout), so the
      constraint can be created before all of the Node structure is finalized.
    </p>

    <p>
      Children are dynamically added/removed in this demo, and <code>child1</code> is constantly translated.
    </p>

    <div id="manualConstraint-example"></div>
    <script type="text/javascript">
      createSandbox( 'manualConstraint-example', ( scene, stepEmitter, display ) => {

        const box = ( () => {
          /*START*/
          const background = new Rectangle( 0, 0, 400, 200, {
            fill: '#ccc'
          } );

          const child1 = createLabeledBox( 'Child 1', colors[ 2 ], 50, 50 );
          const child2 = createLabeledBox( 'Child 2', colors[ 4 ], 50, 50 );
          const child3 = createLabeledBox( 'Child 3', colors[ 5 ], 50, 50 );

          ManualConstraint.create( background, [ child1, child2 ], ( child1Proxy, child2Proxy ) => {
            child2Proxy.leftCenter = child1Proxy.rightCenter;
          } );
          ManualConstraint.create( background, [ child2, child3 ], ( child2Proxy, child3Proxy ) => {
            child3Proxy.left = child2Proxy.right;
          } );
          ManualConstraint.create( background, [ child1, child3 ], ( child1Proxy, child3Proxy ) => {
            child3Proxy.centerY = child1Proxy.centerY;
          } );

          const nodes = [
            new Node( { x: 50, y: 50, children: [ child1 ] } ),
            new Node( { scale: 2, y: 20, children: [ child2 ] } ),
            new Node( {
              matrix: phet.dot.Matrix3.rowMajor(
                0.5, 0, 0,
                0, 1, 0,
                0, 0, 1 ), children: [ child3 ]
            } )
          ];

          let elapsedTime = 0;

          stepEmitter.addListener( dt => {
            elapsedTime += dt;
            child1.translation = Vector2.createPolar( 10, 2 * elapsedTime );

            background.children = [
              ...( elapsedTime % 3 < 2 ? [ nodes[ 0 ] ] : [] ),
              ...( elapsedTime % 5 < 4 ? [ nodes[ 1 ] ] : [] ),
              ...( elapsedTime % 7 < 5 ? [ nodes[ 2 ] ] : [] )
            ];
          } );

          /*END*/
          return background;
        } )();
        scene.addChild( new ResizableNode( display, box, {} ) );
      } );
    </script>

    <h3 id="FlowConstraint" class="index">FlowConstraint</h3>

    <p>
      Want to use a FlowBox (HBox/VBox), but the nodes don't have the same parent? Use FlowConstraint. It is the layout
      constraint used by FlowBox.
    </p>

    <p>
      Example of using FlowBox-like layout with disconnected Nodes that share some ancestor (with qualities similar to ManualConstraint):
    </p>

    <div id="flowConstraint-example"></div>
    <script type="text/javascript">
      createSandbox( 'flowConstraint-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          const firstChild = createLabeledBox( 'First child', '#faa', 150, 30 );
          const secondChild = createLabeledBox( 'Second child', '#afa', 150, 30 );
          const thirdChild = createLabeledBox( 'Third child', '#aaf', 150, 30 );

          const firstParent = new Node( {
            children: [
              firstChild,
              createLabeledBox( 'First parent', null, 400, 200 )
            ]
          } );
          const secondParent = new Node( {
            children: [
              secondChild,
              createLabeledBox( 'Second parent', null, 400, 200 )
            ],
            scale: 0.75
          } );
          const thirdParent = new Node( {
            children: [
              thirdChild,
              createLabeledBox( 'Third parent', null, 400, 200 )
            ],
            scale: 0.5
          } );

          const scene = new Node( {
            children: [ firstParent, secondParent, thirdParent ]
          } );

          // Directly create the constraint, specifying a layoutOrigin to position the content
          const constraint = new FlowConstraint( scene, {
            layoutOriginProperty: new Property( new Vector2( 10, 10 ) ),
            align: 'top',
            spacing: 10
          } );

          // For Flow constraints, we need to know the order, so cells are inserted at specific indices. They can be
          // removed later
          constraint.insertCell( 0, new FlowCell( constraint, firstChild, null ) );
          constraint.insertCell( 1, new FlowCell( constraint, secondChild, null ) );
          constraint.insertCell( 2, new FlowCell( constraint, thirdChild, null ) );
          constraint.updateLayout();
          /*END*/
          return scene;
        } )();
        scene.addChild( new ResizableNode( display, box, {} ) );
      } );
    </script>

    <h3 id="GridConstraint" class="index">GridConstraint</h3>

    <p>
      Want to use a GridBox, but the nodes don't have the same parent? Use GridConstraint. It is the layout
      constraint used by GridBox.
    </p>

    <p>
      Example of using GridBox-like layout with disconnected Nodes that share some ancestor (with qualities similar to ManualConstraint):
    </p>

    <div id="gridConstraint-example"></div>
    <script type="text/javascript">
      createSandbox( 'gridConstraint-example', ( scene, stepEmitter, display ) => {
        const box = ( () => {
          /*START*/
          const firstChild = createLabeledBox( 'First child', '#faa', 150, 30 );
          const secondChild = createLabeledBox( 'Second child', '#afa', 150, 30 );
          const thirdChild = createLabeledBox( 'Third child', '#aaf', 150, 30 );
          firstChild.layoutOptions = { row: 0, column: 0 };
          secondChild.layoutOptions = { row: 1, column: 0 };
          thirdChild.layoutOptions = { row: 0, column: 1 };

          const firstParent = new Node( {
            children: [
              firstChild,
              createLabeledBox( 'First parent', null, 400, 200 )
            ]
          } );
          const secondParent = new Node( {
            children: [
              secondChild,
              createLabeledBox( 'Second parent', null, 400, 200 )
            ],
            scale: 0.75
          } );
          const thirdParent = new Node( {
            children: [
              thirdChild,
              createLabeledBox( 'Third parent', null, 400, 200 )
            ],
            scale: 0.5
          } );

          const scene = new Node( {
            children: [ firstParent, secondParent, thirdParent ]
          } );

          // Directly create the constraint, specifying a layoutOrigin to position the content
          const constraint = new GridConstraint( scene, {
            layoutOriginProperty: new Property( new Vector2( 10, 10 ) ),
            xAlign: 'left',
            yAlign: 'top',
            spacing: 10
          } );

          // For the grid, cells are created and added (they can be removed/disposed later).
          constraint.addCell( new GridCell( constraint, firstChild, null ) );
          constraint.addCell( new GridCell( constraint, secondChild, null ) );
          constraint.addCell( new GridCell( constraint, thirdChild, null ) );
          constraint.updateLayout();
          /*END*/
          return scene;
        } )();
        scene.addChild( new ResizableNode( display, box, {} ) );
      } );
    </script>

  </div>
  <div class="span2"></div>
</div>

<footer style="background-color: #191919;">
  <a class="brand" href="/scenery">Scenery</a>
</footer>

<script>
  generateAPIList();
</script>
</body>
</html>
